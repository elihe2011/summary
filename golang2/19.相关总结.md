# 1. go 

```bash
GOROOT Golang的安装目录
GOPATH 工作区目录，默认 $HOME/go，有三个目录(src, pkg, bin)，其中pkg存放编译静态库文件
GOBIN  编译后二进制程序安装目录。默认 GOPATH/bin， 当执行 go install 命令时，会将编译后的二进制程序放入GOBIN中
```



## 1.1 `go build`

```bash
go build:
-o output 指定编译输出的名称，代替默认的包名。
-i install 安装作为目标的依赖关系的包(用于增量编译提速)。
-a 完全编译，不理会-i产生的.a文件
-n 仅打印输出build需要的命令，不执行
-p n 开多少核cpu来并行编译，默认等于cpu逻辑数
-race 检测数据竞争状态，只支持 linux/amd64, freebsd/amd64, darwin/amd64 和 windows/amd64.
-v 打印出被编译的包名
-work 打印临时工作目录的名称，并在退出时不删除它
-x 同时打印输出执行的命令名（-n）

-gcflags 'arg list' 垃圾回收参数
	-N 禁止编译优化
	-l 禁止内联,禁止内联也可以一定程度上减小可执行程序大小
	可以使用 `go tool compile --help` 查看 gcflags 各参数含义

-ldflags 'flag list'
    '-s -w': 压缩编译后的体积
    -s: 去掉符号表
    -w: 去掉调试信息，不能gdb调试了

-linkshared  链接到以前使用创建的共享库 -buildmode=shared.
-tags 'tag list' 构建出带tag的版本.
```



### 1.1.1 减小可执行程序

```
go build -ldflags '-w -s'
```



### 1.1.2 禁止gc优化和内联

```
go build -gcflags '-N -l'
```



### 1.1.3 交叉编译

解决的是目标程序问题, 是**目的**。

交叉编译不支持 CGO ，要禁用它

```bash
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build
CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build
    
GOOS：darwin、freebsd、linux、windows
GOARCH：386、amd64、arm
```



### 1.1.4 条件编译

解决的是代码适配问题, 是**过程**。

```go
// +build linux,386 darwin,!cgo      (linux AND 386) OR (darwin AND (NOT cgo))

// +build linux darwin
// +build 386            (linux OR darwin) AND 386

// +build !jsoniter
```





## 1.2 `go test`

```bash
go test -v
go test -race     竞争检测
go test -run=TestFib
go test -coverprofile=c.out && go tool cover -html=c.out  
```



## 1.3 `go vet`

go vet: 检查源码中静态错误。-n: 只打印流程中执行的命令但不真正执行它们。-n标记也用于打印流程中执行的命令，但不会取消这些命令的执行 



## 1.4 `go install`

1. go build只对main包有效，在当前目录编译生成一个可执行的二进制文件（依赖包生成的静态库文件放在$GOPATH/pkg）。
2. go install一般生成静态库文件放在$GOPATH/pkg目录下，文件扩展名a. 



# 2. 内存逃逸

## 2.1 什么是内存逃逸？

本该分配到栈上的数据，分配到了堆上。

引起内存逃逸的**典型情况**：

- 方法内局部变量指针返回
- 发送指针到channel中
- 切片中存储指针
- slice 扩容时，超过原始容量
- 在 interface 类型上调用方法：interface 的方法都是动态调度的，只在真正运行时才知道。例如  io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。



检测内存逃逸：

```bash
go build -gcflags=-m .\main.go
```



## 2.2 如何避免内存逃逸？

在`runtime/stubs.go`有个函数叫`noescape`。`noescape`可以在逃逸分析中**隐藏一个指针**。让这个指针在逃逸分析中**不会被检测为逃逸**。

一句话：通过uintptr类型作为中介，屏蔽实际指针的传递，因为uintptr只是个值

```go
func noescape(p unsafe.Pointer) unsafe.Pointer {
     x := uintptr(p)
     return unsafe.Pointer(x ^ 0)
}
```

实例：

```go
type A struct {
	S *string
}

func (f *A) String() string {
	return *f.S
}

type ATrick struct {
	S unsafe.Pointer
}

func (f *ATrick) String() string {
	return *(*string)(f.S)
}

func NewA(s string) A {
	return A{S: &s}
}

func NewATrick(s string) ATrick {
	return ATrick{S: noescape(unsafe.Pointer(&s))}
}

func noescape(p unsafe.Pointer) unsafe.Pointer {
	x := uintptr(p)
	return unsafe.Pointer(x ^ 0)
}

func main() {
	s := "hello"
	f1 := NewA(s)
	f2 := NewATrick(s)

	s1 := f1.String()
	s2 := f2.String()

	fmt.Println(s1 + s2)
}
```



# 3. 切片拷贝

拷贝大切片一定比小切片代价大吗？

并不是，所有切片的大小相同；**三个字段**（一个 uintptr，两个int）。切片中的第一个字是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字。所以 **拷贝大切片跟小切片的代价应该是一样的**。

```go
type SliceHeader struct {
 Data uintptr
 Len  int
 Cap  int
}
```



# 4. 字符串转byte数组

字符串转成byte数组，会发生内存拷贝吗？

字符串转成切片，会产生拷贝。只要是发生类型强转都会发生内存拷贝。

频繁的内存拷贝操作导致性能下降。**如何避免在字符串转成切片的时候不用发生拷贝呢？**

```go
func main() {
	s := "abc"

	// s => &StringHeader
	h1 := (*reflect.StringHeader)(unsafe.Pointer(&s))

	// &StringHeader => &SliceHeader
	h2 := (*[]byte)(unsafe.Pointer(h1))

	// &SliceHeader => []byte
	bs := *h2

	// cap 值未设置
	fmt.Printf("len=%v, cap=%v, bs=%v\n", len(bs), cap(bs), bs)
}

type StringHeader struct {
 Data uintptr
 Len  int
}

type SliceHeader struct {
 Data uintptr
 Len  int
 Cap  int
}
```



# 5. 三种指针

- unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；
- 而uintptr是用于指针运算的，GC 不把 uintptr 当指针，也就是说 uintptr 无法持有对象， uintptr 类型的目标会被回收；
- unsafe.Pointer 可以和 普通指针 进行相互转换；
- unsafe.Pointer 可以和 uintptr 进行相互转换。



# 6. for-select 通道关闭

`for`循环`select`时，如果通道已经关闭会怎么样？如果`select`中的`case`只有一个，又会怎么样？

- for循环`select`时，如果其中一个case通道已经关闭，则每次都会执行到这个case。
- 如果select里边只有一个case，而这个case被关闭了，则会出现死循环。

```go
func main() {
	ch := make(chan int)

	go func() {
		time.Sleep(time.Second)
		ch <- 10
		close(ch)
	}()

	for {
		select {

		// channel被关闭，则会一直命中该case
		case v, ok := <-ch:
			log.Printf("receive: v=%v, ok=%v\n", v, ok)
			time.Sleep(500 * time.Millisecond)

			// 将被关闭的channel置为nil，将不会命中
			if !ok {
				ch = nil
			}

		// 未命中时，则执行default。如果没有default且所有case的channel被关闭，将陷入死循环
		default:
			log.Println("no data")
			time.Sleep(500 * time.Millisecond)
		}
	}
}
```



cmd的Start和Run方法的区别：

Start执行不会等待命令完成，Run会阻塞等待命令完成。

```
cmd := exec.Command("sleep", "10")
err := cmd.Run()  //执行到此处时会阻塞等待10秒
err := cmd.Start()   //如果用start则直接向后运行
if err != nil {
    log.Fatal(err)
}
err = cmd.Wait()   //执行Start会在此处等待10秒
```



# 7. 上下文

```go
context.Context
两个根节点：context.Background(), context.TODO()
四个方法：context.WithCancel(), context.WithTimeout(), context.WithDeadline(), context.WithValue()
```



# 9. interface

interface定义服务，具有那些功能，服务的实现可以是很多种，可以无缝切换结构实现，让使用者关注”这个东西怎么用“，而不用关注具体是什么吧，统一的接口也可以让你的程序拆装更方便。



# 10. 空结构体

golang 中的空结构体 struct{}：

1. 做控制而非数据信息： chan struct{}
2. 实现set: map[string]struct{} 



# 11. 有用的函数

## 11.1 中文字符串位置

```go
func Utf8Index(s, substr string) int {
	index := strings.Index(s, substr)
	if index < 0 {
		return index
	}

	return utf8.RuneCountInString(s[:index])
}
```

