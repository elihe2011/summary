# 1. MySQL

## 1.1 标准库 `database/sql`

提供了保证SQL或类SQL数据库的泛用接口。原生支持连接池，并发安全：

```go
type DB struct {
    
}

func Open(driverName, dataSourceName string) (*DB, error)
```



## 1.2 mysql 驱动

```bash
go get -u github.com/go-sql-driver/mysql

# 查询
db.QueryRow()
db.Query()

# 增、删、改
db.Exec()

# 预处理：一次编译多次执行，防止SQL注入
db.Prepare()

# 事务
tx, err := db.Begin()
tx.Exec()
tx.Rollback()
tx.Commit()
```

示例：

```go
import (
	"database/sql"
	"fmt"

	_ "github.com/go-sql-driver/mysql"
)

var db *sql.DB

func init() {
	// data source name
	dsn := "root:123456@tcp(192.168.31.60:3306)/mydb"

	var err error

	// 校验 dsn 格式是否正确
	db, err = sql.Open("mysql", dsn)
	if err != nil {
		panic(err)
	}

	// 尝试与数据库建立连接 (校验 dsn 参数是否正确)
	err = db.Ping()
	if err != nil {
		panic(err)
	}

	// 连接池最大连接数
	db.SetMaxOpenConns(10)

	// 最大空闲连接数
	db.SetMaxIdleConns(5)
}

type User struct {
	Id   int    `db:"id"`
	Name string `db:"name"`
	Age  int8   `db:"age"`
}

func queryOneRow() {
	var user User
	sqlStr := `select id, name, age from user where id=?`

	err := db.QueryRow(sqlStr, 1).Scan(&user.Id, &user.Name, &user.Age)
	if err != nil {
		panic(err)
	}

	fmt.Printf("%v\n", user)
}

func queryManyRow() {
	sqlStr := "select * from user where id > ?"

	rows, err := db.Query(sqlStr, 0)
	if err != nil {
		panic(err)
	}
	defer rows.Close() // 不关闭，连接不会自动释放

	for rows.Next() {
		var user User
		err := rows.Scan(&user.Id, &user.Name, &user.Age)
		if err != nil {
			panic(err)
		}
		fmt.Printf("%v\n", user)
	}
}

func insertRow() {
	sqlStr := "insert into user(name, age) values(?,?)"

	result, err := db.Exec(sqlStr, "张三", 20)
	if err != nil {
		panic(err)
	}

	affected, _ := result.RowsAffected()
	insertId, _ := result.LastInsertId()
	fmt.Printf("rows affected: %d, last insert id: %d\n", affected, insertId)
}

func updateRow() {
	sqlStr := "update user set name=?, age=? where id=?"
	result, err := db.Exec(sqlStr, "李四", 17, 4)
	if err != nil {
		panic(err)
	}

	affected, _ := result.RowsAffected()
	insertId, _ := result.LastInsertId()
	fmt.Printf("rows affected: %d, last insert id: %d\n", affected, insertId)
}

func deleteRow() {
	sqlStr := "delete from user where id > ?"
	result, err := db.Exec(sqlStr, 2)
	if err != nil {
		panic(err)
	}

	affected, _ := result.RowsAffected()
	insertId, _ := result.LastInsertId()
	fmt.Printf("rows affected: %d, last insert id: %d\n", affected, insertId)
}

// 预处理，一次编译多次执行，提高效率，另外可防止sql注入
func prepareQuery() {
	sqlStr := "select * from user where id=?"
	stmt, err := db.Prepare(sqlStr)
	if err != nil {
		panic(err)
	}
	defer stmt.Close()

	rows, err := stmt.Query(1)
	if err != nil {
		panic(err)
	}
	defer rows.Close()

	for rows.Next() {
		var user User
		err := rows.Scan(&user.Id, &user.Name, &user.Age)
		if err != nil {
			panic(err)
		}

		fmt.Printf("%v\n", user)
	}

	// 再次查询
	rows, err = stmt.Query(2)
	if err != nil {
		panic(err)
	}

	for rows.Next() {
		var user User
		err := rows.Scan(&user.Id, &user.Name, &user.Age)
		if err != nil {
			panic(err)
		}

		fmt.Printf("%v\n", user)
	}
}

// transaction
func transaction() {
	tx, err := db.Begin()
	if err != nil {
		if tx != nil {
			tx.Rollback()
		}
		panic(err)
	}

	sqlStr1 := "update user set age=age+1 where id=?"
	sqlStr2 := "update user set age=age-1 where id=?"

	_, err = tx.Exec(sqlStr1, 1)
	if err != nil {
		tx.Rollback()
		panic(err)
	}

	_, err = tx.Exec(sqlStr2, 2)
	if err != nil {
		tx.Rollback()
		panic(err)
	}

	err = tx.Commit()
	if err != nil {
		tx.Rollback()
		panic(err)
	}

	fmt.Println("transaction done.")
}
```



## 1.3 sqlx

替代 `database/sql`

```bash
go get github.com/jmoiron/sqlx  

var db *sqlx.DB

# 查询
db.Get() 
db.Select()  # 多行

# 增、删、改，基本和原生包一致
db.Exec()

# 事务
tx, err := db.Beginx()
tx.MustExec()
tx.Commit()
tx.Rollback()
```

优点：查询时，只需要传入对象地址，不需要考虑对象内部字段复制

示例：

```go
import (
	"fmt"

	_ "github.com/go-sql-driver/mysql"
	"github.com/jmoiron/sqlx"
)

type User struct {
	Id   int    `db:"id"`
	Name string `db:"name"`
	Age  int8   `db:"age"`
}

var db *sqlx.DB

func init() {
	dsn := "root:123456@tcp(192.168.31.60:3306)/mydb"

	var err error

	// 同时校验dsn格式和是否可以连通数据库
	db, err = sqlx.Connect("mysql", dsn)
	if err != nil {
		panic(err)
	}

	db.SetMaxOpenConns(10)
	db.SetMaxIdleConns(5)
}

func queryRow() {
	sqlStr := "select id, name, age from user where id=?"

	var user User
	err := db.Get(&user, sqlStr, 1)
	if err != nil {
		panic(err)
	}

	fmt.Printf("%v\n", user)
}

func queryManyRow() {
	sqlStr := "select id, name, age from user where id>?"

	var users []User
	err := db.Select(&users, sqlStr, 1)
	if err != nil {
		panic(err)
	}

	for _, user := range users {
		fmt.Printf("%v\n", user)
	}
}
func transaction() {
	tx, err := db.Beginx()
	if err != nil {
		if tx != nil {
			tx.Rollback()
		}
		panic(err)
	}

	sqlStr1 := "update user set age=age+1 where id=?"
	sqlStr2 := "update user set age=age-1 where id=?"

	tx.MustExec(sqlStr1, 5)
	tx.MustExec(sqlStr2, 6)

	err = tx.Commit()
	if err != nil {
		tx.Rollback()
		panic(err)
	}

	fmt.Println("transaction done.")
}
```



## 1.4 sql 注入示例

```
"xxx' or 1=1 #"
"xxx' union select * from user #"
"xxx' and (select count(*) from user) < 10 #"
```











