# 7. 数据类型



## 7.2 channel

channel: 先进先出，用于goroutine间数据通信。

channel的三种状态：

- nil: 只声明，未初始化
- active: 可正常读写
- closed: 已关闭
   - close操作原则上应由发送者完成。因为如果仍然向一个已关闭的channel发送数据，会导致程序抛出panic。而如果由接受者关闭channel，可能会遇到这个风险
   - 从一个已关闭的channel中读取数据不会报错。但是，接受者不会被一个已关闭的channel的阻塞，而且接受者从关闭的channel中仍然可以读取出数据，只不过是这个channel的数据类型的默认值。可通过**`i, ok := <-c`，则ok为false时，则代表channel已经被关闭。**

总结：**空(nil)读写阻塞，写关闭异常，读关闭空值**；无缓存的channel是同步的，有缓冲的channel是异步的



如果队列满了，直接丢弃：

```go
select {
    case ch <- 1:
    default:
}
```



**channel 数据结构**：

```go
type hchan struct {
	qcount   uint  // 元素个数
	dataqsiz uint  // 循环队列长度
	buf      unsafe.Pointer  // 缓冲区数据指针
	elemsize uint16 
	closed   uint32
	elemtype *_type
	sendx    uint  // 发送操作处理到的位置
	recvx    uint  // 接收操作处理到的位置
	recvq    waitq  // 接收队列
	sendq    waitq  // 发送队列

	lock mutex
}

type waitq struct {
	first *sudog  // runtime.sudog 循环链表
	last  *sudog
}
```

![image](https://cdn.jsdelivr.net/gh/elihe2011/bedgraph@master/golang/channel-struct.png)



## 7.5 struct

空结构体 `struct{}`用途：节约内存，`unsafe.Sizeof(struct{}{})`的值等于0

模拟Set:

```go
func main() {
	set := make(map[int]struct{})

	for _, value := range []int{3, 4, 1, 3, 5, 7, 5} {
		set[value] = struct{}{}
	}

	fmt.Println(set)
}
```



**struct 比较**：

1. 匿名结构体，字段顺序类型一致， 可进行比较
2. 匿名结构体，属性中包含引用类型，不能比较

如果结构体中有不可比较的类型，如map，slice等，那么结构体也是无法比较的。结构体比较仅支持“==”操作

复杂的比较，使用`reflect.DeepEqual(obj1, obj2)`

```go
func main() {
	// 1. 结构一致的结构体
	type A struct{ x int }
	type B struct{ x int }
	a := A{11}
	b := B{11}
    
    // 编译错误
    //fmt.Println(a == b)
    
    // 类型不一致，返回false
	fmt.Println(reflect.DeepEqual(a, b))
	

	// 2. 匿名结构体 （不含复杂类型）
    c := struct{ x int }{2}
	d := struct{ x int }{2}

	fmt.Println(a == c) // false
	fmt.Println(c == d) // true

	// 3. 匿名结构体 (含复杂类型)
	e := struct{ m map[string]int }{map[string]int{"x": 1}}
	f := struct{ m map[string]int }{map[string]int{"x": 1}}

	// 编译错误
	//fmt.Println(e == f)
	fmt.Println(reflect.DeepEqual(e, f)) // true
}
```



# 8. select

语言层面的select：**监听多个描述符的读写事件**，一旦某个描述符就绪（一般是读写事件发生），就能够将发生的事件通知给相关的的应用程序去处理该事件

golang的select：**监听多个channel**，每个case都是一个事件，这些事件可以读也可以写，随机选择一个执行；可以设置default，它的作用是当被监听的多个事件都阻塞时，执行default逻辑

goroutine 优雅退出的三种方法：

- `for-range`: 能够感知channel的关闭，自动结束

- `for-select, ok`: 注意使用ok-idiom去检测channel是否已关闭

- 使用独立的退出通道

  ```go
  func worker(done <-chan bool) {
    go func() {
      defer fmt.Println("worker done.")
      for {
        select {
          case <-done:
          	fmt.Println("Recv stop signal.")
              return
          case <-t.C:
          	fmt.Println("Working...")
        }
      }
    }()
  }
  ```

关于select机制，下面说法正确的是（ABC）
A. select机制用来处理异步IO问题
B. select机制最大的一条限制就是每个case语句里必须是一个IO操作
C. golang在语言级别支持select关键字
D. select关键字的用法与switch语句非常类似，~~后面要带判断条件~~

**select 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作**













# 11. nil

`var x = nil`  错误，nil必须先确定类型，能用nil赋值，为引用类型，nil是堆中的第一个

只有引用类型能够nil空值：(因为这些类型的零值为nil)

- ptr
- func
- interface
- map, slice, channel
- error (本质是interface)

string的空值为“”，不能赋值nil



`nil == nil` 判断注意点：

- 当 nil (硬编码的值)与对象比较时，nil 的类型和与它比较的对象声明的类型相同
- c 的类型是 interface{}，它的默认值是 nil

```go
func main() {
    var a *int                      // <*int, nil>
	var b interface{} = nil         // <nil, nil>
	var c interface{} = (*int)(nil) // <*int, nil>
	var d interface{} = a           // <*int, nil>

	fmt.Println(a == nil) // true  (<*int, nil> == <*int, nil>)
	fmt.Println(b == nil) // true  (<nil, nil> == <nil, nil>)
	fmt.Println(c == nil) // false (<*int, nil> == <nil, nil>)
	fmt.Println(d == nil) // false (<*int, nil> == <nil, nil>)

	fmt.Println(a == b) // false (<*int, nil> == <nil, nil>)
	fmt.Println(a == c) // true  (<*int, nil> == <*int, nil>)
	fmt.Println(a == d) // true  (<*int, nil> == <*int, nil>)
}
```



# 12. `常量const`

对于常量定义zero(`const zero = 0.0`)，zero是浮点型常量（F）

**Go中的常量通常是无类型的。但可以参与一些“有类型”的计算。**

**常量不能进行取地址操作 “&”**

六种未明确类型的常量类型:

- bool
- int
- byte
- float
- complex
- string





# 14. 闭包

a **closure** is a record storing **a function** together with **an environment**. **闭包**是由**函数**和与其相关的引用**环境**组合而成的实体 。

闭包是一个函数值，它引用了函数体之外的变量。 这个函数可以对这个引用的变量进行访问和赋值；换句话说这个函数被“绑定”在这个变量上。

延迟求值:

```go
func test() []func() {
	var funcs []func()

	for i := 0; i < 2; i++ {
		x := i // re-assignment
		funcs = append(funcs, func() {
			//fmt.Printf("%p, %v\n", &i, i) // xxx, 2
			fmt.Printf("%p, %v\n", &x, x) // xxx, 0; yyy, 1
		})
	}

	return funcs
}
```

引用同一变量：

```go
func test(x int) (func(), func()) {
	return func() {
			fmt.Println(x)
			x += 10
		}, func() {
			fmt.Println(x) // x+10
		}
}
func main() {
	a, b := test(100)
	a() // 100
	b() // 110
}
```



# 15. panic

- **多个panic，只能捕获最后一个**
- **在协程中，如果发生了panic，但未进行defer-func-recover操作，会连累主程序**

捕获recover 最后一个panic：

```go
func main() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(err) // defer panic
		} else {
			fmt.Println("ok")
		}
	}()

	defer func() {
		panic("defer panic")
	}()

	panic("panic")
}
```



# 16. 对象拷贝

```go
/*** slice ***/
src := []int{1, 2, 3, 4, 5}
dst := make([]int, 5)
copy(dst, src) // 深拷贝，copy & append是slice的专用函数

dst := src[:] // 浅拷贝

/*** map ***/
// 1. json转换 
jsonStr, _ := json.Marshal(src)
var dst map[string]int
json.Unmarshal(jsonStr, &dst)

// 2. for-range
func DeepCopy(o interface{}) interface{} {
	if m, ok := o.(map[string]interface{}); ok {
		newMap := make(map[string]interface{})
		for k, v := range m {
			newMap[k] = DeepCopy(v)
		}
		return newMap
	} else if s, ok := o.([]interface{}); ok {
		newSlice := make([]interface{}, len(s))
		for i, v := range s {
			newSlice[i] = DeepCopy(v)
		}
		return newSlice
	}

	return o
}
```









# 23. 对象的 `String()` 方法

在Golang中，类只要实现了String(), 在执行format时，就会自动调用这个方法

```go
type People struct {
	Name string
}

func (p People) String() string {
	return fmt.Sprintf("%v", p)        // 无限递归调用，导致栈溢出
	//return fmt.Sprintf("%v", p.Name) // OK
}

func main() {
	p := &People{"Jackson"}
	fmt.Println(p) // 自动调用 p.String()
}
```



# 24. 方法接收者

| receiver | invoker | 改变原始对象 |
| -------- | ------- | ------------ |
| (t *T)   | *T      | Yes          |
| (t *T)   | T       | Yes (new)    |
| (t T)    | *T      | No           |
| (t T)    | T       | No           |

需要注意interface{}的调用

```go
func main() {
	var a Integer = 1
	var b Integer = 2

	var i interface{} = &a
	sum := i.(*Integer).Add(b)
	diff := i.(*Integer).Sub(b)
	fmt.Println(sum, diff)

	var j interface{} = a
	sum = j.(Integer).Add(b) // cannot take the address of j.(Integer), 因为j.(Integer)的类型为main.Integer, 无法自动转换成*Integer
	diff = j.(Integer).Sub(b)
	fmt.Println(sum, diff)

}

func (a *Integer) Add(b Integer) Integer {
	return *a + b
}

func (a Integer) Sub(b Integer) Integer {
	return a - b
}
```





# 26. 内存泄漏

关于内存泄露，下面说法正确的是（BD）
A. golang有自动垃圾回收，不存在内存泄露
B. golang中检测内存泄露主要依靠的是pprof包
C. 内存泄露可以在编译阶段发现
D. 应定期使用浏览器来查看系统的实时内存信息，及时发现内存泄露问题



检测是否 goroutine 泄露 

使用runtime.Stack()在测试代码前后计算goroutine的数量，代码运行完毕会触发gc，如果触发gc后，发现还有goroutine未被回收，那么这个goroutine很可能是被泄漏的

打印堆栈：

> - 当前堆栈
>
>   ```go
>   log.Info("stack %s", debug.Stack())
>   ```
>
> - 全局堆栈
>
>   ```go
>   buf := make([]byte, 1<<16)
>   runtime.Stack(buf, true)
>   log.Info("stack %s", buf)
>   ```

goroutine 泄漏：一个程序**不断地产生新的goroutine，且又不结束它们，会造成泄漏**

```go
func main() {
	for i := 0; i < 10000; i++ {
		go func() {
			select {}
		}()
	}
}
```



# 27. 位操作

```go
//const s = "Go101.org" // 4 0
//var s = "Go101.org" // 0 0
var s = [9]byte{'G', 'o', '1', '0', '1', '.', 'o', 'r', 'g'} // 4 0

var a byte = 1 << len(s) / 128
var b byte = 1 << len(s[:]) / 128

func main() {
	fmt.Println(a, b)
}
```

len函数：

> For some arguments, such as a string literal or a simple array expression, the result can be constant.
>
> ```go
> const s = "Go101.org"
> len(s)    // const
> len(s[:]) // var
> 
> var s = "Go101.org"
> len(s)    // var
> len(s[:]) // var
> 
> var s = [9]byte{'G', 'o', '1', '0', '1', '.', 'o', 'r', 'g'}
> len(s)    // const
> len(s[:]) // var
> ```
>
> 

位移操作：

> The right operand in a shift expression must have integer type or be an untyped constant representable by a value of type uint.
>
> If the left operand of a non-constant shift expression is an untyped const, it is first implicity converted to the type it would assume if the shift expression were replaced by it's left operand alone.
>
> `var a byte = 1 << len(s) / 128`: `1 << len(s)`是常量表达式，它的结果为512，除以128，结果4
>
> `var b byte = 1 << len(s[:]) / 128` : `1 << len(s[:])`不是常量表达式，操作数1为无类型常量，会先将其转化为byte，然后再进行位移操作。byte类型的1，移位操作后，越界变成0，除以128，结果0 



# 28. Data Race问题怎么解决？

检测方法：`go run -race` 或 `go build -race`

解决办法：

- 互斥锁 sync.Mutex
- 使用channel，效率更高



# 29. 互斥锁、读写锁、死锁

- 互斥锁 (sync.Mutex) : 最简单的一种锁，读写均需要Lock/Unlock
- 读写锁 (sync.RWMutex) : 写独占、读共享、写锁优先级高

- 死锁

死锁产生原因：

1. 一个线程两次申请加锁
2. 两个线程相互申请对方的锁，但双方都不释放锁

产生死锁的四个必要条件：

1. 互斥：一个资源每次只能被一个线程使用
2. 请求与保持：一个线程因请求资源而阻塞，但对已获得资源保存不放
3. 不剥夺：线程获取的资源，在未使用完成前，不能强行剥夺
4. 循环等待：若干线程之间形成一种头尾相接的循环等待资源关系

处理死锁的四种方法：

1. 死锁预防：通过确保死锁的一个必要条件不满足，保证不会发生死锁
2. 死锁检测：允许发生死锁，但可通过系统设置的检查结构检测死锁的发生，采取措施将死锁清除掉
3. 死锁避免：在资源分配过程中，使用某些方法避免系统进入不安全状态，从而避免发生死锁
4. 死锁解除：当检测到系统中发生死锁，将进程从死锁中解脱出来

避免死锁的算法：

1. 进程启动拒绝：如果一个进程的请求会导致死锁，则不启动该进程
2. 资源分配拒绝：如果一个进程增加的资源请求会导致死锁，则不允许分配资源

解除死锁的方法：

1. 资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程
2. 撤销进程法：强制撤销部分、甚至全部死锁进程的资源。



# 30. Go 语言并发机制 

CSP并发模型：不同于传统的多线程通过共享内存来通信，CSP讲究的是“以通信的方式来共享内存”。用于描述两个独立的并发实体通过共享的通信channel进行通信的并发模型。CSP中，channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。

channel被单独创建并且可以在进程之间传递，一个实体通过将消息发到channel中，然后又监听这个channel的实体处理，两个实体之间是匿名的，它实现了实体中间的解藕。

Goroutine是Golang并发的实体，它底层使用协程(coroutine)实现并发，coroutine是一种运行在用户态的用户线程，类似greenthread，coroutine具有如下特点：

- 用户空间，避免了内核态和用户态的切换导致的成本
- 可以由语言和框架层进行调度
- 更小的栈空间允许创建大量的实例



# 31. Goroutine

系统线程：会有一个大小固定的栈(2MB)，它用来保存函数递归调用时的参数和局部变量

Goroutine：以一个很小的栈启动(2K/4K)，当遇到深度递归调用导致栈空间不足时，会自动扩展栈（最大1G）

Go调度器：可以在n个系统线程上调度m个goroutine。调度器只关注单独的Go程序中的goroutine，goroutine采用的是半抢占式的协作调度，只有在当前Goroutine发生阻塞时才发生调度；同时发生在用户态，切换代价比系统线程低的多。`runtime.GOMAXPROC`变量，用于控制当前运行正常的非阻塞goroutine的系统线程数量



# 4. 获取变量占用的字节数

`unsafe.Sizeof(obj)`

```go
func main() {
	var n = 100
	fmt.Println(unsafe.Sizeof(n))
}
```


# 6. 随机数

```go
func main() {
	rand.Seed(time.Now().UnixNano())  // 种子变化越大，随机性越好
	n := rand.Intn(100) + 1
	fmt.Println(n)
}
```

# 7. 时间和日期函数

```go
func main() {
	now := time.Now()  // time.Time

	year := now.Year()
	month := int(now.Month())
	day := now.Day()
	fmt.Printf("%04d-%02d-%02d\n", year, month, day)

	weekday := now.Weekday()
	fmt.Println(weekday)

	ts := now.Unix() // timestamp
	nano := now.UnixNano()
	fmt.Println(ts, nano)

	dateStr := now.Format("2006-01-02 15:04:05")
	fmt.Println(dateStr)
}

time.Sleep(100 * time.MilliSecond)
```


# 8. 内置函数

```go
len   // string, array, slice, map, channel
close // channel

new   // 分配内存, 值类型 int, float, struct等，返回指针
make  // 分配内存, 引用类型 chan, map, slice等，返回类型本身，而非指针

nptr = new(int) // *int

append  // 追加元素到array, slice中
panic/recover // 错误处理
```

# 9. new和make的区别

- `new(T)` 返回 T 的指针 `*T` 并指向 T 的零值。
- `make(T)` 返回的初始化的 T，只能用于 slice，map，channel。







