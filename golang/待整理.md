

# 26. 内存泄漏

关于内存泄露，下面说法正确的是（BD）
A. golang有自动垃圾回收，不存在内存泄露
B. golang中检测内存泄露主要依靠的是pprof包
C. 内存泄露可以在编译阶段发现
D. 应定期使用浏览器来查看系统的实时内存信息，及时发现内存泄露问题



检测是否 goroutine 泄露 

使用runtime.Stack()在测试代码前后计算goroutine的数量，代码运行完毕会触发gc，如果触发gc后，发现还有goroutine未被回收，那么这个goroutine很可能是被泄漏的

打印堆栈：

> - 当前堆栈
>
>   ```go
>   log.Info("stack %s", debug.Stack())
>   ```
>
> - 全局堆栈
>
>   ```go
>   buf := make([]byte, 1<<16)
>   runtime.Stack(buf, true)
>   log.Info("stack %s", buf)
>   ```

goroutine 泄漏：一个程序**不断地产生新的goroutine，且又不结束它们，会造成泄漏**

```go
func main() {
	for i := 0; i < 10000; i++ {
		go func() {
			select {}
		}()
	}
}
```





```go

```


# 6. 随机数

```go
func main() {
	rand.Seed(time.Now().UnixNano())  // 种子变化越大，随机性越好
	n := rand.Intn(100) + 1
	fmt.Println(n)
}
```

# 7. 时间和日期函数

```go
func main() {
	now := time.Now()  // time.Time

	year := now.Year()
	month := int(now.Month())
	day := now.Day()
	fmt.Printf("%04d-%02d-%02d\n", year, month, day)

	weekday := now.Weekday()
	fmt.Println(weekday)

	ts := now.Unix() // timestamp
	nano := now.UnixNano()
	fmt.Println(ts, nano)

	dateStr := now.Format("2006-01-02 15:04:05")
	fmt.Println(dateStr)
}

time.Sleep(100 * time.MilliSecond)
```





cmd的Start和Run方法的区别：

Start执行不会等待命令完成，Run会阻塞等待命令完成。

```
cmd := exec.Command("sleep", "10")
err := cmd.Run()  //执行到此处时会阻塞等待10秒
err := cmd.Start()   //如果用start则直接向后运行
if err != nil {
    log.Fatal(err)
}
err = cmd.Wait()   //执行Start会在此处等待10秒
```


