# 1. 文件读写

```go
// 一次性文件读写
ioutil.ReadFile
ioutil.WriteFile

// 读文件
os.Open

// 写文件
os.Create
os.OpenFile

// 拷贝文件
io.Copy
io.CopyBuffer

// 带缓冲
bufio.NewReader
bufio.NewWriter

// 目录遍历
filepath.Walk
```



# 2. 网络编程

```go
// 服务端
net.Listen()
listener.Accept()

// 客户端
net.Dail

// 连接
conn.Read()
conn.Write()
conn.Close()
```



# 3. rpc

```go
// 服务端
rpc.Register()
rpc.RegisterName()

rpc.HandleHTTP()
             
             
// 客户端
rpc.DialHTTP()
client.Call()

// telnet 模拟调用格式
{"method": "JsonRpc.Add", "params": [{"X":5,"Y":3}], "id": 1}
```



# 4. sync

## 4.1 `sync.Once`

**只运行一次**

```
func main() {
   var once sync.Once
   done := make(chan bool)

   for i := 0; i < 5; i++ {
      go func() {
         once.Do(func() {
            fmt.Println(i)
         })

         time.Sleep(time.Second)
         done <- true
      }()
   }

   for i := 0; i < 5; i++ {
      <-done
   }
}
```



## 4.2 `sync.Mutex`

互斥锁

```go
func (m *Mutex) Lock()
func (m *Mutex) Unlock()
```



## 4.3 `sync.RWMutex`

读写锁：写互斥，读共享

```go
func (rw *RWMutex) Lock()
func (rw *RWMutex) RLock()
func (rw *RWMutex) RLocker() Locker
func (rw *RWMutex) RUnlock()
func (rw *RWMutex) Unlock()
```



## 4.4 `sync.WaitGroup`

用于等待一组 goroutine 结束：

```go
func (wg *WaitGroup) Add(delta int)
func (wg *WaitGroup) Done()
func (wg *WaitGroup) Wait()
```



## 4.5 `sync.Cond`

```go
func NewCond(l Locker) *Cond
func (c *Cond) Broadcast()
func (c *Cond) Signal()
func (c *Cond) Wait()
```

![hashmap](https://cdn.jsdelivr.net/gh/elihe2011/bedgraph@master/golang/sync-cond.png)

```go
func main() {
	cond := sync.NewCond(new(sync.Mutex))
	num := 0

	// Consumer
	go func() {
		for {
			cond.L.Lock()
			for num == 0 {
				cond.Wait()
			}

			num--
			fmt.Printf("Consumer: %d\n", num)
			cond.Signal()
			cond.L.Unlock()
		}
	}()

	// Producer
	for {
		time.Sleep(time.Second)
		cond.L.Lock()
		for num == 3 {
			cond.Wait()
		}

		num++
		fmt.Printf("Producer: %d\n", num)
		cond.Signal()
		cond.L.Unlock()
	}
}
```



## 4.6 `sync.Pool` 

**临时对象池**

```go
 func (p *Pool) Get() interface{}
 func (p *Pool) Put(x interface{})
```

保存和复用临时对象，以减少内存分配，降低GC压力

> 获取对象过程：
>
> 1. 固定到某个P，尝试从私有对象获取，如果私有对象非空则返回该对象，并将私有对象清掉
> 2. 如果私有对象为空，就去当前子池的共享列表中获取(需要加锁)
> 3. 如果当前子池列表也为空，就尝试去其他P的子池的共享列表偷一个(需要加锁)
> 4. 如果其他子池都是空的，直接返回用户指定的New 函数对象

```go
// GC 回收
func main() {
	p := &sync.Pool{
		New: func() interface{} {
			return 0
		},
	}

	a := p.Get().(int)
	p.Put(1)
	runtime.GC() // 缓存对象可能被删除

	b := p.Get().(int)
	fmt.Println(a, b)
}
```

```go
func main() {
	bufferPool := &sync.Pool{
		New: func() interface{} {
			return new(bytes.Buffer)
		},
	}

	// 获取缓冲区，存储字节序列
	buf := bufferPool.Get().(*bytes.Buffer)

	var a uint32 = 121
	var b uint32 = 3434

	// 将数据转为字节序列
	err := binary.Write(buf, binary.LittleEndian, a)
	if err != nil {
		panic(err)
	}

	err = binary.Write(buf, binary.LittleEndian, b)
	if err != nil {
		panic(err)
	}

	// 拼接后的结果
	fmt.Printf("% x\n", buf.Bytes())

	// 缓冲使用完毕，必须重置并放回Pool中
	buf.Reset()
	bufferPool.Put(buf)
}
```



## 4.7 `sync.Map`

**线程安全map**

```go
func (m *Map) Delete(key interface{})
func (m *Map) Load(key interface{}) (value interface{}, ok bool)
func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool)
func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)
func (m *Map) Range(f func(key, value interface{}) bool)
func (m *Map) Store(key, value interface{})
```




# 5. http

```go
// 客户端
http.Get()
http.Client{}
http.NewRequest()
httputil.DumpResponse()

// 服务端
http.ListenAndServe()
http.HandleFunc(endpoint, handler)
func Handler(w http.ResponseWriter, r *http.Request) {} // 请求处理函数
func HTTPInterceptor(h http.HandlerFunc) http.HandlerFunc {} // 中间件

mux := http.NewServeMux()  // http 请求路由，多路复用器Multiplexor，它把收到的请求与一组预先定义的URL路由路径做对比，然后匹配合适的路径关联到处理器Handler

// http包自带的常用处理器
http.FileServer()
http.NoFoundHandler()
http.RedirectHandler()

// 处理函数
ServeHTTP(http.ResponseWriter, *http.Request)

// 默认请求路由
func main1() {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		log.Println(r.Header.Get("User-Agent"))
		w.Write([]byte("Hello World!"))
	})

	http.ListenAndServe(":8080", nil)
}

// 自定义请求路由
func main() {
	mux := http.NewServeMux()

	mux.Handle("/", http.RedirectHandler("http://baidu.com", 307))
	http.ListenAndServe(":8080", mux)
}
```



# 6. `context`

管理一组呈现树状结构的Goroutine，让每个Goroutine都拥有相同的上下文，并且可以在这个上下文中传递数据

```go
type Context interface {
  Done() <-chan struct{}
  Err() error
  Deadline() (deadline time.Time, ok bool)
  Value(key interface{}) interface{}
}

// 返回一个空的context，通常作为树的根节点，不能被取消，没有值，也没有过期时间
func Background() Context

// 取消函数
func CancelFunc func()
func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
func WithDeadline(parent Context, t time.Time) (Context, CancelFunc)
```

**示例1：**

```go
func monitor(ctx context.Context, num int) {
	for {
		select {
		case <-ctx.Done():
			fmt.Printf("Monitor[%d] stopped.\n", num)
			return
		default:
			val := ctx.Value("name")
			fmt.Printf("Monitor[%d] is running, value is %v\n", num, val)
			time.Sleep(2 * time.Second)
		}
	}
}

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	ctx, cancel = context.WithTimeout(ctx, time.Second)
	ctx = context.WithValue(ctx, "name", "jack")
	defer cancel()

	for i := 0; i < 5; i++ {
		go monitor(ctx, i)
	}

	time.Sleep(5 * time.Second)

	if err := ctx.Err(); err != nil {
		fmt.Printf("Reason: %v\n", err)
	}

	fmt.Println("Done.")
}
```

注意：context上下文数据不是全局的，它只查询本节点及父节点的数据，不能查询兄弟节点数据

Context使用原则：

- 不要把Context放在结构体中，要以参数形式传递
- 做函数参数时，应该作为第一个参数
- 给一个函数传递Context时，不要传递nil，如果不知道传递什么，就使用context.TODO
- Context的Value相关方法应该传递必须的数据，不要什么数据都传递
- Context是线程安全的，可以放心的在多个goroutine中传递



# 7. 标准输入

## 7.1 `fmt`

`Scanf`: 空格作为分隔符，占位符与输入格式一样

`Scanln`: 空格作为分隔符, 换行符结束

`Scan`: 空格或换行符作为分隔符

`Sscanf`: 从字符串输入，空格做分隔符

`Fscanf`: 从文件输入

```go
var a int
var b string

// 不支持换行
fmt.Scanf("%d", &a)
fmt.Scanf("%s", &b)

// 同上
fmt.Scanln(&a, &b)

// 支持换行
fmt.Scanf("%d\n", &a)
fmt.Scanf("%s\n", &b)

// 同上
fmt.Scan(&a, &b)

s := "10 abc"
fmt.Sscanf(s, "%d %s", &a, &b)

s = "5\n\nxyz"
fmt.Sscan(s, &a, &b)

fmt.Fscanf(os.Stdin, "%d %s", &a, &b)
```

## 7.2 `os`

`File.Read(b []byte)`

`File.Write(b []byte)`

`File.WriteString(s string)`

```go
func main() {
	var buf [8]byte

	os.Stdin.Read(buf[:])

	//fmt.Printf("%s\n", buf)
    os.Stdout.Write(buf[:])
}
```

## 7.3 `bufio`

读取一整行

```go
func main() {
	reader := bufio.NewReader(os.Stdin)
	s, _ := reader.ReadString('\n')
	fmt.Println(s)
}
```



# 8. 命令行参数

## 8.1 `os.Args`

```go
func main() {
	for i, v := range os.Args {
		fmt.Printf("Args[%d]=%v\n", i, v)
	}
}
```

## 8.2 `flag`

```go
func main() {
	var local bool
	var schema string
	var port int

	flag.BoolVar(&local, "l", false, "whether local protocol")
	flag.StringVar(&schema, "s", "http", "schema")
	flag.IntVar(&port, "p", 80, "port")
	flag.Parse()

	fmt.Println(local, schema, port)
}
```



# 9. json

golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（BCD）
A. 指针  **//可进行隐式转换，对指针取值，对所指对象进行序列化**
B. channel
C. complex
D. 函数

struct的序列化要注意：结构体在序列化时私有变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值



json 序列化tag使用：

- 定制key名            `json:"id"`
- 指定数据类型        `json:"id, string"`    (string, number, bool)
- 忽略空值                `json:"addr, omitempty"`
- 忽略字段                `json:"-"`

自定义json序列化

```go
type Date time.Time

func (d *Date) MarshalJSON() ([]byte, error) {
    t := time.Time(*d)
    str := now.Format("2006-01-02")
    return []byte(str), nil
}

func (d *Date) UnmarshalJSON(data []byte) error {
    t, err := time.Parse("2006-01-02", string(data))
    if err != nil {
        return err
    }
    
    *d = Date(t)
    return nil
}
```



