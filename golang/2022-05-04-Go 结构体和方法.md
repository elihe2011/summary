---
layout: post
title:  Go 结构体和接口
date:   2018-01-05 09:28:32
comments: true
photos: 
tags: 
  - go
categories: Golang
---


# 1. 结构体

将多个不同类型命名字段(field)序列打包成一个复合类型。

结构体特点：

- 值类型
- 做参数，值传递
- 相同类型，可使用==或!=比较

Go语言中实现封装、继承和多态：

- 封装：通过方法实现
- 继承：通过匿名字段实现
- 多态：通过接口实现

<!-- more -->

## 1.1 定义结构体

```go
type person struct {
	Name string
	Age  int
}

func main() {
	p := person{
		Name: "lucy",
		Age: 22,
	}
	fmt.Println(p)
}
```

## 1.2 匿名结构体

```go
type person struct {
	Name string
	Age  int
	Contact struct {
		Phone, City string
	}
}

func main() {
	p1 := person{
		Name: "lucy",
		Age: 22,
		Contact: struct{ Phone, City string } {
			Phone: "123456789",
			City: "LA",
		},
	}
	fmt.Println(p1)

	p2 := person{
		Name: "jack",
		Age:  19,
	}
	p2.Contact.Phone = "987654321"
	p2.Contact.City = "NY"

	fmt.Println(p2)
}
```

## 1.3 匿名字段

```go
func main() {
	s := struct {
		int
		string
	} {
		10,
		"jack",
	}

	fmt.Println(s)
}
```

## 1.4 嵌入结构（模拟继承）

```go
type person struct {
	Name string
	Age int
}

type teacher struct {
	person
	Salary float32
}

type student struct {
	person
	Score float32
}

func main() {
	t := teacher {
		person: person{
			Name: "Jack",
			Age: 45,
		},
		Salary: 12901.20,
	}
	t.Age += 1

	s := student{
		person: person{
			Name: "Tom",
			Age:  13,
		},
		Score: 91.50,
	}
	s.Score -= 2.5

	fmt.Println(t, s)
}
```

## 1.5 结构体序列化

注意使用struct标签，否则序列化后的名称会保持大写开头不变

```go
type Student struct {
	Name string `json:"name"`
	Age  byte   `json:"age"`
}

func main() {
	stu := Student{"Jack", 21}

	js, err := json.Marshal(stu)
	if err != nil {
		fmt.Println("json化失败", err)
		return
	}

	fmt.Println(string(js))
}
```

## 1.6 工厂模式

```go
type student struct {
	Name string
	Age  byte
}

func NewStudent(name string, age byte) *student {
	return &student{
		Name: name,
		Age:  age,
	}
}

func (stu *student) String() string {
	return fmt.Sprintf("Name=%v, Age=%v", stu.Name, stu.Age)
}
```

## 1.7 结构体链表

```go
type Node struct {
	Name  string
	Value int
	next  *Node
}

func main() {
	node := &Node{
		Name:  "head",
		Value: 0,
	}

	appendNodes(node)
	//trans(node)

	// 只所以要有二级指针，是为了改变顶级node的地址，方便遍历函数遍历
	insertNodes(&node)
	//trans(node)

	delNode(&node, "head")
	//trans(node)

	addNode(&node, "node_A_1", &Node{Name: "newNode", Value: 12})
	trans(node)
}

func appendNodes(p *Node) {
	for i := 0; i < 2; i++ {
		node := Node{
			Name:  fmt.Sprintf("node_A_%d", i),
			Value: rand.Intn(100),
		}

		p.next = &node
		p = &node
	}
}

func insertNodes(p **Node) {
	for i := 0; i < 2; i++ {
		node := Node{
			Name:  fmt.Sprintf("node_I_%d", i),
			Value: rand.Intn(100),
		}

		node.next = *p
		*p = &node
	}
}

func delNode(p **Node, name string) {
	head := *p

	// 第一个即为要删除的对象
	if head.Name == name {
		*p = head.next
		return
	}

	prev := head
	head = head.next

	for head != nil {
		if head.Name == name {
			prev.next = head.next
			break
		}

		prev = head
		head = head.next
	}
}

func addNode(p **Node, name string, newNode *Node) {
	head := *p

	// 第一个元素前插入
	if head.Name == name {
		newNode.next = head
		*p = newNode
		return
	}

	prev := head
	head = head.next
	for head != nil {
		if head.Name == name {
			prev.next = newNode
			newNode.next = head
			break
		}

		prev = head
		head = head.next
	}
}

func trans(p *Node) {
	for p != nil {
		fmt.Println(*p)
		p = p.next
	}
}func main() {
	node := &Node{
		Name:  "head",
		Value: 0,
	}

	appendNodes(node)
	insertNodes(&node)
	delNode(&node, "node_I_4")
	appendNode(node, "head", "newAppend")
	insertNode(&node, "node_A_4", "newInsert")

	trans(node)
}

type Node struct {
	Name  string
	Value int
	next  *Node
}

func trans(p *Node) {
	for p != nil {
		fmt.Println(*p)
		p = p.next
	}
}

func appendNodes(p *Node) {
	for i := 0; i < 5; i++ {
		node := &Node{
			Name:  fmt.Sprintf("node_A_%d", i),
			Value: rand.Intn(100),
		}
		p.next = node
		p = node
	}
}

// 除了要在head前增加元素，还需要去改变链表head的位置，需要用到多重指针
func insertNodes(p **Node) {
	for i := 0; i < 5; i++ {
		node := &Node{
			Name:  fmt.Sprintf("node_I_%d", i),
			Value: rand.Intn(100),
		}
		node.next = *p
		*p = node
	}
}

func delNode(p **Node, name string) {
	node := *p

	// 第一个就是要删除的元素
	if node.Name == name {
		*p = node.next
		return
	}

	prev := node
	node = node.next

	for node != nil {
		if node.Name == name {
			prev.next = node.next
			break
		}

		prev = node
		node = node.next
	}
}

func appendNode(p *Node, name, newName string) {
	for p != nil {
		if p.Name == name {
			newNode := &Node{
				Name:  newName,
				Value: rand.Intn(100),
				next:  p.next,
			}
			p.next = newNode
			break
		}

		p = p.next
	}

}

func insertNode(p **Node, name, newName string) {
	node := *p

	// 在第一个元素前增加
	if node.Name == name {
		newNode := &Node{
			Name:  newName,
			Value: rand.Intn(100),
			next:  node,
		}

		// 改变链表头
		*p = newNode
		return
	}

	prev := node
	node = node.next

	for node != nil {
		if node.Name == name {
			newNode := &Node{
				Name:  newName,
				Value: rand.Intn(100),
				next:  node,
			}

			// 与前一个链接起来
			prev.next = newNode
			break
		}

		prev = node
		node = node.next
	}
}
```

## 1.8 结构体内存结构

不管结构体包含多少字段，其内存总是一次性分配的，各字段在相邻的地址空间按定义顺序排列。当然，对于引用类型、字符串和指针，结构内存中只包含其基本（头部）数据。还有，所有匿名字段成员也被包含在内。

```go
type point struct {
	x, y int
}

type node struct {
	id   int
	name string
	data []byte
	next *node
	point
}

func main() {
	v := node{
		id:    1,
		name:  "yes",
		data:  []byte{1, 2, 3, 4},
		point: point{x: 100, y: 200},
	}

	format := `
v: %p ~ %x, size %d, align: %d

field address                offset   size
-------+--------------------+--------+-----
id      %p          %d        %d
name    %p          %d        %d
data    %p          %d        %d
next    %p          %d        %d
x       %p          %d        %d
y       %p          %d        %d
`

	fmt.Printf(format,
		&v, uintptr(unsafe.Pointer(&v))+unsafe.Sizeof(v), unsafe.Sizeof(v), unsafe.Alignof(v),
		&v.id, unsafe.Offsetof(v.id), unsafe.Sizeof(v.id),
		&v.name, unsafe.Offsetof(v.name), unsafe.Sizeof(v.name),
		&v.data, unsafe.Offsetof(v.data), unsafe.Sizeof(v.data),
		&v.next, unsafe.Offsetof(v.next), unsafe.Sizeof(v.next),
		&v.x, unsafe.Offsetof(v.x), unsafe.Sizeof(v.x),
		&v.y, unsafe.Offsetof(v.y), unsafe.Sizeof(v.y))
}

/*
v: 0xc000084000 ~ c000084048, size 72, align: 8

field address                offset   size
-------+--------------------+--------+-----
id      0xc000084000          0        8
name    0xc000084008          8        16
data    0xc000084018          24        24
next    0xc000084030          48        8
x       0xc000084038          56        8
y       0xc000084040          64        8
*/
```

`unsafe.Sizeof(x)`特点总结：

- **字符串：始终返回16**。字符串类型对应一个结构体，该结构体有两个域，第一个域是指向该字符串的指针，第二个域是字符串的长度，每个域占8个字节，但是并不包含指针指向的字符串的内容。
- **切片: 始终返回24**。if x is a slice, Sizeof returns the size of the slice descriptor, not the size of the memory referenced by the slice.
- **数组: Sizeof(x[0]) \* len(x)**

## 1.9 结构体字段对齐

**在分配内存时，字段须做对齐处理，通常以所有字段中最长的基础类型宽度为标准**

`unsafe.Alignof(x)`: 获取对齐宽度，以最长的基础类型宽度作为对齐标准。

```go
func main() {
	v1 := struct {
		a byte
		b byte
		c int32   // 对齐宽度4
	}{}

	v2 := struct {
		a byte
		b byte    // 对齐宽度1
	}{}

	v3 := struct {
		a byte
		b []int   // 基础类型int，对齐宽度8
		c int32
	}{}

	fmt.Printf("v1: %d, %d\n", unsafe.Alignof(v1), unsafe.Sizeof(v1))  // 4, 8
	fmt.Printf("v2: %d, %d\n", unsafe.Alignof(v2), unsafe.Sizeof(v2))  // 1, 2
	fmt.Printf("v3: %d, %d\n", unsafe.Alignof(v3), unsafe.Sizeof(v3))  // 8, 40
}
```

## 1.10 类型对齐长度

| 类型      | 对齐长度 |
| --------- | -------- |
| bool      | 1        |
| int8/byte | 1        |
| int32     | 4        |
| int64     | 8        |
| string    | 8        |
| map       | 8        |
| slice     | 8        |


# 2. 方法

方法是与对象实例绑定的特殊函数

## 2.1 绑定方法

```go
type A struct {
	Name string
}

// （a A) receiver
func (a A) Print() {
	fmt.Println(a.Name)
}

func main() {
	a := A{
		Name: "tom",
	}
	a.Print()
}
```

## 2.2 为int扩展方法

```go
type TZ int

func (a *TZ) Print() {
	fmt.Println("TZ")
}

func main() {
	var a TZ

	a.Print()         // method value

	(*TZ).Print(&a)   // method expression
}
```

## 2.3 结构体重写String()方法

重新String()方法：(fmt.Println()会自动调用String()方法)

```go
type Student struct {
	Name string `json:"name"`
	Age  byte   `json:"age"`
}

func main() {
	stu := Student{"Jack", 21}

	fmt.Println(&stu) // 自动调用String()方法
}

func (stu *Student) String() string {
	return fmt.Sprintf("Name=%v, Age=%v", stu.Name, stu.Age)
}
```

## 2.4 方法集

类型有一个与之相关的方法集（method set），这决定了它是否实现某个接口。

- 类型T方法集包含所有receiver T方法。
- 类型*T方法集包含所有receiver T+*T方法。
- 匿名嵌入S，T方法集包含所有receiver S方法。
- 匿名嵌入*S，T方法集包含所有receiver S+*S方法。
- 匿名嵌入S或*S，*T方法集包含所有receiver S+*S方法。

```go
type S struct{}

type T struct {
	S
}

func (S) Hello() {}
func (S) sVal()  {}
func (*S) sPtr() {}
func (T) tVal()  {}
func (*T) tPtr() {}

func methodSet(a interface{}) {
	t := reflect.TypeOf(a)
	fmt.Println(t.NumMethod()) // methods need to export, 只有Hello一个方法可导出

	for i, n := 0, t.NumMethod(); i < n; i++ {
		m := t.Method(i)
		fmt.Println(m.Name, m.Type)
	}
}

func main() {
	var t = T{}

	methodSet(t)
	println("------------")
	methodSet(&t)
}
```

