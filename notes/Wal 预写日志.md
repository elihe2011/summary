# 1. 简介

WAL (Write Ahead Log) 预写日志，是数据库系统中常见的一种手段，用于保证数据操作的原子性和持久性。

WAL 是关系数据库系统中用于提供原子性和持久性（ACID 属性中的两个）的一系列技术。在使用 WAL 的系统中，所有的修改在提交之前都要先写入 log 文件中。

WAL 允许用 in-place 方式更新数据库。另一种用来实现原子更新的方法是 shadow paging，它并不是 in-place 方式。用 in-place 方式做更新的主要优点是减少索引和块列表的修改。ARIES 是 WAL 系列技术常用的算法。在文件系统中，WAL 通常称为 journaling。



**WAL 的机制原理**：

- 修改并不直接写入到数据库文件中，而是写入到另外一个称为 WAL 的文件中；
- 如果事务失败，WAL 中的记录会被忽略，撤销修改；
- 如果事务成功，它将在随后的某个时间被写回到数据库文件中，提交修改。



**WAL 的优点**：

- 读和写可以完全地并发执行，不会互相阻塞（但是写之间仍然不能并发）。

- WAL 在大多数情况下，拥有更好的性能（因为无需每次写入时都要写两个文件）。

- 磁盘 I/O 行为更容易被预测。

- 使用更少的 fsync()操作，减少系统脆弱的问题。



**提升性能**：

数据库的最大性能挑战就是磁盘的读写，主要方案有三种：

- **随机读写改顺序读写**
- **缓冲单条读写改批量读写**
- **单线程读写改并发读写**

WAL 其实是这种思路的一种实现：

- WAL 中记录事务的更新内容，通过 WAL 将随机的脏页写入变成顺序的日志刷盘；
- WAL 通过 buffer 的方式改单条磁盘刷入为缓冲批量刷盘；
- WAL 数据到最终数据的同步过程中可以采用并发同步的方式。



**checkpoint** (检查点)：

使用 WAL 的数据库系统不会再每新增一条 WAL 日志就将其刷入数据库文件中，一般积累一定的量然后批量写入，通常使用**「页」**为单位，这是磁盘的写入单位。 **同步 WAL 文件和数据库文件的行为被称为 checkpoint**，一般在 WAL 文件积累到一定页数修改的时候；当然，有些系统也可以手动执行 checkpoint。执行 checkpoint 之后，WAL 文件可以被清空，这样可以保证 WAL 文件不会因为太大而性能下降。

有些数据库系统读取请求也可以使用 WAL，通过读取 WAL 最新日志就可以获取到数据的最新状态。



# 2. SQLite

​	在引入WAL机制之前，SQLite使用rollback journal机制实现原子事务。它的原理是：**在修改数据库文件中的数据之前，先将修改所在分页中的数据备份在另外一个地方，然后才将修改写入到数据库文件中；如果事务失败，则将备份数据拷贝回来，撤销修改；如果事务成功，则删除备份数据，提交修改**。

 	WAL机制原理：**修改并不直接写入到数据库文件中，而是写入到另外一个称为WAL的文件中；如果事务失败，WAL中的记录会被忽略，撤销修改；如果事务成功，它将在随后的某个时间被写回到数据库文件中，提交修改**。

​	同步WAL文件和数据库文件的行为被称为checkpoint（检查点），它由SQLite自动执行，默认是在WAL文件积累到1000页修改的时候；当然，在适当的时候，也可以手动执行checkpoint，SQLite提供了相关的接口。执行checkpoint之后，WAL文件会被清空。

​	在读的时候，SQLite将在WAL文件中搜索，找到最后一个写入点，记住它，并忽略在此之后的写入点（这保证了读写和读读可以并行执行）；随后，它确定所要读的数据所在页是否在WAL文件中，如果在，则读WAL文件中的数据，如果不在，则直接读数据库文件中的数据。

​	在写的时候，SQLite将之写入到WAL文件中即可，但是必须保证独占写入，因此写写之间不能并行执行。

​    WAL在实现的过程中，使用了共享内存技术，因此，所有的读写进程必须在同一个机器上，否则，无法保证数据一致性。



优点：

- 读和写可以完全地并发执行，不会互相阻塞（但是写之间仍然不能并发）
- WAL在大多数情况下，拥有更好的性能（因为无需每次写入时都要写两个文件）
- 磁盘I/O行为更容易被预测。

缺点：

- 访问数据库的所有程序必须在同一主机上，且支持共享内存技术。
- 每个数据库现在对应3个文件：<yourdb>.db，<yourdb>-wal，<yourdb>-shm。
- 当写入数据达到GB级的时候，数据库性能将下降。
- 4.3.7.0之前的SQLite无法识别启用了WAL机制的数据库文件。



**兼容性问题**：在启用了WAL之后，数据库文件格式的版本号由1升级到了2，因此，3.7.0之前的SQLite无法识别启用了WAL机制的数据库文件。

禁用WAL会使数据库文件格式的版本号恢复到1，从而可以被SQLite 3.7.0之前的版本识别。



**性能问题**：在一般情况下，WAL会提高SQLite的事务性能；但是在某些极端情况下，却会导致SQLite事务性能的下降。

- 在事务执行时间较长或者要修改的数据量达到GB级的时候，WAL文件会被占用，它会暂时阻止checkpoint的执行（checkpoint会清空WAL文件），这将导致WAL文件变得很大，增加寻址时间，最终导致读写性能的下降。
- 当checkpoint执行的时候，会降低当时的读写性能，因此，WAL可能会导致周期性的性能下降。



# 3. MySQL

mysql 通过 redo、undo 日志实现 WAL。

- redo log 重做日志：每当有操作时，在数据变更之前将操作写入 redo log，这样当发生掉电之类的情况时系统可以在重启后继续操作。

- undo log 撤销日志：当一些变更执行到一半无法完成时，可以根据撤销日志恢复到变更之间的状态。

mysql 中用 redo log 来在系统 Crash 重启之类的情况时修复数据（事务的持久性），而 undo log 来保证事务的原子性。



# 4. Etcd

etcd 的数据目录下有两个子目录`wal`和`snap`。它们的作用就是实现 WAL 机制

`wal`：存放预写式日志，最大的作用是记录了整个数据变化的全部历程。所有数据的修改在提交前，都要先写入到 WAL 中。

`snap`：存放快照数据，为防止 WAL 文件过多而设置的快照，存储 etcd 数据状态。

WAL 机制使得 etcd 具备了以下两个功能：

- 故障快速恢复：当你的数据遭到破坏时，就可以通过执行所有 WAL 中记录的修改操作，快速从最原始的数据恢复到数据损坏前的状态。
- 数据回滚（undo）/重做（redo）：因为所有的修改操作都被记录在 WAL 中，需要回滚或重做，只需要方向或正向执行日志中的操作即可



# 5. ElasticSearch

如果没用 `fsync` 把数据从文件系统缓存刷（flush）到硬盘，elasticsearch 不能保证数据在断电甚至是程序正常退出之后依然存在。为了保证可靠性，需要确保数据变化被持久化到磁盘。

在动态更新索引时，elasticsearch 说一次完整的提交会将段刷到磁盘，并写入一个包含所有段列表的提交点。Elasticsearch 在启动或重新打开一个索引的过程中使用这个提交点来判断哪些段隶属于当前分片。

即使通过每秒刷新（refresh）实现了近实时搜索，elasticsearch 仍然需要经常进行完整提交来确保能从失败中恢复。但在两次提交之间发生变化的文档怎么办？

Elasticsearch 增加了一个 translog ，或者叫事务日志，在每一次对 Elasticsearch 进行操作时均进行了日志记录。









