# 1. 全局变量

## 1.1 应用场景

在 Rust 中，静态变量的初始化受严格限制。传统的 const 只能用于编译器已知的常量，而全局可变状态需要现场安全的延迟初始化方案。

在应用程序开发中，如下场景需要使用全局变量：

- 加载配置文件
- 建立数据库连接池
- 初始化日志句柄
- 缓存计算代价高昂的对象



## 1.2 初始化方案

- 早期方案：`lazy_static!` 宏
- 现代方案：`once_cell::sync::OnceCell`
- 标准方案：`std::sync::OnceLock`



方案对比：

| 特性           | OnceCell        | OnceLock |
| :------------- | :-------------- | :------- |
| 来源           | once_cell crate | 标准库   |
| 最小 Rust 版本 | 1.56+           | 1.70+    |
| 线程安全       | ✅               | ✅        |
| 零开销         | ✅               | ✅        |
| API 完整性     | 高              | 中等     |



# 2. 实战示例

## 2.1 全局配置

```rust
// 使用 OnceLock 的全局配置管理器
use std::sync::{OnceLock, Arc};
use std::collections::HashMap;

type ConfigData = HashMap<String, String>;

struct ConfigManager {
    settings: ConfigData,
}

impl ConfigManager {
    fn new() -> Self {
        let mut settings = ConfigData::new();
        settings.insert("host".to_string(), "127.0.0.1".to_string());
    	settings.insert("port".to_string(), "8080".to_string());
		settings.insert("timeout".to_string(), "30".to_string());
        
        Self { settings }
    }
    
    fn get(&self, key: &str) -> Option<&String> {
        self.settings.get(key)
    }
    
    fn validate(&self) -> bool {
        !self.settings.is_empty()
    }
}

// 全局静态变量
static GLOBAL_CONFIG: OnceLock<Arc<ConfigManager>> = OnceLock::new();

// 初始化函数
pub fn init_global_config() -> Result<(), Box<dyn std::error::Error>> {
    let config = ConfigManager::new();
    if !config.validate() {
        return Err("Invalid configuration".into());
    }
    
    GLOBAL_CONFIG.set(Arc::new(config))
    	.map_err(|_| "Configuration already initialized".into())
}

// 访问函数
pub fn get_config() -> &'static Arc<ConfigManager> {
    GLOBAL_CONFIG.get().expect("Configuration not initialized")
}

// 安全访问函数 (推荐)
pub fn get_config_safe() -> Option<&'static Arc<ConfigManager>> {
    GLOBAL_CONFIG.get()
}
```



## 2.2 数据库连接池

```rust
use std::sync::OnceLock;
use std::time::Duration;

#[derive(Debug)]
struct DatabasePool {
    connections: usize,
    timeout: Duration,
}

impl DatabasePool {
    fn new() -> Self {
        DatabasePool {
            connections: 10,
            timeout: Duration::from_secs(30),
        }
    }
    
    fn execute_query(&self, query: &str) -> String {
        format!("Executed: {}, Connections: {}", query, self.connections)
    }
}

static DATABASE_POOL: OnceLock<DatabasePool> = OnceLock::new();

pub fn init_database_pool() -> &'static DatabasePool {
    DATABASE_POOL.get_or_init(|| {
        println!("Initializing database pool...");
        DatabasePool::new()
    })
}

pub fn get_db_pool() -> Option<&'static DatabasePool> {
    DATABASE_POOL.get()
}
```



## 2.3 缓存服务

```rust
use std::sync::{OnceLock, RwLock};
use std::collections::HashMap;
use std::time::{SystemTime, Duration};

struct CacheEntry {
    data: String,
    expires_at: SystemTime,
}

impl CacheEntry {
    fn new(data: String, ttl: Duration) -> Self {
        CacheEntry {
            data,
            expires_at: SystemTime::now() + ttl,
        }
    }
    
    fn is_expired(&self) -> bool {
        SystemTime::now() > self.expires_at
    }
}

struct KmsServiceManager {
    cache: RwLock<HashMap<String, CacheEntry>>,
    default_ttl: Duration,
}

impl KmsServiceManager {
    fn new() -> Self {
        KmsServiceManager {
            cache: RwLock::new(HashMap::new()),
            default_ttl: Duration::from_secs(300),  // 5 minutes
        }
    }
    
    fn get_key(&self, key_id: &str) -> Option<String> {
        let cache = self.cache.read().unwrap();
        
        if let Some(entry) = cache.get(key_id) {
            if !entry.is_expired() {
                return Some(entry.data.clone());
            }
        }
        
        None
    }
    
    fn set_key(&self, key_id: String, data: String) {
        let entry = CacheEntry::new(data, self.default_ttl);
        let mut cache = self.cache.write().unwrap();
        cache.insert(key_id, entry);
    }
    
    fn clear_expired(&self) -> usize {
        let mut cache = self.cache.write().unwrap();
        let before_len = cache.len();
        
        cache.retain(|_, entry| !entry.is_expired());
        before_len - cache.len()
    }
}

// 使用 OnceLock 的全局服务管理器
static GLOBAL_KMS_MANAGER: OnceLock<KmsServiceManager> = OnceLock::new();

pub fn get_kms_service() -> &'static KmsServiceManager {
    GLOBAL_KMS_SERVICE_MANAGER.get_or_init(|| {
        println!("Initializing KMS service manager...");
        KmsServiceManager::new()
    })
}

pub fn initialize_kms_service() -> Result<(), &'static str> {
    let manager = KmsServiceManager::new();
    GLOBAL_KMS_SERVICE_MANAGER.set(manager)
    	.map_err(|_| "KMS service already initialized")
}
```



# 3. 迁移指南

## 3.1 变量定义

```rust
// 迁移前：使用 once_cell
use once_cell::sync::OnceCell;

static CONFIG: OnceCell<AppConfig> = OnceCell::new();
static DATABASE: OnceCell<DatabasePool> = OnceCell::new();
static CACHE: OnceCell<CacheManager> = OnceCell::new();

// 迁移后：使用 OnceLock
use std::sync::OnceLock;
static CONFIG: OnceLock<AppConfig> = OnceLock::new();
static DATABASE: OnceLock<DatabasePool> = OnceLock::new();
static CACHE: OnceLock<CacheManager> = OnceLock::new();
```



## 3.2 API兼容性

对于缺少的方法，提供替代方案

```rust
// OnceCell 特有的方法替代
trait OnceCellCompact<T> {
    fn into_inner(self) -> Option<T>;
    fn take(&mut self) -> Option<T>;
}

// 对需要 into_inner 的场景，可以使用包装类型
struct ManagedCell<T>(OnceLock<T>);

impl<T> ManagedCell<T> {
    fn new() -> Self {
        Self(OnceLock::new())
    }
    
    fn into_inner(self) -> Option<T> {
        // 注意：这需要获取所有权，对于静态变量不适用
        // 主要用于非静态场景
        None // 实际实现会更复杂
    }
}
```



# 4. 最佳实践

## 4.1 初始化策略

```rust
// 方案1：懒初始化(推荐)
pub fn get_service() -> &'static Service {
    static SERVICE: OnceLock<Service> = OnceLock::new();
    SERVICE.get_or_init(|| Service::new())
}

// 方案2：显式初始化
pub fn init_service() -> Result<(), InitError> {
	static SERVICE1: OnceLock<ServiceA> = OnceLock::new();
    static SERVICE2: OnceLock<ServiceB> = OnceLock::new();
    
    SERVICE1.set(ServiceA::new()?)?;
    SERVCIE2.set(ServiceB::new()?)?;
    
    Ok(())
}

// 方案3：带验证的初始化
pub fn initialize_with_validation() -> Result<&'static ValidatedService, InitError> {
    static SERVICE: OnceLock<ValidatedService> = OnceLock::new();
    
    SERVICE.get_or_try_init(|| {
        let service = Service::new();
        service.validate()?;
        Ok(service)
    })
}
```



## 4.2 错误处理模式

```rust
use std::sync::OnceLock;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ServiceError {
    #[error("Service not initialized")]
    NotInitialized,
    #[error("Initialization failed: {0}")]
    InitFailed(String),
}

struct CriticalService;

impl CriticalService {
    fn new() -> Result<Self, ServiceError> {
        // 模拟可能的失败
        if std::env::var("REQUIRED_CONFIG").is_err() {
            return Err(ServiceError:::InitFailed("Missing required config".into()));
        }
        Ok(Self)
    }
}

static CRITICAL_SERVICE: OnceLock<Result<CriticalService, ServiceError>> = OnceLock::new();

pub fn ensure_service() -> Result<&'static CriticalService, ServiceError> {
    CRITICAL_SERVICE.get_or_init(|| CritialService::new()).as_ref()
    	.map_err(|e| match e {
            ServiceError::InitFailed(msg) => ServiceError::InitFailed(msg.clone()),
            _ => ServiceError::NotInitialized,
    })
}
```



## 4.3 测试策略

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::OnceLock;
    
    // 静态变量
    static TEST_SERVICE: OnceLock<String> = OnceLock::new();
    
    #[test]
    fn test_once_lock_initialization() {
        let value = TEST_SERVICE.get_or_init(|| "test_value".to_string());
        assert_eq!(value, "test_value");
        
        // 第二次调用返回相同的实例
        let same_value = TEST_SERVICE.get().unwrap();
        assert_eq!(same_value, "test_value");
    }
    
    #[test]
    fn test_thread_safty() {
        use std::thread;
        
        static COUNTER: OnceLock<usize> = OnceLock::new();
        
        let handlers: Vec<_> = (0..10).map(|_| {
            thread::spawn(|| {
                COUNTER.get_or_init(|| 42);
            })
        }).collect();
        
        for handler in handlers {
            handler.join.unwrap();
        }
        
        assert_eq!(*COUNTER.get().unwrap(), 42);
    }
}
```



# 5. 性能考量

```rust
use std::sync::OnceLock;
use std::time::Instant;

// 性能测试：对比不同初始化方式的开销
struct ExpensiveResource {
    data: Vec<usize>,
}

impl ExpensiveResource {
    fn new() -> Self {
        // 模拟昂贵的初始化
        let data = (0..1_000_000).collect();
        Self { data }
    }
}

static EXPENSIVE_RESOURCE: OnceLock<ExpensiveResource> = OnceLock::new();

pub fn benchmark_initialization() {
    let start = Instant::now();
    
    // 第一次初始化
    let _ = EXPENSIVE_RESOURCE.get_or_init(|| {
        println!("Performing expensive initialization...");
        ExpensiveResource::new()
    });
    
    let first_call = start.elpased();
    
    // 后续访问
    let satrt = Instant::now();
    for _ in 0..1000 {
        let _ = EXPENSIVE_RESOURCE.get().unwrap();
    }
    let subsequent_calls = start.elapsed();
    
    println!("First call: {:?}", first_call);
    println!("Subsequent 1000 calls: {:?}", subsequent_calls);
}
```



# 6. 经典示例

## 6.1 架构设计模式

### 6.1.1 分层初始化

```rust
use std::sync::{OnceLock, RwLock};
use serde::Deserialize;
use tokio::runtime::Runtime;

#[derive(Debug, Deserialize, Clone)]
pub struct DatabaseConfig {
    pub url: String,
    pub max_connections: u32,
    pub timeout_secs: u64,
}

#[derive(Debug, Deserialize, Clone)]
pub struct RedisConfig {
    pub url: String,
    pub key_prefix: String,
}

#[derive(Debug, Deserialize, Clone)]
pub struct AppConfig {
    pub database: DatabaseConfig,
    pub redis: RedisConfig,
    pub log_level: String,
}

// 配置层 - 最先初始化
static APP_CONFIG: OnceLock<AppConfig> = OnceLock::new();

// 运行时层 - 依赖配置
static RUNTIME: OnceLock<Runtime> = OnceLock::new();

// 服务层 - 依赖运行时和配置
static DATABASE_POOL: OnceLock<sqlx::PgPool> = OnceLock::new();
static REDIS_CLIENT: OnceLock<redis::Client> = OnceLock::new();

// 业务层 - 依赖所有底层服务
static USER_SERVICE: OnceLock<UserService> = OnceLock::new();

pub struct UserService {
    db_pool: &'static sqlx::PgPool,
    redis_client: &'static redis::Client,
}

impl UserService {
    pub fn new(db_pool: &'static sqlx::PgPool, redis_client: &'static redis::Client) -> Self {
        Self { db_pool, redis_client }
    }

    pub async fn get_user(&self, user_id: i64) -> Result<Option<User>, ServiceError> {
        // 业务逻辑实现
        Ok(None)
    }
}

// 分层初始化控制器
pub struct AppInitializer;

impl AppInitializer {
    pub fn init_config(config: AppConfig) -> Result<(), InitError> {
        APP_CONFIG.set(config).map_err(|_| InitError::AlreadyInitialized)
    }

    pub fn init_runtime() -> Result<&'static Runtime, InitError> {
        RUNTIME.get_or_try_init(|| {
            Runtime::new().map_err(|e| InitError::RuntimeError(e.to_string()))
        })
    }

    pub async fn init_database() -> Result<&'static sqlx::PgPool, InitError> {
        DATABASE_POOL.get_or_try_init(|| async {
            let config = APP_CONFIG.get().ok_or(InitError::ConfigNotInitialized)?;
            sqlx::postgres::PgPoolOptions::new()
                .max_connections(config.database.max_connections)
                .connect(&config.database.url)
                .await
                .map_err(|e| InitError::DatabaseError(e.to_string()))
        }).await
    }

    pub fn init_services() -> Result<&'static UserService, InitError> {
        USER_SERVICE.get_or_try_init(|| {
            let db_pool = DATABASE_POOL.get().ok_or(InitError::DatabaseNotInitialized)?;
            let redis_client = REDIS_CLIENT.get().ok_or(InitError::RedisNotInitialized)?;
            Ok(UserService::new(db_pool, redis_client))
        })
    }
}
```



### 6.1.2 依赖注入模式

```rust
use std::sync::{OnceLock, RwLock};
use std::collections::HashMap;
use std::any::{Any, TypeId};

type ServiceFactory = Box<dynFn() -> Box<dyn Any + Send + Sync> + Send + Sync>;

struct DiContainer {
    services: RwLock<HashMap<TypeId, Box<dyn Any + Send + Sync>>>,
    factories: RwLock<HashMap<TypeId, ServiceFactory>>,
}

impl DiContainer {
    fn new() -> Self {
        Self {
            services: RwLock::new(HashMap::new()),
            factories: RwLock::new(HashMap::new()),
        }
    }

    fn register<T: 'static + Send + Sync, F: Fn() -> T + Send + Sync + 'static>(
        &self,
        factory: F,
    ) {
        let type_id = TypeId::of::<T>();
        let boxed_factory: ServiceFactory = Box::new(move || Box::new(factory()));

        self.factories.write().unwrap().insert(type_id, boxed_factory);
    }

    fn resolve<T: 'static + Send + Sync>(&self) -> Option<&T> {
        let type_id = TypeId::of::<T>();
        letmut services = self.services.write().unwrap();

        if !services.contains_key(&type_id) {
            let factory = self.factories.read().unwrap().get(&type_id)?.clone();
            let service = factory();
            services.insert(type_id, service);
        }

        services
            .get(&type_id)
            .and_then(|any| any.downcast_ref::<T>())
    }
}

static DI_CONTAINER: OnceLock<DiContainer> = OnceLock::new();

pub struct ServiceLocator;

impl ServiceLocator {
    pub fn initialize() {
        DI_CONTAINER.get_or_init(|| {
            let container = DiContainer::new();

            // 注册服务工厂
            container.register(|| DatabasePool::new());
            container.register(|| RedisClient::new());
            container.register(|| UserService::new(
                Self::get_service::<DatabasePool>().unwrap(),
                Self::get_service::<RedisClient>().unwrap(),
            ));

            container
        });
    }

    pub fn get_service<T: 'static + Send + Sync>() -> Option<&'static T> {
        DI_CONTAINER.get()?.resolve::<T>()
    }
}
```



## 6.2 高级特性和模式

### 6.2.1 配置热重载

```rust
use std::sync::{OnceLock, RwLock};
use std::time::{Duration, Instant};
use tokio::sync::watch;
use serde::Deserialize;

#[derive(Debug, Deserialize, Clone)]
pub struct DynamicConfig {
    pub feature_flags: FeatureFlags,
    pub rate_limits: RateLimits,
    pub timeouts: TimeoutConfig,
}

#[derive(Debug, Deserialize, Clone)]
pub struct FeatureFlags {
    pub enable_new_ui: bool,
    pub experimental_features: bool,
    pub maintenance_mode: bool,
}

static DYNAMIC_CONFIG: OnceLock<RwLock<DynamicConfig>> = OnceLock::new();
static CONFIG_WATCHER: OnceLock<watch::Sender<DynamicConfig>> = OnceLock::new();

pub struct ConfigManager {
    last_reload: Instant,
    reload_interval: Duration,
}

impl ConfigManager {
    pub fn init_initial_config(config: DynamicConfig) -> watch::Receiver<DynamicConfig> {
        let (sender, receiver) = watch::channel(config.clone());

        DYNAMIC_CONFIG.set(RwLock::new(config)).unwrap();
        CONFIG_WATCHER.set(sender).unwrap();

        receiver
    }

    pub async fn start_config_watcher(self) {
        letmut interval = tokio::time::interval(self.reload_interval);

        loop {
            interval.tick().await;

            ifletOk(new_config) = self.load_config_from_source().await {
                self.update_config(new_config).await;
            }
        }
    }

    async fn load_config_from_source(&self) -> Result<DynamicConfig, ConfigError> {
        // 从外部源加载配置（文件、Consul、ETCD等）
        Ok(DynamicConfig {
            feature_flags: FeatureFlags {
                enable_new_ui: true,
                experimental_features: false,
                maintenance_mode: false,
            },
            rate_limits: RateLimits::default(),
            timeouts: TimeoutConfig::default(),
        })
    }

    async fn update_config(&self, new_config: DynamicConfig) {
        // 更新静态配置
        ifletSome(config_lock) = DYNAMIC_CONFIG.get() {
            *config_lock.write().unwrap() = new_config.clone();
        }

        // 通知观察者
        ifletSome(watcher) = CONFIG_WATCHER.get() {
            let _ = watcher.send(new_config);
        }
    }
}

// 配置访问器
pub struct ConfigAccessor;

impl ConfigAccessor {
    pub fn get_config() -> DynamicConfig {
        DYNAMIC_CONFIG
            .get()
            .expect("Config not initialized")
            .read()
            .unwrap()
            .clone()
    }

    pub fn subscribe() -> watch::Receiver<DynamicConfig> {
        CONFIG_WATCHER
            .get()
            .expect("Config watcher not initialized")
            .subscribe()
    }

    pub fn with_config<F, T>(f: F) -> T
    where
        F: FnOnce(&DynamicConfig) -> T,
    {
        let config = DYNAMIC_CONFIG
            .get()
            .expect("Config not initialized")
            .read()
            .unwrap();
        f(&config)
    }
}
```



### 6.2.2 健康检查与就绪探针

```rust
use std::sync::{OnceLock, RwLock};
use std::collections::HashMap;
use std::time::{Instant, Duration};

#[derive(Debug, Clone)]
pub struct HealthStatus {
    pub is_healthy: bool,
    pub message: String,
    pub last_check: Instant,
    pub details: HashMap<String, String>,
}

#[derive(Debug)]
pub struct HealthChecker {
    components: RwLock<HashMap<String, HealthStatus>>,
}

impl HealthChecker {
    pub fn new() -> Self {
        Self {
            components: RwLock::new(HashMap::new()),
        }
    }

    pub fn register_component(&self, name: String, initial_status: HealthStatus) {
        self.components.write().unwrap().insert(name, initial_status);
    }

    pub fn update_status(&self, name: &str, status: HealthStatus) {
        ifletSome(mut components) = self.components.try_write() {
            components.insert(name.to_string(), status);
        }
    }

    pub fn overall_health(&self) -> HealthStatus {
        let components = self.components.read().unwrap();
        letmut is_healthy = true;
        letmut messages = Vec::new();
        letmut details = HashMap::new();

        for (name, status) in components.iter() {
            details.insert(name.clone(), status.message.clone());
            if !status.is_healthy {
                is_healthy = false;
                messages.push(format!("{}: {}", name, status.message));
            }
        }

        HealthStatus {
            is_healthy,
            message: if messages.is_empty() {
                "All systems operational".to_string()
            } else {
                messages.join("; ")
            },
            last_check: Instant::now(),
            details,
        }
    }

    pub fn is_ready(&self) -> bool {
        let required_components = vec!["database", "redis", "external_api"];
        let components = self.components.read().unwrap();

        required_components.iter().all(|comp| {
            components.get(*comp)
                .map(|status| status.is_healthy)
                .unwrap_or(false)
        })
    }
}

static HEALTH_CHECKER: OnceLock<HealthChecker> = OnceLock::new();

pub struct HealthMonitor;

impl HealthMonitor {
    pub fn initialize() -> &'static HealthChecker {
        HEALTH_CHECKER.get_or_init(|| {
            let checker = HealthChecker::new();

            // 注册默认组件状态
            checker.register_component(
                "database".to_string(),
                HealthStatus {
                    is_healthy: false,
                    message: "Not initialized".to_string(),
                    last_check: Instant::now(),
                    details: HashMap::new(),
                },
            );

            checker
        })
    }

    pub async fn start_health_checks() {
        let checker = Self::initialize();

        tokio::spawn(asyncmove {
            letmut interval = tokio::time::interval(Duration::from_secs(30));

            loop {
                interval.tick().await;
                Self::perform_health_checks().await;
            }
        });
    }

    async fn perform_health_checks() {
        let checker = Self::initialize();

        // 检查数据库连接
        ifletSome(db_pool) = ServiceLocator::get_service::<DatabasePool>() {
            let db_health = check_database_health(db_pool).await;
            checker.update_status("database", db_health);
        }

        // 检查 Redis 连接
        ifletSome(redis_client) = ServiceLocator::get_service::<RedisClient>() {
            let redis_health = check_redis_health(redis_client).await;
            checker.update_status("redis", redis_health);
        }
    }
}
```



## 6.3 生产级实践

### 6.3.1 测试策略与 Mocking

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::{OnceLock, Mutex};

    // 测试专用的 DI 容器
    static TEST_CONTAINER: OnceLock<TestContainer> = OnceLock::new();

    struct TestContainer {
        mocks: Mutex<HashMap<TypeId, Box<dyn Any>>>,
    }

    impl TestContainer {
        fn new() -> Self {
            Self {
                mocks: Mutex::new(HashMap::new()),
            }
        }

        fn register_mock<T: 'static>(&self, mock: T) {
            self.mocks.lock().unwrap().insert(TypeId::of::<T>(), Box::new(mock));
        }

        fn get_mock<T: 'static>(&self) -> Option<&T> {
            self.mocks
                .lock()
                .unwrap()
                .get(&TypeId::of::<T>())
                .and_then(|any| any.downcast_ref::<T>())
        }
    }

    pub struct TestSetup;

    impl TestSetup {
        pub fn initialize() {
            TEST_CONTAINER.get_or_init(|| TestContainer::new());
        }

        pub fn register_mock<T: 'static>(mock: T) {
            TEST_CONTAINER.get().unwrap().register_mock(mock);
        }

        pub fn get_mock<T: 'static>() -> &'static T {
            TEST_CONTAINER.get().unwrap().get_mock::<T>().unwrap()
        }
    }

    // 模拟数据库连接池
    struct MockDatabasePool;

    impl MockDatabasePool {
        fn new() -> Self {
            Self
        }
    }

    #[tokio::test]
    async fn test_service_with_mocks() {
        TestSetup::initialize();
        TestSetup::register_mock(MockDatabasePool::new());

        // 测试可以使用模拟对象
        let _mock_pool = TestSetup::get_mock::<MockDatabasePool>();

        // 测试逻辑...
    }

    // 集成测试模块
    #[cfg(feature = "integration-test")]
    mod integration_tests {
        use super::*;

        #[tokio::test]
        async fn test_full_initialization_flow() {
            // 测试完整的初始化流程
            let config = AppConfig::default();
            AppInitializer::init_config(config).unwrap();
            AppInitializer::init_runtime().unwrap();

            // 验证服务已正确初始化
            assert!(ServiceLocator::get_service::<UserService>().is_some());
        }
    }
}
```



### 6.3.2 性能监控与指标

```rust
use std::sync::{OnceLock, atomic::{AtomicU64, Ordering}};
use std::time::Instant;

#[derive(Debug)]
pub struct PerformanceMetrics {
    pub initialization_time: AtomicU64,
    pub service_calls: AtomicU64,
    pub errors: AtomicU64,
    pub cache_hits: AtomicU64,
    pub cache_misses: AtomicU64,
}

impl PerformanceMetrics {
    pub fn new() -> Self {
        Self {
            initialization_time: AtomicU64::new(0),
            service_calls: AtomicU64::new(0),
            errors: AtomicU64::new(0),
            cache_hits: AtomicU64::new(0),
            cache_misses: AtomicU64::new(0),
        }
    }

    pub fn record_initialization_time(&self, duration: std::time::Duration) {
        self.initialization_time.store(duration.as_millis() asu64, Ordering::Relaxed);
    }

    pub fn increment_service_calls(&self) {
        self.service_calls.fetch_add(1, Ordering::Relaxed);
    }

    pub fn increment_errors(&self) {
        self.errors.fetch_add(1, Ordering::Relaxed);
    }

    pub fn record_cache_access(&self, hit: bool) {
        if hit {
            self.cache_hits.fetch_add(1, Ordering::Relaxed);
        } else {
            self.cache_misses.fetch_add(1, Ordering::Relaxed);
        }
    }

    pub fn get_metrics(&self) -> MetricsSnapshot {
        MetricsSnapshot {
            initialization_time_ms: self.initialization_time.load(Ordering::Relaxed),
            service_calls: self.service_calls.load(Ordering::Relaxed),
            errors: self.errors.load(Ordering::Relaxed),
            cache_hits: self.cache_hits.load(Ordering::Relaxed),
            cache_misses: self.cache_misses.load(Ordering::Relaxed),
        }
    }
}

#[derive(Debug, Clone)]
pub struct MetricsSnapshot {
    pub initialization_time_ms: u64,
    pub service_calls: u64,
    pub errors: u64,
    pub cache_hits: u64,
    pub cache_misses: u64,
}

static PERFORMANCE_METRICS: OnceLock<PerformanceMetrics> = OnceLock::new();

pub struct MetricsCollector;

impl MetricsCollector {
    pub fn initialize() -> &'static PerformanceMetrics {
        PERFORMANCE_METRICS.get_or_init(|| PerformanceMetrics::new())
    }

    pub fn record_initialization<F, T>(f: F) -> T
    where
        F: FnOnce() -> T,
    {
        let start = Instant::now();
        let result = f();
        let duration = start.elapsed();

        Self::initialize().record_initialization_time(duration);
        result
    }

    pub fn with_service_call<F, T>(f: F) -> T
    where
        F: FnOnce() -> T,
    {
        Self::initialize().increment_service_calls();
        f()
    }
}

// 使用示例
pub struct InstrumentedUserService {
    inner: UserService,
    metrics: &'static PerformanceMetrics,
}

impl InstrumentedUserService {
    pub fn new(inner: UserService) -> Self {
        Self {
            inner,
            metrics: MetricsCollector::initialize(),
        }
    }

    pub async fn get_user(&self, user_id: i64) -> Result<Option<User>, ServiceError> {
        MetricsCollector::with_service_call(|| async {
            self.inner.get_user(user_id).await
        }).await
    }
}
```



## 6.4 部署与运维

### 6.4.1 优雅关闭与资源清理

```rust
use std::sync::{OnceLock, RwLock};
use tokio::sync::broadcast;

static SHUTDOWN_SIGNAL: OnceLock<broadcast::Sender<()>> = OnceLock::new();
static RESOURCE_CLEANUP: OnceLock<RwLock<Vec<Box<dynFnOnce() + Send>>>> = OnceLock::new();

pub struct GracefulShutdown;

impl GracefulShutdown {
    pub fn initialize() -> broadcast::Receiver<()> {
        let (sender, receiver) = broadcast::channel(1);
        SHUTDOWN_SIGNAL.set(sender).unwrap();

        RESOURCE_CLEANUP.set(RwLock::new(Vec::new())).unwrap();

        receiver
    }

    pub fn register_cleanup_handler<F: FnOnce() + Send + 'static>(cleanup: F) {
        ifletSome(cleanup_handlers) = RESOURCE_CLEANUP.get() {
            cleanup_handlers.write().unwrap().push(Box::new(cleanup));
        }
    }

    pub async fn shutdown() {
        // 发送关闭信号
        ifletSome(sender) = SHUTDOWN_SIGNAL.get() {
            let _ = sender.send(());
        }

        // 等待一段时间让任务完成
        tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;

        // 执行清理操作
        Self::execute_cleanup();
    }

    fn execute_cleanup() {
        ifletSome(cleanup_handlers) = RESOURCE_CLEANUP.get() {
            letmut handlers = cleanup_handlers.write().unwrap();
            whileletSome(handler) = handlers.pop() {
                handler();
            }
        }
    }

    pub fn is_shutdown_initiated() -> bool {
        SHUTDOWN_SIGNAL.get().is_some()
    }
}
```

