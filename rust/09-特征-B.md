# 1. 自动特征扩散规则

概括的讲， `auto trait = marker trait + derived trait`

```rust
// 标记 trait，不需要实现任何方法
trait Marker {}

// 派生 trait，通过派生实现
#[derive(Debug, Clone, PartialEq)]
struct Point {
    x: f64,
    y: f64,
}

// unsafe trait
unsafe trait UnsafeTrait {
    unsafe fn dangerous_operation(&self);
}
```



## 1.1 标记特征 (marker trait)

**marker trait (标记特征)** 是一种 **不包含任何方法或关联项** 的 trait，它的主要作用是通过实现该 trait 来 <font color="red">“标记”某个类型具备某种特性或能力，不涉及行为实现</font>。

| 特性           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| 无方法定义     | 不需要定义任何函数和属性                                     |
| 用于标记类型   | 通过 trait 的存在与否，表达某种“类型信息”                    |
| 编译器特殊处理 | `Send`，`Sync` 等由编译器自动实现或阻止实现                  |
| 手动实现       | 可以为自定义类型手动实现 marker trait，但需小心，避免破坏安全性 |



### 1.1.1 标准库

| auto trait                  | 天赋异能                                                     |
| --------------------------- | ------------------------------------------------------------ |
| `std::marker::Send`         | 自定义数据结构的“跨线程”(所有权转移)数据复制 一 **传值**。"所有权转移"意味着一旦当前线程内的变量值被传给另一线程，那么当前线程上下文就**再也不能**访问该变量的值了 |
| `std::marker:Sync`          | 自定义数据结构的“跨线程“"内存共享 一 **传引用**。此外，由 trait Send 至 trait Sync 的转换关系可概括为：若`<&T: Send>`，那么 `<T: Sync>` |
| `std::marker::Unpin`        | `trait Unpin` 实现类**并不承诺**其实例总是被锚定于内存中的预定**位置不动**。即，为了减少内存碎片的数量；<br/>`trait Unpin` 实现类对象会在其生命周期内被来回腾于【栈】内存各处，强调Rust对【堆〕内存不会做这类腾挪处理 |
| `std::panic::UnwindSafe`    | 当`std:panic::catch_unwind`(闭包)被用来监控执行闭包内的(受控)程序崩溃 unwinding panic 时，被监控闭包的捕获变量都必须实现此特征。 |
| `std::panic::RefUnwindSafe` | 同上                                                         |



#### 1.1.1.1 Send & Sync

```rust
// Send 表示类型可以在线程之间安全传递
fn is_send<T: Send>() {}

// Sync 表示类型可以安全地被多个线程共享
fn is_sysnc<T: Sync>() {}
```

大多数内建类型，如 `i32`，`String`，`Vec<T>` 等都是 `Send` 和 `Sync`

```rust
fn main() {
    is_send::<i32>();
    is_sync::<Vec<u8>>();
}
```



#### 1.1.1.2 Unpin

用于表示类型可以安全地被 "取消固定" (move 后不会 影响器安全性):

```rust
use std::marker::Unpin;

fn assert_unpin<T: Unpin>() {}

fn main() {
    assert_unpin::<i32>();
}
```



### 1.1.2 自定义

定义自己的 marker trait：

```rust
trait MyMarker {}

struct Foo;
impl MyMarker for Foo;
```

虽然这个 trait 没有方法，但可以用 trait bound 来约束使用：

```rust
fn do_something<T: MyMarker>(_: T) {
    println!("T implements MyMarker");
}
```



### 1.1.3 unsafe

某些 marker trait 是 unsafe trait，例如：

```rust
unsafe trait MyUnsafeMarker {}
```

因为错误地标记可能会造成 **内存安全问题** (如错误地标记为 `Send` 可能会导致数据竞争)，所以编译器对内置的 marker trait 的实现有严格限制。



### 1.1.4 Send

Send 是标准库中一个重要的 marker trait，它标识那些可以在线程间安全传输的类型

```rust
pub unsafe auto trait Send {}
```



**核心特性**：

- **自动实现**：Send 是一个 auto trait，意味着编译器会自动为合适的类型实现它。如果一个类型的所有字段都实现了 Send，那么该类型也自动实现 Send
- **不安全**：Send 被标记为 unsafe，意味着手动实现 Send 需要使用 unsafe 代码，因为实现者需要保证类型确实可以安全地在线程间传输



#### 1.1.4.1 典型示例

**Send 类型**：

```rust
use std::thread;
use std::sync::Arc;

fn main() {
    // i32 实现了 Send，可以子啊进程间传输
    let data = 42;
    let handle = thread::spawn(move || {
        println!("{}", data);
    });
    handle.join().unwrap();
    
    // Arc<T> 实现了 Send （当 T: Send + Sync 时)
    let shared_data = Arc::new(vec![1, 2, 3, 4, 5]);
    let shared_data_clone = Arc::clone(&shared_data);
    let handle = thread::spawn(move || {
        println!("{:?}", shared_data_clone);
    });
    handle.join().unwrap();
}
```



**非 Send 类型**：

```rust
use std::rc::Rc;
use std::thread;

fn main() {
    let data = Rc::new(42);
    
    // 编译失败，因为 Rc<T> 没有实现 Send
    let handle = thread::spawn(move || {
        println!("{}", data);
    });
    
    // 错误信息：`Rc<i32>` cannot be sent between threads safely
}
```



**Rc 不是 Send**：

`Rc<T>` 未实现 Send 时因为它使用非原子操作来管理引用计数。如果两个线程同时尝试克隆指向同一个引用计数值的 Rc，它们可能会同时尝试更新引用计数，从而导致未定义行为

```rust
use std::rc::Rc;

// Rc 内部的引用计数操作不是原子的
struct RcExample {
    data: Rc<i32>,
}

// RcExample 不会自动实现 Send，因为 Rc<i32> 不是 Send
```

需要将 `std::rc::Rc` 替换成支持原子操作的 `std::sync::Arc`



#### 1.1.4.2 自定义类型

##### 1.1.4.2.1 自动实现 Send

所有字段都是 Send，将自动实现 Send

```rust
#[derive(Debug)]
struct MyStruct {
    id: i32,
    text: String,
    numbers: Vec<u32>,
}

fn main() {
    let data = MyStruct {
        id: 1,
        text: "hello".to_string(),
        numbers: vec![1, 2, 3],
    };
    
    std::thread::spawn(move || {
        println!("{:?}", data);
    });
}
```



##### 1.1.4.2.2 手动实现 Send

需要使用 unsafe 

```rust
use std::marker::PhantomData;
use std::ptr::NonNull;

// 一个包含裸指针的结构体
struct MyRawPointer<T> {
    ptr: NonNull<T>,
    _marker: PhantomData<T>,
}

// 手动实现 Send
unsafe impl<T> Send for MyRawPointer<T>
	where T: Send,
{
    
}
```



#### 1.1.4.3 实际应用场景

##### 1.1.4.3.1 线程池任务

```rust
use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel::<Box<dyn Fn() + Send>>();
    
    // 工作线程
    let handle = thread::spawn(move || {
        while let Ok(task) = rx.recv() {
            task();
        }
    });
    
    // 发送任务(必须能Send)
    let data = 3;
    tx.send(Box::new(move || {
        println!("{}", data);
    })).unwrap();
    
    drop(tx);
    handle.join.unwrap();
}
```



##### 1.1.4.3.2 异步编程

```rust
use std::future::Future;
use std::pin::Pin;

// Future 必须能Send，才能在不同线程间调度
fn async_test() -> Pin<Box<dyn Future<Output = i32> + Send>> {
    Box::pin(async {
        5
    })
}
```



### 1.1.5 Sync

**Sync & Send**：

- 如果一个类型 `T` 是 `Sync` 的，那么它的引用 `&T` 可以被安全地在多个线程之间共享。即 `T` 是可以被同步访问的类型。

- 一个类型 `T` 是 `Sync` 的，那么 `&T` 将是 `Send` 的。`Send` 标记一个只得所有权可以在线程之间移动。
- **`T` is `Sync` <=> `&T` is `Send`**



**Sync 是一个自动 Trait**：

- 和 `Send` 一样，通常不需要手动为类型实现 Sync
- 如果一个 struct 或 enum 得所有字段都是 Sync 的，那么这个类型本身也是 Sync 的



**Sync 的类型**：

- **基本类型**：`u8`，`f64`，`bool`，`&T` 等。它们的值不可变，共享引用它们不会产生任何副作用
- **聚合类型**：如果一个元组、结构体、枚举的所有成员都是 Sync 的，那么它也是 Sync 的
- **大部分集合**：`Box<T>`，`Vec<T>` 等。只要其包含的类型 `T` 是 `Sync` 的，那么它也是 Sync 的
- **&mut T**：前提 `T` 必须是 `Sync` 的。因为无法从一个共享引用 `&(&mut T)` 中获取可变性，这个引用被降级为只读，即 `&(&T)`。因此线程间共享的 `&mut T` 的引用不会引起数据竞争



**不是 Sync 的类型**：

- **内部可变性**：即一个类型允许通过共享引用 `&self` 修改其内部数据
- **`Cell<T>` 和 `RefCell<T>` **：`Cell` 的 `set` 方法签名是 `fn set(&self, val: T)`。它只需要一个共享引用就能修改内部值，这种修改不是同步的，没有任何锁或原子操作保护。
- **引用计数 `Rc<T>`**：`Rc` 的 `clone` 方法签名是 `fn clone(&self) -> Rc<T>` ，通过它来增加引用计数，该计数操作是非原子的。



**在线程间安全地共享状态** ：

- **锁**：`Mutex<T>`(互斥锁)、`RwLock<T>` (多读单写锁)
- **`Arc<T>`** : 线程安全的引用计数
- **`std::sync::atomic`**：原子类型，包含 `AtomicUsize` 、`AtomicBool` 等



## 1.2 派生特征 (derived trait)

通过 `#[derive]` 属性，编译器能够一个某些 trait 的基本实现。如果需要更复杂的行为，这些 trait 也可以手动实现。

可自动派生的 trait：

- `Eq`, `PartialEq`, `Ord`, `PartialOrd`  比较
- `Clone`  从 `&T` 创建副本 `T`
- `Copy` 使类型具有“复制语义”(copy semantics) 而非“移动语义”(move semantics)
- `Hash` 从 `&T` 计算哈希值 (hash)
- `Default` 创建一个零值实例
- `Debug` 使用 `{:?}` formatter 来格式化一个值



### 1.2.1 比较

 ```rust
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&self) -> Centimeters {
        let &Inches(inches) = self;

        Centimeters(inches as f64 * 2.54)
    }
}

fn main() {
    let foot = Inches(12);

    println!("One foot equals {:?}", foot);

    let meter = Centimeters(50.0);

    let cmp = {
        if foot.to_centimeters() < meter {
            "smaller"
        } else {
            "bigger"
        }
    };
    println!("One foot is {} than one meter.", cmp);
}
 ```



### 1.2.2 Copy & Clone

#### 1.2.2.1 Copy (隐式复制)

- Copy 是一个标记 trait (marker trait，没有任何方法)，表示类型启动**按位复制 (bitwise copy)**；
- 实现了 Copy 的类型**在赋值或传递时，会自动复制值，而不是移动所有权**；
- Copy 是隐式的，编译器会自动为实现了 Copy 的类型生成复制逻辑。



什么类型可以实现 Copy trait？

- POD (Plain Old Data) 类型，即**不包含任何指针、引用、析构函数**
- 类型的所有字段都实现了 Copy



**包含引用字段的类型，不能实现 Copy**：

```rust
struct Foo<'a> {
    x: &'a i32,
}

// error[E0204]: the trait `Copy` may not be implemented for this type
impl Copy for Foo<'_> {}
```



**所有实现了 Copy 的类型，都必须实现 Clone**：

```rust
#[derive(Debug, Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

let p1 = Point { x: 10, y: 20 };
let p2 = p1;               // 自动复制
println!("p1: {:?}", p1);  // 仍然有效
```

<font color="red">基本数据类型 (如i32、f64) 和不可变引用都实现了 `Copy`</font>。但**可变引用无法实现 `Copy`，因为同一时刻只能存在一个可变引用**。



为什么需要 Copy trait？

- Copy trait 允许控制类型的复制行为，当一个类型实现了它时，其值可以在赋值、传参和返回值时自动复制。这样可以避免显示调用 clone 方法来复制值
- Copy 类型的值总是**按位复制，它们复制开销很小**，对提高程序性能非常有帮助



#### 1.2.2.2 Clone (显式深拷贝)

- Clone 是一个显式的 trait，表示类型的值可以通过调用 clone 方法来复制；
- 实现了 Clone 的类型需要显式调用 clone 方法来复制
- Clone 可以用于任何类型，包括那些需要深拷贝 (deep copy) 的复杂类型



```rust
#[derive(Clone)]
struct Buffer {
    data: Vec<u8>,
}

let buf1 = Buffer { data: vec![1, 2, 3] };
let buf2 = buf1.clone();   // 显式深拷贝
```



为什么需要 Clone trait？

- Clone trait 允许显式地复制类型的值，但那些不能按位复制的类型非常有用，例如指针或引用类型
- Clone trait 还允许自定义复制行为，可以在 clone 方法中添加任何逻辑，以便在复制时执行特定的操作

```rust
// 自动实现
#[derive(Clone)]
struct Point {
    x: i32,
    y: i32,
}

// 手动实现
impl Clone for Point {
    fn clone(&self) -> Self {
        Self { x: self.x, y: self.y }
    }
}
```

实现 `Clone` 时需要注意：

- 必须保证 `clone` 实现时安全的
- 对于包含引用的类型，需确保生命周期有效性

- 应该保持 `clone` 后的对象与原对象逻辑等价



当处理资源时，默认的行为是在赋值或函数调用的同时将它们转移。但也可以通过 Clone trait 把资源复制一份。

```rust
// 不含资源的单元结构体
#[derive(Debug, Clone, Copy)]
struct Nil;

// 包含资源的结构体
#[derive(Clone, Debug)]
struct Pair(Box<i32>, Box<i32>);

fn main() {
    // 实例化 Nil
    let nil = Nil;

    // 复制，未发生资源移动 move
    let copied_nil = nil;

    println!("original: {:?}", nil);
    println!("copied: {:?}", copied_nil);

    // 实例化 Pair
    let pair = Pair(Box::new(1), Box::new(2));
    println!("original: {:?}", pair);

    // 移动
    let moved_pair = pair;
    println!("copied: {:?}", moved_pair);

    // pair 已失去资源
    // println!("original: {:?}", pair);

    // 克隆
    let cloned_pair = moved_pair.clone();
    drop(moved_pair);

    // moved_pair 被销毁，无法访问
    // println!("copied: {:?}", moved_pair);

    // clone 的资源可正常访问
    println!("cloned: {:?}", cloned_pair);
}
```



#### 1.2.2.3 异同点

| 特性         | `Copy`                             | `Clone`                          |
| :----------- | :--------------------------------- | :------------------------------- |
| **复制方式** | 隐式复制（自动）                   | 显式复制（调用`clone()`）        |
| **所有权**   | 保留原变量                         | 保留原变量                       |
| **适用类型** | 简单类型（如`u8`、`i32`、`f64`）   | 任何类型（包括复杂类型）         |
| **实现方式** | 标记 trait，编译器自动生成复制逻辑 | 需要手动实现`clone`方法          |
| **性能**     | 内存级复制，高效（位复制）         | 可能较低（深拷贝可能涉及堆分配） |
| **适用场景** | 简单值类型                         | 需要深拷贝的复杂类型             |
| **析构函数** | 禁止                               | 允许存在                         |


注意事项：

- 所有实现了 `Copy` 的类型，必须也实现 `Clone`，因为 `Copy` 是 `Clone` 的子 trait；
- 对于大型数据结构，频繁复制可能会导致性能问题。在这种情况下，考虑使用引用或智能指针（如`Rc`、`Arc`）来避免复制

- `Copy`只能用于不涉及所有权转移的类型。例如，`String`和`Vec`不能实现`Copy`，因为它们涉及堆内存的所有权管理。



总结：

- **`Copy`**是隐式的、高效的复制机制，适用于小型、无所有权的数据类型。

- **`Clone`**是显式的复制机制，适用于任何类型，尤其是需要深拷贝的复杂数据类型。



# 2. 内置特征

## 2.1 Drop

Drop trait 只有一个方法： drop，当对象离开作用域时会自动调用该方法，其主要作用是释放实现者实例拥有的资源。

`Box`，`Vec`, `String`, `File` 及 `Process` 是一些实现了 Drop trait 来释放资源的类型。

```rust
struct Droppable {
    name: &'static str,
}

impl Drop for Droppable {
    fn drop(&mut self) {
        println!("> Dropping {}", self.name);
    }
}

fn main() {
    let _a = Droppable { name: "a" };

    {
        let _b = Droppable { name: "b" };

        {
            let _c = Droppable { name: "c" };
            let _d = Droppable { name: "d" };

            println!("Exiting block B");
        }
        println!("Just exited block B");

        println!("Exiting block A");
    }
    println!("Just exited block A");

    // 手动调用 drop 函数销毁
    drop(_a);

    println!("End of the main function");
}
```



## 2.2 Iterator

Iterator trait 用来对集合类型实现迭代器。该 trait 只需要定义一个返回 next 元素的方法。

for 结构会使用 `.into_iter()` 方法将一些集合类型转换为迭代器

```rust
struct Fibonacci {
    curr: u32,
    next: u32,
}

impl Iterator for Fibonacci {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        let new_next = self.curr + self.next;

        self.curr = self.next;
        self.next = new_next;

        Some(self.curr)
    }
}

fn fibonacci() -> Fibonacci {
    Fibonacci { curr: 1, next: 1 }
}

fn main() {
    // 序列迭代器
    let mut sequence = 0..3;
    println!("Four consecutive `next` calls on 0..3");
    println!("> {:?}", sequence.next());
    println!("> {:?}", sequence.next());
    println!("> {:?}", sequence.next());
    println!("> {:?}", sequence.next());

    // for 迭代
    println!("Iterate through 0..3 using `for`");
    for i in 0..3 {
        println!("> {}", i);
    }

    // 数组
    let array = [1u32, 4, 7, 8];
    println!("Iterate the following array: {:?}", array);
    for i in array.iter() {
        println!("> {}", i);
    }

    // take(n) 获取前 n 项
    println!("The first four terms of the Fibonacci sequence are:");
    for i in fibonacci().take(4) {
        println!("> {}", i);
    }

    // skip(n) 跳过前 n 项
    println!("The next for terms of the Fibonacci sequence are:");
    for i in fibonacci().skip(4).take(4) {
        println!("> {}", i);
    }
}
```



## 2.3 算术运算符

`std::ops::arith.rs` 中定义了以下核心特征：

- Add/AddAssign: 加法运算 (+)
- Sub/SubAssign: 减法运算 (-)
- Mul/MulAssign: 乘法运算 (*)
- Div/DivAssign: 除法运算 (/)
- Rem/RemAssign: 取余运算 (%)
- Neg: 取负运算 (-)



### 2.3.1 加减

```rust
use std::ops::{Add, Sub};

#[derive(Debug, Clone, Copy)]
struct Complex {
    real: f64,
    image: f64,
}

impl Complex {
    fn new(real: f64, image: f64) -> Self {
        Complex { real, image }
    }
}

impl Add for Complex {
    type Output = Complex;
    
    fn add(self, rhs: Self) -> Self::Output {
        Complex {
            real: self.real + rhs.real,
            image: self.image + rhs.image,
        }
    }
}

impl Sub for Complex {
    type Output = Complex;
    
    fn sub(self, rhs: Self) -> Self::Output {
        Complex {
            real: self.real - rhs.real,
            image: self.image - rhs.image,
        }
    }
}
```



### 2.3.2 泛型运算符

```rust
use std::ops::{Add, Mul};
use std::fmt::Debug;

#[derive(Debug)]
struct Vector<T> {
    components: Vec<T>,
}

impl<T> Vector<T>
where
	T: Add<Output = T> + Clone,
{
    fn new(components: Vec<T>) -> Self {
        Vector { components }
    }
}

impl<T> Add for Vector<T>
where
	T: Add<Output = T> + Clone,
{
    type Output = Option<Vector<T>>;
    
    fn add(self, rhs: Self) -> Self::Output {
        if self.components.len() != rhs.components.len() {
            return None;
        }
        
        let components = self.components
        	.iter()
        	.zip(rhs.components.iter())
        	.map(|a, b| a.clone() + b.clone())
        	.collect();
        
        Some(Vector { components })
    }
}
```



### 2.3.3 自定义赋值运算符

```rust
use std;:ops::{AddAssign, MulAssign};

#[derive(Debug)]
struct Counter {
    value: i32,
    max: i32,
}

impl AddAssign<i32> for Counter {
    fn add_assign(&mut self, rhs: i32) {
        self.value = (self.value + rhs).min(self.max);
    }
}

impl MulAssign<i32> for Counter {
    fn mul_assign(&mut self, rhs: i32) {
        self.value = (self.value * rhs).min(self.max);
    }
}

fn main() {
    let mut counter = Counter {
        value: 5,
        max: 100,
    };
    
    counter += 10;
    println!("After addition: {:?}", counter);
    
    counter *= 2;
    println!("After multiplication: {:?}", counter);
}
```



### 2.3.4 自定义数值类型

```rust
use std::ops::{Add, Sub, Mul, Div};
use std::cmp::PartialEq;

#[derive(Debug, Copy, Clone)]
struct Decimal {
    value: i64,
    scale: u8,
}

impl Decimal {
    fn new(value: i64, scale: u8) -> Self {
        Decimal { value, scale }
    }
    
    fn normalize(self, other: Self) -> (Self, Self) {
        if self.scale == other.scale {
            return (self, other);
        }
        
        if self.scale > other.scale {
            iet factor = 10_i64.pow((self.scale - other.scale) as u32);
            (self, Decial::new(other.value * factor, self.scale))
        } else {
            let factor = 10_i64.pow((other.scale - self.scale) as u32);
            (Decimal::new(self.value * factor, other.scale), other)
        }
    }
}
```



### 2.3.5 运算符重载与类型转换

```rust
use std::ops::{Add, Mul};
use std::convert::From;

#[derive(Debug, Clone, Copy)]
struct Percentage(f64);

impl From<f64> for Percentage {
    fn from(value: f64) -> Self {
        Percentage(value.clamp(0.0, 100.0))
    }
}

impl Add for Percentage {
    type Output = Self;
    
    fn add(self, rhs: Self) -> Self {
        Percentage::from(self.0 + rhs.0)
    }
}

impl Mul<f64> for Percentage {
    type Output = Self;
    
    fn mul(self, rhs: f64) -> Self {
        Percentage::from(self.0 * rhs)
    }
}

impl Mul<Percentage> fro f64 {
    type Output = f64;
    
    fn mul(self, rhs: Percentage) -> f64 {
        self * (rhs.0 / 100.0)
    }
}
```



## 2.4 Sized

### 2.4.1 Sized 约束

在 Rust 中，绝大多数类型在编译期必须又固定的大小 (Sized)

```rust
u32   // 4 bytes
i64   // 8 bytes

struct Point { x: i32, y: i32 }   // 8 bytes
```

编译器需要知道类型的大小，才能在栈上分配空间。

编译器会字段给泛型类型加上 `Sized` 约束，普通泛型 `T` 默认要求是  `Sized` 类型：

```rust
fn foo<T>(x: T) {}

// 编译器自动增加 Sized 约束
fn foo<T: Sized>(x: T) {}
```



### 2.4.2 非 Sized 类型

动态大小类型 (DST, Dynamically Sized Type) 在编译期大小不确定，因此不是 `Sized`：

- `str`  长度只在运行时确定
- `[T]` 切片，长度不定
- trait 对象，如 `dyn MyTrait`，背后大小不定

这些类型不能直接放在栈上，必须通过引用或智能指针使用：

```rust
let s: str;          // 编译错误，大小未知
let s: &str;         // 通用引用间接使用
```



### 2.4.3 `?Sized`

`?Sized` 允许这个类型可能是 `Sized`，也可能不是 `Sized`

它常用在**泛型参数**上，让函数或结构体支持处理 DST：

```rust
fn foo<T: ?Sized>(x: &T) {}
```

根据 `T` 的具体类型来确定：

- Sized (如 `i32`、`String`)，`&T` 是正常引用
- `str`、`[u8]` 或 `dyn Trait`，`&T` 是胖指针 (带元数据)



### 2.4.4 综合对比

```rust
// Sized: 编译时已知大小的类型
let x: i32 = 43;
let a: [u8; 4] = [1, 2, 3, 4];

// ?Sized: 编译时未知大小的类型
let str_slice: &str = "hello";
let dyn_trait: &dyn Display = &42;

// 编译器自动添加 Sized 约束 fn generic_sized<T: Sized>(value: T)
fn generic_sized<T>(value: T) {
    println!("Size: {}", std::mem::size_of::<T>());
}
```



### 2.4.5 实例

#### 2.4.5.1 智能指针

```rust
struct CustomBox<T: ?Sized>(Box<T>);

impl<T: ?Sized> CustomBox<T> {
    fn new<U>(value: U) -> CustomBox<U>
    where
    	U: Sized,
    {
        CustomBox(Box::new(value))
    }
}

impl CustomBox<str> {
    fn from_str(s: &str) -> CustomBox<str> {
        CustomBox(s.into())
    }
}
```



#### 2.4.5.2 动态分发优化

```rust
trait VirtualMethod {
    fn process(&self);
}

// 优化前：需要两次解引用
struct Unoptimized<T: ?Sized> {
    data: Box<T>,
}

// 优化后：胖指针直接存储
struct Optimized<T: ?Sized> {
    data: T
}

fn optimize_dispatch() {
    impl VirtualMethod for String {
        fn process(&self) {
            println!("Processing string: {}", self);
        }
    }
    
    let opt: Optimized<Box<dyn VirtualMethod>> = Optimized {
		data: Box::new(String::from("test"))
    };
}
```



#### 2.4.5.3 零成本抽象

```rust
#[repr(C)]
struct ZeroCost<T: ?Sized> {
    len: usize,
    data: T,
}

// 只有 Sized 类型可创建
impl<T: ?Sized> ZeroCost<T> {
    fn new<U: Sized>(data: U) -> ZeroCost<U> {
        ZeroCost {
            len: std::mem::size_of::<U>(),
            data,
        }
    }
}

// 特化实现
impl ZeroCost<[u8]> {
    fn from_slice(slice: &[u8]) -> Box<ZeroCost<[u8]>> {
        let len = slice.len();
        // --snip--
        unimplemented!()
    }
}
```



#### 2.4.5.4 Borrow 中使用 `?Sized`

```rust
pub trait Borrow<Borrowed>
where
	Borrowed: ?Sized,
{
    fn borrow(&self) -> &Borrowed;
}
```

原因：

- 借用的目标类型 (`Borrowed`) 可能是切片 `[T]`、`str` 或 `dyn Trait`

- 如果不加 `?Sized`，`Borrowed` 默认加上 `Sized` 约束，将不能实现：

  ```rust
  impl Borrow<str> for String {}
  impl<T> Borrow<[T]> for Vec<T> {}
  ```

  

## 2.5 Borrow

Borrow trait 让集合支持**跨类型查找**，但又不丢失哈希、比较一致性，比如 `HashMap`、`BTreeMap` 的 key 查询时。

Borrow 定义在 `std::borrow::Borrow`：

```rust
pub trait Borrow<Borrowed>
where
	Borrowed: ?Sized,
{
    fn borrow(&self) -> &Borrowed;
}
```

- **泛型参数 `Borrowed`**：要借用成的目标类型，可以是一个具体类型 (如 `str`) 或动态大小类型 (如 `?Sized` 允许 `str`)
- **核心思想**：用于在 **逻辑等价** 的不同类型之间建立 “借用关系”，而不仅仅是物理上的引用。比如 `String` 和 `str`
  - `String` 拥有所有权
  - `str` 切片引用
  - `String` 实现了 `Borrow<str>`，这样 `&String`  可以“借用”成 `&str`

它和普通的 `AsRef` 很像，但设计目标不同：

| Trait    | 语义                                               | 场景                                           |
| -------- | -------------------------------------------------- | ---------------------------------------------- |
| `AsRef`  | 只要求可以无开销地转换成某个引用类型               | I/O API、通用函数参数                          |
| `Borrow` | 要保证**借用结果在`Eq`/`Hash`/`Ord` 等比较上等价** | 容器查找、键比较 (`HashMap`/`BTreeMap` 的 key) |



**等价性保证**，`Borrow` 有额外的约束：

如果 `a.borrow() == b.borrow()`，那么 `a` 和 `b` 在逻辑上必须等价 (`Eq` / `Hash` / `Ord` 一致)，这样才能安全用于集合查找



## 5.1 实现原理

```rust
use std::collections::HashMap;

let mut map: HashMap<String, i32> = HashMap::new();
map.insert("hello".to_string(), 42);

// 用 &str 查找 String 类型的 key
assert_eq!(map.get("hello"), Some(&42));
```

为什么 `map.get("hello")` 能编译？

- `HashMap::get` 的签名如下：

  ```rust
  pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
  where
  	K: Borrow<Q>,
  	Q: Hash + Eq,
  ```

- 这里 `K = String`，`Q = str`，在标准库中：

  ```rust
  impl Borrow<str> for String {
      fn borrow(&self) -> &str {
          self.as_str()
      }
  }
  ```

- 编译器发现：

  - `String: Borrow<str>`
  - `str: Hash+ Eq`

- 所以 `&str` 也可以用来查找 `String` key 的 `HashMap`



### 2.5.2 实例

#### 2.5.2.1 `String` 和 `str`

```rust
use std::borrow::Borrow;
use std::collections::HashMap;

fn main() {
    let mut map: HashMap<String, i32> = HashMap::new();
    map.insert("apple".to_string(), 5);
    
    // 直接用 &str 查找 String key
    let count = map.get("apple").unwrap();
    println!("count = {}", count);
    
    // 手动调用 Borrow
    let s: String = "hello".to_string();
    let slice: &str = s.borrow();
    println!("{}", slice);
}
```



调用关系链：

```rust
map.get("apple")          // 类型：&str

↓ （编译器匹配 HashMap::get 的泛型约束）
HashMap<K=String, V>::get<Q>(&self, k: &Q) -> Option<&V>
where
    K: Borrow<Q>,         // String 必须实现 Borrow<str>
    Q: Hash + Eq

↓
String::borrow(&self) -> &str
    // 标准库实现：
    impl Borrow<str> for String {
        fn borrow(&self) -> &str {
            self.as_str()
        }
    }

↓
HashMap 内部调用：
1. 对 key 进行 hash 计算：
   hash(k.borrow())   // 这里 k 是 &str
2. 根据 hash 值定位到桶
3. 桶里每个 key 也调用 key.borrow() -> &str 进行 Eq 比较

↓
返回匹配的 value 引用
```



关键点：

- `Borrow` 在 **查找参数** 和 **容器中存的key** 上都会被调用一次：

  - 查找参数 `k.borrow()` => 生成比较/哈希所需的引用类型
  - 容器中每个 `key.borrow()` => 确保比较双方类型一致

- `Hash` 和 `Eq` 都基于 `borrow()` 的返回类型来执行，这是它能保证跨类型查找结果一致的关键

- 这种设计使得：

  ```
  HashMap<String, V>   可以用 &str 查找
  HashSet<Vec<u8>>     可以用 &[u8] 查找
  BTreeMap<Box<K>>     可以用 &K 查找
  ```

  

#### 2.5.2.2 自定义类型跨类型查找

```rust
use std::borrow::Borrow;
use std::collections::HashSet;

#[derive(Hash, Eq, PartialEq, Debug)]
struct UserId(String);

#[derive(Hash, Eq, PartialEq, Debug)]
struct Username(String);

// 让 UserId 借用成 str
impl Borrow<str> for UserId {
    fn borrow(&self) -> &str {
        &self.0
    }
}

fn main() {
    let mut users: HashSet<UserId> = HashSet::new();
    users.insert(UserId("alice".into()));
    users.insert(UserId("bob".into()));
    
    // 直接用 &str 查找
    assert!(users.contains("alice"));
    assert!(!users.contains("carol"));
}
```



#### 2.5.2.3 自定义 `Borrow` 改变容器比较逻辑

```rust
use std::borrow::Borrow;
use std::collections::HashSet;

#[derive(Debug)]
struct CaseInsensitive(String);

impl Borrow<str> for CaseInsensitive {
    fn borrow(&self) -> &str {
        &self.0
    }
}

impl PartialEq for CaseInsensitive {
    fn eq(&self, other: &Self) -> bool {
        self.0.eq_ingore_ascii_case(&other.0)
    }
}

impl Eq for CaseInsensitive {}

impl std::hash::Hash for CaseInsensitive {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.0.to_lowercase().hash(state);
    }
}

fn main() {
    let mut set: HashSet<CaseInsensitive> = HashSet::new();
    set.insert(CaseInsensitive("Hello".into()));
    
    assert!(set.contains("hello"));
}
```



### 2.5.3 总结

- `Borrow` 用于跨类型借用，尤其是集合查找时让 `&T` 能当作 `&U` 用
- 它要求借用后的类型在 `Eq` / `Hash` / `Ord` 等比较上保持一致
- 场景内置实现：
  - `String: Borrow<str>`
  - `Vec<T>: Borrow<[T]`
  - `Box<T>: Borrow<T>`
- 自定义类型可以实现 `Borrow`，从而让集合支持不同但等价的 key 查找









































