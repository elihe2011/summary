# 1. åŸºæœ¬ç±»å‹

- æœ‰ç¬¦å·æ•´æ•°ï¼ˆsigned integersï¼‰ï¼š`i8`ã€`i16`ã€`i32`ã€`i64`ã€`i128` å’Œ `isize`ï¼ˆæŒ‡é’ˆå®½åº¦ï¼‰
- æ— ç¬¦å·æ•´æ•°ï¼ˆunsigned integersï¼‰ï¼š `u8`ã€`u16`ã€`u32`ã€`u64`ã€`u128` å’Œ `usize`ï¼ˆæŒ‡é’ˆå®½åº¦ï¼‰
- æµ®ç‚¹æ•°ï¼ˆfloating pointï¼‰ï¼š `f32`ã€`f64`
- `char`ï¼ˆå­—ç¬¦ï¼‰ï¼šå•ä¸ª Unicode å­—ç¬¦ï¼Œå¦‚ `'a'`ï¼Œ`'Î±'` å’Œ `'âˆ'`ï¼ˆæ¯ä¸ªéƒ½æ˜¯ 4 å­—èŠ‚ï¼‰
- `bool`ï¼ˆå¸ƒå°”å‹ï¼‰ï¼šåªèƒ½æ˜¯ `true` æˆ– `false`
- å•å…ƒç±»å‹ï¼ˆunit typeï¼‰ï¼š`()`ã€‚å…¶å”¯ä¸€å¯èƒ½çš„å€¼å°±æ˜¯ `()` è¿™ä¸ªç©ºå…ƒç»„



## 1.1 æ•°å€¼ç±»å‹

### 1.1.1 æ•´æ•°

| ength   | Signed  | Unsigned |
| ------- | ------- | -------- |
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| arch    | `isize` | `usize`  |

æ•´å‹è¡¨ç¤ºæ³•ï¼š

| Number literals  | Example       |
| ---------------- | ------------- |
| Decimal          | `98_222`      |
| Hex              | `0xff`        |
| Octal            | `0o77`        |
| Binary           | `0b1111_0000` |
| Byte (`u8` only) | `b'A'`        |

ç¤ºä¾‹ï¼š

```rust
let x = 5;
let y: u32 = 123_456;
let z: f64 = 1.23e+2;
let zero = z.min(123.4);
let bin = 0b1111_0000;
let oct = 0o7320_1546;
let hex = 0xf23a_b049;
```

**ç¼–è¯‘æ—¶æ•´å‹æº¢å‡º**ï¼š

- debug æ¨¡å¼ï¼Œæ£€æŸ¥æ•´å‹æº¢å‡ºï¼Œè‹¥å­˜åœ¨é—®é¢˜ï¼Œåˆ™ç›´æ¥ *panic*

- release æ¨¡å¼ï¼Œ**ä¸ä¼š**æ£€æµ‹æº¢å‡ºã€‚å½“æ•´å‹æº¢å‡ºæ—¶ï¼Œä¼šæŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºï¼ˆ*twoâ€™s complement wrapping*ï¼‰çš„è§„åˆ™å¤„ç†ã€‚

æ˜¾å¼å¤„ç†å¯èƒ½çš„æº¢å‡ºï¼Œä½¿ç”¨æ ‡å‡†åº“é’ˆå¯¹åŸå§‹æ•°å­—ç±»å‹æä¾›çš„æ–¹æ³•ï¼š

- `wrapping_*`ï¼šæ‰€æœ‰æ¨¡å¼ä¸‹ï¼ŒæŒ‰ç…§è¡¥ç æº¢å‡ºè§„åˆ™å¤„ç†ï¼Œä¾‹å¦‚ `wrapping_add`
- `checked_*`ï¼šå‘ç”Ÿæº¢å‡ºï¼Œè¿”å›None
- `overflowing_*`ï¼šè¿”å›ç»“æœå€¼åŠæ˜¯å¦æº¢å‡ºboolå€¼
- `saturating_*`ï¼šä½¿å€¼è¾¾åˆ°æœ€å°å€¼æˆ–æœ€å¤§å€¼

```rust
fn main() {
    let a: u8 = 255;
    let b = a.wrapping_add(20);
    println!("{}", b);
}
```

è¡¥å……ï¼š

- æ­£æ•°ï¼šåŸç ã€åç ã€è¡¥ç  ä¸å˜
- è´Ÿæ•°ï¼š
  - åŸç ï¼šç¬¦å·ä½1 | ç»å¯¹å€¼åŸç 
  - åç ï¼šç¬¦å·ä½1 | åŸç å–å
  - è¡¥ç ï¼šç¬¦å·ä½1 | åç +1     ç¬¦å·ä½å‚ä¸è¿ç®—



### 1.1.2 æµ®ç‚¹ç±»å‹

`f32` ï¼šå•ç²¾åº¦ ï¼Œ`f64`ï¼š åŒç²¾åº¦

**æµ®ç‚¹æ•°é™·é˜±**ï¼š

- æµ®ç‚¹æ•°æ˜¯ä¸€ç§è¿‘ä¼¼è¡¨è¾¾ï¼Œå—é™äºæµ®ç‚¹æ•°ç²¾åº¦
- æµ®åŠ¨æ•°ä½¿ç”¨ `>`ï¼Œ`>=` ç­‰è¿›è¡Œæ¯”è¾ƒï¼Œåœ¨æŸäº›åœºæ™¯ä¸‹ä¸æ­£ç¡®ã€‚æ¨èä½¿ç”¨ `std::cmp::PartialEq` è¿›è¡Œæµ®ç‚¹æ•°æ¯”è¾ƒ

HashMap Key çš„ç±»å‹å¿…é¡»å®ç° `std::cmp::Eq` ç‰¹æ€§ã€‚ä½† f32 å’Œ f64 å‡æœªå®ç°è¯¥æ¥å£ï¼Œæ‰€ä»¥æ— æ³•ä½¿ç”¨æµ®ç‚¹æ•°ä½œä¸º HashMap çš„Keyã€‚

```rust
fn main() {
    assert!(0.1 + 0.2 == 0.3) // panic
}
```

**NaN**ï¼šæ•°å­¦ä¸Šæœªå®šä¹‰çš„ç»“æœ(not a number)

```rust
fn main() {
    // è´Ÿæ•°å¹³æ–¹æ ¹
    let x = (-42.1_f32).sqrt();
    println!("{}", x);          // NaN
    println!("{}", x.is_nan()); // true
}
```



### 1.1.3 åºåˆ—(Range)

åºåˆ—åªå…è®¸ç”¨äºæ•°å­—æˆ–å­—ç¬¦ç±»å‹ï¼Œå®ƒä»¬æ˜¯è¿ç»­ï¼Œç¼–è¯‘å™¨åœ¨ç¼–è¯‘æœŸå¯ä»¥æ£€æŸ¥è¯¥åºåˆ—æ˜¯å¦ä¸ºç©ºï¼Œ**å­—ç¬¦å’Œæ•°å­—å€¼æ˜¯ Rust ä¸­ä»…æœ‰çš„å¯ä»¥ç”¨äºåˆ¤æ–­æ˜¯å¦ä¸ºç©ºçš„ç±»å‹**

```rust
fn main() {
    // [1, 5)
    for i in 1..5 {
        print!("{} ", i)
    }
    println!();

    // ['a', 'z']
    for i in 'a'..='z' {
        print!("{} ", i)
    }
}
```



### 1.1.4 å¤æ•°

æœªåŒ…å«åœ¨æ ‡å‡†åº“ä¸­ï¼Œéœ€è¦å¼•å…¥ç¤¾åŒºåº“ `num = "0.4.0"`

```rust
use num::complex::Complex;

fn main() {
    let a = Complex {re: 2.1, im: -1.2};
    let b = Complex::new(1.5, 0.7);

    let result = a + b;
    println!("{} + {}i", result.re, result.im);
}
```



## 1.2 å­—ç¬¦ (char)

Rust å­—ç¬¦åŒ…å« `ASCII`ã€`Unicode` ï¼ˆå•ä¸ªä¸­æ—¥éŸ©æ–‡å­—ã€emojiç­‰ï¼ŒèŒƒå›´ä» `U+0000 ~ U+D7FF` å’Œ `U+E000 ~ U+10FFFF`ï¼‰

```rust
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let g = 'ä¸­';
    let e = 'ğŸ˜»';

    println!("{}: {}, {}", c, c.len_utf8(), std::mem::size_of_val(&c)); // 1, 4
    println!("{}: {}, {}", z, z.len_utf8(), std::mem::size_of_val(&z)); // 3, 4
    println!("{}: {}, {}", g, g.len_utf8(), std::mem::size_of_val(&g)); // 3, 4
    println!("{}: {}, {}", e, e.len_utf8(), std::mem::size_of_val(&e)); // 4, 4
}
```



## 1.3 å¸ƒå°” (bool)

å€¼ä¸º `true` å’Œ `false`ï¼Œå†…å­˜å ç”¨ `1` ä¸ªå­—èŠ‚



## 1.4 å•å…ƒç±»å‹

å•å…ƒç±»å‹`()`ï¼š

- main å‡½æ•°è¿”å›å€¼
- `println!()` å®çš„è¿”å›å€¼

`()` ä¸å ç”¨å†…å­˜ï¼Œå¯ä½œä¸º HashMap çš„å€¼ï¼Œç”¨æ³•å’Œ Go è¯­è¨€çš„ `struct{}` ç±»ä¼¼ï¼Œåªç”¨æ¥å ä½

**å‘æ•£å‡½æ•° ( diverge function )**ï¼šRust ä¸­æ²¡æœ‰è¿”å›å€¼çš„å‡½æ•°ï¼Œå…¶ç‰¹ç‚¹æ˜¯æ— æ³•æ”¶æ•›



# 2. å¤åˆç±»å‹

## 2.2 å­—ç¬¦ä¸²

**Rust å­—ç¬¦æ˜¯ Unicode ç±»å‹ï¼Œæ¯ä¸ªå­—ç¬¦å æ® 4 ä¸ªå­—èŠ‚å†…å­˜ç©ºé—´ï¼›å­—ç¬¦ä¸²æ˜¯ UTF-8 ç¼–ç ï¼Œå…¶ä¸­æ‰€å çš„å­—èŠ‚æ•°æ•°å˜åŒ–çš„(1-4)**ï¼Œè¿™æ ·æœ‰åŠ©äºå¤§å¹…é™ä½å­—ç¬¦ä¸²æ‰€å çš„å†…å­˜ç©ºé—´ã€‚

å­—ç¬¦ä¸²ç±»å‹ï¼š

- `&str`ï¼šç¡¬ç¼–ç å­—ç¬¦ä¸²ï¼Œå­˜å‚¨åœ¨ç¨‹åºç‰‡æ®µä¸­ï¼Œé™æ€åˆ†é…ï¼Œå›ºå®šå¤§å°ï¼Œä¸”ä¸å¯å˜ï¼Œ**å­—ç¬¦å­—é¢é‡æ˜¯åˆ‡ç‰‡**ã€‚æŒ‡å‘ä¸€ä¸ªæœ‰æ•ˆ UTF-8 åºåˆ—çš„åˆ‡ç‰‡ `&[u8]`
- Stringï¼šå¯å˜å­—ç¬¦ä¸²ï¼Œå­˜å‚¨åœ¨**å †å†…å­˜ä¸Š**ï¼Œå¯åŠ¨æ€æ”¹å˜å¤§å°å’Œå€¼ï¼Œä¸”å…·æœ‰æ‰€æœ‰æƒ

```rust
fn main() {
    // å †åªè¯»å†…å­˜ä¸­åˆ†é…çš„å­—ç¬¦ä¸²çš„å¼•ç”¨
    let pangram: &'static str = "the quick brown fox jumps over the lazy dog";
    println!("Pangram: {}", pangram);

    // reverse
    println!("Words in reverse");
    for word in pangram.split_whitespace().rev() {
        println!("> {}", word);
    }

    // å¤åˆ¶å­—ç¬¦åˆ° vectorï¼Œæ’åºå¹¶å»é‡
    let mut chars: Vec<char> = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // å¯å˜å­—ç¬¦ä¸²
    let mut string = String::new();
    for c in chars {
        string.push(c);
        string.push_str(", ");
    }
    println!("String: {}", string);

    // åˆ é™¤å­—ç¬¦
    let chars_to_trim: &[char] = &[' ', ','];
    let trimmed_str: &str = string.trim_matches(chars_to_trim);
    println!("Used characters: {}", trimmed_str);
}
```



**æ³¨æ„ï¼šä¸æ”¯æŒå­—ç¬¦ä¸²ç´¢å¼•**

```rust
let s = String::from("hello");
let h = s[0];    // cannot be indexed by `{integer}`
let h = s[0..1]  // ok
```



### 2.2.1 `&str` ä¸ `String` äº’è½¬

```rust
fn main() {
    // &str -> String
    let s1 = String::from("hello");
    let s2= "world".to_string();
    println!("{}, {}", s1, s2);

    // String -> &str
    let s = String::from("hello world");
    let a1 = &s;  // &String -> &str, deref éšå¼å¼ºåˆ¶è½¬æ¢
    let a2 = &s[..];
    let a3 = s.as_str();

    println!("{}, {}, {}", a1, a2, a3);
}
```



### 2.2.2 å­—ç¬¦ä¸²æ“ä½œ

```rust
fn push() {
    let mut s = String::from("hello");
    s.push_str(" rust");
    s.push_str("!");
    println!("{}", s);
}

fn insert() {
    let mut s = String::from("hello rust!");
    s.insert(5, ',');
    s.insert_str(6, " I like");
    println!("{}", s);
}

fn replace() {
    let s1 = String::from("I like rust. Learning rust is my favorite!");
    let r1 = s1.replace("rust", "RUST");
    println!("{}", r1);

    let r2 = s1.replacen("rust", "RUST", 1);
    println!("{}", r2);

    let mut s2 = String::from("I like rust");
    s2.replace_range(7..8, "R");
    println!("{}", s2);
}

fn delete() {
    let mut s = String::from("Rust test ä¸­æ–‡");
    
    // åˆ é™¤æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œè¿”å› Some(char)
    let c1 = s.pop();
    println!("c1: {:?}", c1);  // Some('æ–‡')
    println!("s: {}", s);      // Rust test ä¸­
    
    // åˆ é™¤æŒ‡å®šä½ç½®å­—ç¬¦ï¼Œè¿”å›å­—ç¬¦
    let c2 = s.remove(2);
    println!("c2: {}", c2);  // s
    println!("s: {}", s);    // Rut test ä¸­
    
    // ä»æŒ‡å®šä½ç½®æˆªæ–­å­—ç¬¦ä¸²ï¼Œè¿”å› ()
    s.truncate(6);
    println!("s: {}", s);    // Rut te
    
    // æ¸…ç©ºå­—ç¬¦ä¸²ï¼Œè¿”å› ()
    s.clear();
    println!("s: {}", s);   // ""
}

fn concatenate() {
    // +, +=
    let s1 = String::from("hello");
    let s2 = String::from(" rust");

    // let s = s1 + &s2;  // è‡ªåŠ¨ç”± &String è½¬ä¸º &str
    let s = s1.add(&s2);  // 1.79 å·²ä¸æ”¯æŒ
    println!("{}", s);

    // format!()
    let s3 = String::from("hello");
    let s4 = "rust";
    let s = format!("{} {}", s3, s4);
    println!("{}", s);
}
```



### 2.2.3 å­—ç¬¦ä¸²è½¬ä¹‰

```rust
fn main() {
    // \x  åå…­è¿›åˆ¶
    let byte_escape = "I'm writing \x52\x75\x73\x74!";
    println!("What are you doing\x3F (\\x3F means ?) {}", byte_escape);

    // \u Unicodeå­—ç¬¦
    let unicode_codepoint = "\u{211D}";
    let character_name = "\"DOUBLE-STRUCT CAPITAL R\"";
    println!("Unicode character {} (U+211D) is called {}", unicode_codepoint, character_name);

    // \ å¿½ç•¥æ¢è¡Œ
    let long_string = "String literals
                              can span multiple lines.
                              The linebreak and indentation here ->\
                              <- can be escaped too!";
    println!("{}", long_string);
}
```



### 2.2.4 UTF-8 å­—ç¬¦ä¸²

```rust
use utf8_slice;

fn main() {
    let s = "ä¸­å›½äºº";

    // å­—ç¬¦
    for c in s.chars() {
        println!("{}", c);
    }

    // å­—èŠ‚
    for b in s.bytes() {
        println!("{}", b);
    }

    // å­å­—ç¬¦ä¸²
    let ss = utf8_slice::slice(s, 0, 2);
    println!("{}", ss);
}
```



### 2.2.5 ç±»å‹è½¬æ¢

```rust
let f = 24.4321;
let s = format!("{:.2}", f);
let f2: f64 = s.parse().unwrap();
```



### 2.2.6 åŸå§‹å­—ç¬¦ä¸² (raw string)

```rust
fn main() {
    let raw_str = r"Escapes don't work here: \x3F \u{211D}";
    println!("{}", raw_str);

    // åŸå§‹å­—ç¬¦ä¸²ä¸­æœ‰å¼•å·ï¼Œéœ€æ·»åŠ  #
    let quotes = r#"And then I said: "There is no escape!""#;
    println!("{}", quotes);

    // åŸå§‹å­—ç¬¦ä¸²ä¸­æœ‰ "#" å·ï¼Œå®šç•Œç¬¦ä½¿ç”¨å¤šä¸ª #
    let longer_delimiter = r###"A string with "# in it. And even "##!"###;
    println!("{}", longer_delimiter);
}
```



### 2.2.7 å­—èŠ‚ä¸² (byte string)

é UTF-8 å­—ç¬¦ï¼Œä½¿ç”¨å­—èŠ‚ä¸² (byte string)

```rust
use std::str;

fn main() {
    // ä¸æ˜¯ &str
    let byte_string: &[u8; 20] = b"this is a bytestring";
    println!("A byte string: {:?}", byte_string);

    // å­—èŠ‚ä¸²å¯ä»¥ä½¿ç”¨å•å­—èŠ‚è½¬ä¹‰å­—ç¬¦
    let escaped = b"\x52\x75\x73\x74 as bytes";
    println!("Some escaped bytes: {:?}", escaped);

    // åŸå§‹å­—èŠ‚ä¸²ä½•åŸå§‹å­—ç¬¦ä¸²å†™æ³•ä¸€æ ·
    let raw_byte_string = br"\u{211D} is not escaped here";
    println!("Raw byte string: {:?}", raw_byte_string);

    // å­—èŠ‚ä¸²è½¬ &str å¯èƒ½å¤±è´¥
    if let Ok(my_str) = str::from_utf8(raw_byte_string) {
        println!("And the same as the text: '{}'", my_str);
    }

    let quotes = br#"You can also use "fancier" formmating, \
                              like with normal raw strings"#;
    println!("Quotes: {:?}", quotes);

    // å­—èŠ‚ä¸²ä¸ä½¿ç”¨ utf8 ç¼–ç , SHIFT-JIS ç¼–ç çš„ "ã‚ˆã†ã“ã"
    let shift_jis = b"\x82\xe6\x82\xa8\x82\xb1\x82";

    match str::from_utf8(shift_jis) {
        Ok(my_str) => println!("Conversion successfully: '{}'", my_str),
        Err(e) => println!("Conversion failed: {:?}", e),
    };
}
```



## 2.3 æ•°ç»„ (Array)

Rust ä¸­çš„ä¸¤ç§æ•°ç»„ï¼š

- arrayï¼šå›ºå®šé•¿åº¦ï¼Œé€Ÿåº¦å¿«ã€‚ç±»æ¯” `&str`ï¼Œ**å­˜å‚¨åœ¨æ ˆä¸Š**
- vectorï¼šå¯åŠ¨æ€å¢é•¿ï¼Œä½†æœ‰æ€§èƒ½æŸè€—ï¼Œä¹Ÿç§°åŠ¨æ€æ•°ç»„ï¼›ç±»æ¯” `String`ï¼Œ**å­˜å‚¨åœ¨å †ä¸Š**

æ•°ç»„çš„ä¸‰è¦ç´ ï¼š`[T; length]`

- é•¿åº¦å›ºå®š
- å…ƒç´ å¿…éœ€æœ‰ç›¸åŒçš„ç±»å‹
- ä¾æ¬¡çº¿æ€§æ’åˆ—

### 2.3.1 æ•°ç»„å£°æ˜

```rust
fn main() {
    // è‡ªåŠ¨æ¨å¯¼ç±»å‹
    let a = [1, 2, 3, 4, 5];
    println!("{:?}", a);

    // å£°æ˜ç±»å‹
    let b: [f64; 3] = [1.0, 2.2, 2.5];
    println!("{:?}", b);

    // æŸä¸ªå€¼é‡å¤å‡ºç° N æ¬¡
    let c = [6; 3];
    println!("{:?}", c);

    // è®¿é—®æ•°ç»„
    println!("{}", a[1]);
}
```



### 2.3.2 é‡å¤èµ‹å€¼

```rust
fn main() {
    let a = [String::from("just a test"); 8];
    println!("{:?}", a);
}
```

é”™è¯¯ï¼š`error[E0277]: the trait bound String: Copy is not satisfied`

åŸå› ï¼šç”±äºæ‰€æœ‰æƒåŸåˆ™ï¼Œ**åŸºæœ¬ç±»å‹çš„èµ‹å€¼æ”¯æŒç›´æ¥æ‹·è´ï¼Œä½†å¤æ‚ç±»å‹æ²¡æœ‰æ·±æ‹·è´ï¼Œåªèƒ½ä¸€ä¸ªä¸ªåˆ›å»º**ã€‚

```rust
fn main() {
    let a = [String::from("just a test"), String::from("just a test"), String::from("just a test")];
    println!("{:?}", a);
}
```

ä¼˜åŒ–ï¼šè°ƒç”¨`std::array::from_fn`

```rust
fn main() {
    let a: [String; 8] = std::array::from_fn(|_i| String::from("just a test"));
    println!("{:?}", a);
}
```



### 2.3.3 äºŒç»´æ•°ç»„

```rust
fn main() {
    let a1: [u8; 3] = [1, 2, 3];
    let a2 = [4, 5, 6];
    let a3: [u8; 3] = [0; 3];
    let a4 = [1; 3];

    // a2 & a4 çš„ç±»å‹ï¼Œè‡ªåŠ¨ç”±é»˜è®¤çš„ i32 è½¬ä¸º u8
    let two_dim_array = [a1, a2, a3, a4];
    println!("{:?}", two_dim_array);

    // éå†
    for a in two_dim_array {
        println!("{:?}", a);

        for n in a.iter() {
            println!("\t{:?} + 10 = {:?}", n, n+10)
        }

        let mut sum = 0;
        for i in 0..a.len() {
            sum += a[i];
        }
        println!("\tsum({:?}) = {}", a, sum)
    }
}
```



## 2.4 åˆ‡ç‰‡ (Slice)

åˆ‡ç‰‡æ˜¯å¯¹æ•°ç»„æˆ– vector çš„éƒ¨åˆ†è¿ç»­å¼•ç”¨ï¼Œå®ƒä½¿å¾—å¯ä»¥é«˜æ•ˆåœ°è®¿é—®åºåˆ—çš„å­éƒ¨åˆ†è€Œä¸éœ€è¦å¤åˆ¶ã€‚åˆ‡ç‰‡å¯¹äºå‡½æ•°å‚æ•°éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºå®ƒä»¬å…è®¸å‡½æ•°å¤„ç†æ•°ç»„æˆ–å‘é‡çš„ä»»ä½•éƒ¨åˆ†ã€‚



Sliceï¼š&[T]ï¼Œå¼•ç”¨ä¸€ä¸ªæ•°ç»„çš„éƒ¨åˆ†æ•°æ®å¹¶ä¸”ä¸éœ€è¦æ‹·è´

**åˆ‡ç‰‡æ˜¯å¯¹é›†åˆçš„éƒ¨åˆ†å¼•ç”¨**ï¼Œé€šè¿‡ `&s[START:END]`

```rust
fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];

    // let world = &s[6..11];

    // let len = s.len();
    // let world = &s[6..len];

    let world = &s[6..];

    println!("{}, {}", hello, world);
}
```

![img](https://cdn.jsdelivr.net/gh/elihe2011/bedgraph@master/rust/rust-slice.jpg)

### 2.4.1 UTF-8 å­—ç¬¦åˆ‡ç‰‡

```rust
fn main() {
    let s = "ä¸­å›½äºº";

    // UTF8 ä¸‰ä¸ªå­—èŠ‚ï¼Œbyte index 2 is not a char boundary
    //let a = &s[..2];

    // OK
    let a = &s[..3];

    println!("{}", a);
}
```



### 2.4.2 åˆ‡ç‰‡å€Ÿç”¨

åˆ‡ç‰‡å€Ÿç”¨é—®é¢˜ï¼š**å·²ç»æ‹¥æœ‰å¯å˜å€Ÿç”¨æ—¶ï¼Œå°±æ— æ³•å†æ‹¥æœ‰ä¸å¯å˜å€Ÿç”¨ã€‚**

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    // mutable borrow occurs here
    // pub fn clear(&mut self)
    s.clear();  // error

    // immutable borrow later used here
    println!("the first word is: {}", word);
}

fn first_word(s: &String) -> &str {
    &s[..1]
}
```



### 2.4.3 æ•°ç»„åˆ‡ç‰‡

æ•°ç»„åˆ‡ç‰‡ï¼Œå³å¯¹æ•°ç»„ä¸€éƒ¨åˆ†çš„å¼•ç”¨ã€‚å…¶ç‰¹ç‚¹å¦‚ä¸‹ï¼š

- åˆ‡ç‰‡å¤§å°å–å†³äºæŒ‡å®šçš„èµ·å§‹å’Œç»“æŸä½ç½®
- åˆ›å»ºåˆ‡ç‰‡çš„ä»£ä»·éå¸¸å°ï¼Œå®ƒåªæ˜¯é’ˆå¯¹åº•å±‚æ•°ç»„çš„ä¸€ä¸ªå¼•ç”¨
- **åˆ‡ç‰‡ç±»å‹`[T]`ä¸å›ºå®šçš„å¤§å°ï¼Œè€Œåˆ‡ç‰‡å¼•ç”¨ç±»å‹`&[T]`åˆ™å…·æœ‰å›ºå®šçš„å¤§å°**ã€‚Rustå¾ˆå¤šæ—¶å€™éœ€è¦å›ºå®šå¤§å°çš„æ•°æ®ç±»å‹ï¼Œå› æ­¤ `&[T]` åŠ `&str` æ›´æœ‰ç”¨

```rust
fn main() {
    let array = [1, 2, 3, 4, 5];
    let slice = &array[1..3];
    println!("{:?}", slice);

    assert_eq!(slice, &[2, 3]);
}
```



### 2.4.4 æ•°ç»„ä¸åˆ‡ç‰‡

**æ•°ç»„**ï¼š`[T; n]`ï¼Œé•¿åº¦åœ¨ç¼–è¯‘æ—¶å·²ç¡®å®šã€‚

**åˆ‡ç‰‡**ï¼š`[T]`ï¼Œè¿è¡Œæ—¶æ•°æ®ç»“æ„ï¼Œé•¿åº¦æ— æ³•åœ¨ç¼–è¯‘æ—¶å¾—çŸ¥ã€‚å®é™…å¼€å‘ä¸­ï¼Œä¸€èˆ¬é€šè¿‡å¼•ç”¨çš„æ–¹å¼ä½¿ç”¨`&[T]`ï¼Œå› ä¸ºå®ƒå›ºå®šå¤§å°



## 2.5 å…ƒç»„ (Tuple)

Tuple: (T1, T2, ...), å…·æœ‰å›ºå®šå¤§å°çš„æœ‰åºåˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ éƒ½æœ‰è‡ªå·±çš„ç±»å‹ï¼Œé€šè¿‡è§£æ„æˆ–è€…ç´¢å¼•æ¥è·å¾—æ¯ä¸ªå…ƒç´ çš„å€¼ã€‚**è¶…è¿‡12ä¸ªå…ƒç´ ä¸èƒ½è¢«ç›´æ¥println**

å…ƒç»„æ˜¯ç”±å¤šç§ç±»å‹ç»„åˆåˆ°ä¸€èµ·å½¢æˆçš„ã€‚å…ƒç»„çš„é•¿åº¦æ˜¯å›ºå®šçš„ï¼Œå…ƒç´ çš„é¡ºåºä¹Ÿæ˜¯å›ºå®šçš„ã€‚

```rust
fn main() {
    let tup: (i64, f64, i8) = (100, 3.14, 1);

    // è§£æ„
    let (x, y, z) = tup;
    println!("x={}, y={}, z={}", x, y, z);

    // ç´¢å¼•
    let a = tup.1;
    println!("{}", a);
}
```



## 2.6 æšä¸¾ (Enum)

æšä¸¾(enum æˆ– enumeration)å…è®¸ä½ é€šè¿‡åˆ—ä¸¾å¯èƒ½çš„æˆå‘˜æ¥å®šä¹‰ä¸€ä¸ª**æšä¸¾ç±»å‹**

```rust
enum PokerSuit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,
}
```

æšä¸¾é»˜è®¤æ˜¯ç§æœ‰çš„ï¼Œé€šè¿‡ pub å…³é”®å­—å˜ä¸ºå…¬æœ‰ï¼Œå…¶å†…éƒ¨å…ƒç´ ä¹ŸåŒæ—¶å˜ä¸ºå…¬æœ‰ã€‚(è¿™ç‚¹ä¸ç»“æ„ä½“ä¸åŒï¼Œç»“æ„ä½“å…ƒç´ å…¬æœ‰éœ€è¦åœ¨å±æ€§å‰æ·»åŠ pub)



### 2.6.1 æšä¸¾å€¼

```rust
// å®šä¹‰ä¸€ä¸ªæšä¸¾ï¼ŒåŒ…æ‹¬è‹¥å¹²ä¸ªå˜ä½“
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    // åˆ›å»ºä¸€ä¸ª Write æšä¸¾å˜ä½“çš„å®ä¾‹
    let msg = Message::Write(String::from("hello"));

    // åŒ¹é…æšä¸¾å˜ä½“
    match msg {
        Message::Write(text) => println!("{}", text),
        _ => println!("å…¶ä»–æ¶ˆæ¯ç±»å‹"),
    }
}
```

æšä¸¾çš„ `match` è¡¨è¾¾å¼ç¡®ä¿æ‰€æœ‰å¯èƒ½çš„æƒ…å†µéƒ½è¢«å¤„ç†



### 2.6.2 åŒä¸€åŒ–ç±»å‹

æœ‰ä¸€ä¸ª WEB æœåŠ¡ï¼Œéœ€è¦æ¥å—ç”¨æˆ·çš„é•¿è¿æ¥ï¼Œå‡è®¾è¿æ¥æœ‰ä¸¤ç§ï¼š`TcpStream` å’Œ `TlsStream`ï¼Œä½†å¸Œæœ›å¯¹è¿™ä¸¤ä¸ªè¿æ¥çš„å¤„ç†æµç¨‹ç›¸åŒï¼Œä¹Ÿå°±æ˜¯ç”¨åŒä¸€ä¸ªå‡½æ•°æ¥å¤„ç†è¿™ä¸¤ä¸ªè¿æ¥

```rust
fn new (stream: TcpStream) {
  let mut s = stream;
  if tls {
    s = negotiate_tls(stream)
  }

  // websocketæ˜¯ä¸€ä¸ªWebSocket<TcpStream>æˆ–è€…
  //   WebSocket<native_tls::TlsStream<TcpStream>>ç±»å‹
  websocket = WebSocket::from_raw_socket(
    stream, ......)
}

enum Websocket {
  Tcp(Websocket<TcpStream>),
  Tls(Websocket<native_tls::TlsStream<TcpStream>>),
}
```



### 2.6.3 Option

ç©ºå€¼ null çš„è¡¨è¾¾éå¸¸æœ‰æ„ä¹‰ï¼Œå› ä¸ºç©ºå€¼è¡¨ç¤ºå½“å‰æ—¶åˆ»å˜é‡çš„å€¼æ˜¯ç¼ºå¤±çš„ã€‚Rust æŠ›å¼ƒ `null`ï¼Œæ”¹ä¸ºä½¿ç”¨ `Option` æšä¸¾å˜é‡æ¥å¤„ç†ç©ºå€¼

`Option` æšä¸¾åŒ…å«ä¸¤ä¸ªæˆå‘˜ï¼š

- `Some(T) ` è¡¨ç¤ºå«æœ‰å€¼
- `None` è¡¨ç¤ºæ²¡æœ‰å€¼

`Option<T>` æšä¸¾è¢«åŒ…å«åœ¨ `prelude`ï¼ˆRust æ ‡å‡†åº“ï¼Œæå‰å°†æœ€å¸¸ç”¨çš„ç±»å‹ã€å‡½æ•°ç­‰å¼•å…¥å…¶ä¸­ï¼Œçœå¾—å†æ‰‹åŠ¨å¼•å…¥ï¼‰ä¹‹ä¸­ï¼Œä¸éœ€è¦å°†å…¶æ˜¾å¼å¼•å…¥ä½œç”¨åŸŸã€‚å®ƒçš„æˆå‘˜ `Some` å’Œ `None` ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œæ— éœ€ä½¿ç”¨ `Option::` å‰ç¼€å°±å¯ç›´æ¥ä½¿ç”¨ã€‚

```rust
let some_number = Some(5);
let some_string = Some("a string");

let absent_number: Option<i32> = None;
```

`match` è¡¨è¾¾å¼ï¼Œå¯ç”¨äºå¤„ç† `Option<T>` ï¼Œä¼šæ ¹æ®æšä¸¾çš„æˆå‘˜è¿è¡Œä¸åŒçš„ä»£ç ï¼Œè¿™äº›ä»£ç å¯ä»¥ä½¿ç”¨åŒ¹é…åˆ°çš„å€¼ä¸­çš„æ•°æ®ã€‚

```rust
fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    println!("{}", six.unwrap());
    println!("{}", none.is_none());
}

fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i+1),
    }
}
```



## 2.7 ç»“æ„ä½“ (Struct)

### 2.7.1 è‡ªå®šä¹‰ç»“æ„ä½“

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```



#### 2.7.1.1 åˆ›å»ºå®ä¾‹

æ³¨æ„ï¼š**æ¯ä¸ªå­—æ®µéƒ½å¿…é¡»åˆå§‹åŒ–**

```rust
fn main() {
    let user = User {
        username: String::from("eli"),
        email: String::from("eli@test.io"),
        active: false,
        sign_in_count: 0,
    };

    println!("{}", user.active);
}
```



#### 2.7.1.2 æ›´æ–°æ“ä½œ

`..` è¯­æ³•è¡¨æ˜å‡¡æ˜¯æ²¡æœ‰æ˜¾å¼å£°æ˜çš„å­—æ®µï¼Œä» `user` ä¸­è‡ªåŠ¨è·å–

```rust
fn main() {
    ...

    let user2 = User {
        email: String::from("lollipop@qq.com"),
        ..user   // å…¶ä»–æœªå£°æ˜å­—æ®µå–è‡ªuser
    };
    println!("{:?}", user2);
}
```



#### 2.7.1.3 å†…å­˜æ’åº

```rust
struct File {
    name: String,
    data: Vec<u8>,
}

fn main() {
    let f = File {
        name: String::from("abc.txt"),
        data: Vec::new(),
    };

    let name = &f.name;
    let len = &f.data.len();

    println!("{:?}", f);
    println!("name: {}, length: {}", name, len);
}
```

![img](https://cdn.jsdelivr.net/gh/elihe2011/bedgraph@master/rust/rust-struct-mem.png)



### 2.7.2 å…ƒç»„ç»“æ„ä½“(Tuple-Struct)

å…ƒç»„ç»“æ„ä½“ï¼š**ç»“æ„ä½“æœ‰åç§°ï¼Œä½†å­—æ®µæ²¡æœ‰åç§°**ï¼Œå½“å…ƒç»„ç»“æ„ä½“åªæœ‰ä¸€ä¸ªå­—æ®µæ—¶ï¼Œæˆä¸ºæ–°ç±»å‹(newtype);

```rust
struct Point(i32, i32);
struct Color(u8, u8, u8);

fn main() {
    let origin = Point(0, 0);
    let black = Color(0, 0, 0);
    ...
}

/**-----------------------**/
// a tuple struct
struct Pair(i32, f32);
let pair = Pair(1, 0.1);
let Pair(integer, decimal) = pair;

// A tuple struct's constructors can be used as functions
struct Digit(i32);
let v = vec![0, 1, 2];
let d: Vec<Digit> = v.into_iter().map(Digit).collect();

// newtype: a tuple struct with only one element
struct Inches(i32);
let length = Inches(10);
let Inches(integer_length) = length;
```



### 2.7.3 å•å…ƒç»“æ„ä½“(Unit-like Struct)

æ²¡æœ‰ä»»ä½•å­—æ®µå’Œå±æ€§ã€‚

å¦‚æœå®šä¹‰ä¸€ä¸ªç±»å‹ï¼Œä½†æ˜¯ä¸å…³å¿ƒè¯¥ç±»å‹çš„å†…å®¹, åªå…³å¿ƒå®ƒçš„è¡Œä¸ºæ—¶ï¼Œå°±å¯ä»¥ä½¿ç”¨ `å•å…ƒç»“æ„ä½“`

```rust
struct Null;
let empty = Null;

impl SomeTrait for Null {

}
```



### 2.7.4 æ“ä½œç»“æ„ä½“

#### 2.7.4.1 æ•°æ®æ‰€æœ‰æƒ

```rust
struct User {
    username: &str,
    email: &str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user = User {
        email: "lolly@test.io",
        username: "ly",
        active: true,
        sign_in_count: 1,
    };

    println!("{:?}", user);
}
```

åœ¨ç»“æ„ä½“ä¸­ï¼Œä½¿ç”¨åŸºäºå¼•ç”¨çš„ `&str` å­—ç¬¦ä¸²åˆ‡ç‰‡ç±»å‹ï¼Œå³`User` ç»“æ„ä½“ä»å…¶å®ƒå¯¹è±¡å€Ÿç”¨æ•°æ®ã€‚ä½†æ­¤å¤„å¿…é¡»ç”¨åˆ°ç”Ÿå‘½å‘¨æœŸ(lifetimes)ï¼Œå¦åˆ™å°†å‡ºç° `error[E0106]: missing lifetime specifier`ï¼Œä¿®æ­£ï¼š

```rust
struct User<'a> {
    username: &'a str,
    email: &'a str,
    sign_in_count: u64,
    active: bool,
}
```

æ³¨æ„ï¼š**ç»“æ„ä½“ä¸­æœ‰å¼•ç”¨å­—æ®µæ—¶ï¼Œéœ€è¦å¯¹ç”Ÿå‘½å‘¨æœŸå‚æ•°è¿›è¡Œå£°æ˜ `<'a>`**ã€‚è¯¥ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨è¯´æ˜ï¼Œç»“æ„ä½“ `User` æ‰€å¼•ç”¨çš„å­—ç¬¦ä¸² `str` å¿…é¡»æ¯”è¯¥ç»“æ„ä½“æ´»å¾—æ›´ä¹…ã€‚



#### 2.7.4.2 æ‰“å°ç»“æ„ä½“

```rust
#[derive(Debug)]     // æ‰“å°
#[derive(Default)]   // é»˜è®¤å€¼
struct Point3D {
    x: i32,
    y: i32,
    z: i32
}

fn main() {
    let origin = Point3D::default();
    println!("{:?}", &origin);
    
    let point = Point3D{y: 1, ..origin};
    let Point3D{x: x0, y: y0, ..} = point;
    
    println!("x={}, y={}", x0, y0);
}
```



#### 2.7.4.3 å­—æ®µå¯å˜æ€§

Rust ä¸æ”¯æŒåŸŸå¯å˜æ€§(field mutability):

```rust
struct Point {
    mut x: i32,  // ä¸æ”¯æŒ
    y: i32,
}
```



å¯å˜æ€§æ˜¯ç»‘å®šçš„ä¸€ä¸ªå±æ€§ï¼Œè€Œä¸æ˜¯ç»“æ„ä½“è‡ªèº«çš„ï¼š

```rust
use std::cell::Cell;

#[derive(Debug)]
struct Point2D {
    x: i32,
    y: Cell<i32>
}

fn main() {
    let mut point = Point2D{x: 1, y: Cell::new(5)};
    println!("{:?}", &point);
    
    point.y.set(8);
    println!("{:?}", point);
}
```

