# 1. åŸºæœ¬ç±»å‹

- æœ‰ç¬¦å·æ•´æ•°ï¼ˆsigned integersï¼‰ï¼š`i8`ã€`i16`ã€`i32`ã€`i64`ã€`i128` å’Œ `isize`ï¼ˆæŒ‡é’ˆå®½åº¦ï¼‰
- æ— ç¬¦å·æ•´æ•°ï¼ˆunsigned integersï¼‰ï¼š `u8`ã€`u16`ã€`u32`ã€`u64`ã€`u128` å’Œ `usize`ï¼ˆæŒ‡é’ˆå®½åº¦ï¼‰
- æµ®ç‚¹æ•°ï¼ˆfloating pointï¼‰ï¼š `f32`ã€`f64`
- å­—ç¬¦ï¼ˆcharï¼‰ï¼šå•ä¸ª Unicode å­—ç¬¦ï¼Œå¦‚ `'a'`ï¼Œ`'Î±'` å’Œ `'âˆ'`ï¼ˆæ¯ä¸ªéƒ½æ˜¯ 4 å­—èŠ‚ï¼‰
- å¸ƒå°”å‹ï¼ˆboolï¼‰ï¼š `true` æˆ– `false`
- å•å…ƒç±»å‹ï¼ˆunit typeï¼‰ï¼šå…¶å”¯ä¸€å€¼å°±æ˜¯ `()` è¿™ä¸ªç©ºå…ƒç»„



## 1.1 æ•°å€¼ç±»å‹

### 1.1.1 æ•´æ•°

| Length  | Signed  | Unsigned |
| ------- | ------- | -------- |
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| arch    | `isize` | `usize`  |

è¡¨ç¤ºæ³•ï¼š

| Number literals  | Example       |
| ---------------- | ------------- |
| Decimal          | `98_222`      |
| Hex              | `0xff`        |
| Octal            | `0o77`        |
| Binary           | `0b1111_0000` |
| Byte (`u8` only) | `b'A'`        |

ç¤ºä¾‹ï¼š

```rust
let x = 5;
let y: u32 = 123_456;
let z: f64 = 1.23e+2;
let zero = z.min(123.4);
let bin = 0b1111_0000;
let oct = 0o7320_1546;
let hex = 0xf23a_b049;
```

**ç¼–è¯‘æ—¶æ•´å‹æº¢å‡º**ï¼š

- debug æ¨¡å¼ï¼Œæ£€æŸ¥æ•´å‹æº¢å‡ºï¼Œè‹¥å­˜åœ¨é—®é¢˜ï¼Œåˆ™ç›´æ¥ *panic*

- release æ¨¡å¼ï¼Œ**ä¸ä¼š**æ£€æµ‹æº¢å‡ºã€‚å½“æ•´å‹æº¢å‡ºæ—¶ï¼Œä¼šæŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºï¼ˆ*twoâ€™s complement wrapping*ï¼‰çš„è§„åˆ™å¤„ç†ã€‚

æ˜¾å¼å¤„ç†å¯èƒ½çš„æº¢å‡ºï¼Œä½¿ç”¨æ ‡å‡†åº“é’ˆå¯¹åŸå§‹æ•°å­—ç±»å‹æä¾›çš„æ–¹æ³•ï¼š

- `wrapping_*`ï¼šæ‰€æœ‰æ¨¡å¼ä¸‹ï¼ŒæŒ‰ç…§è¡¥ç æº¢å‡ºè§„åˆ™å¤„ç†ï¼Œä¾‹å¦‚ `wrapping_add`
- `checked_*`ï¼šå‘ç”Ÿæº¢å‡ºï¼Œè¿”å›None
- `overflowing_*`ï¼šè¿”å›ç»“æœå€¼åŠæ˜¯å¦æº¢å‡ºboolå€¼
- `saturating_*`ï¼šä½¿å€¼è¾¾åˆ°æœ€å°å€¼æˆ–æœ€å¤§å€¼

```rust
fn main() {
    let a: u8 = 255;
    let b = a.wrapping_add(20);
    println!("{}", b);
}
```

è¡¥å……ï¼š

- æ­£æ•°ï¼šåŸç ã€åç ã€è¡¥ç  ä¸å˜
- è´Ÿæ•°ï¼š
  - åŸç ï¼šç¬¦å·ä½1 | ç»å¯¹å€¼åŸç 
  - åç ï¼šç¬¦å·ä½1 | åŸç å–å
  - è¡¥ç ï¼šç¬¦å·ä½1 | åç +1     ç¬¦å·ä½å‚ä¸è¿ç®—



### 1.1.2 æµ®ç‚¹æ•°

Rust æä¾› IEEE çš„ä¸¤ç§æµ®ç‚¹æ•°ï¼š

- `f32` ï¼šå•ç²¾åº¦

- `f64`ï¼š åŒç²¾åº¦ï¼Œé»˜è®¤



æœ‰æ•ˆçš„æ ¼å¼ï¼šæ•´æ•°éƒ¨åˆ†å¿…é€‰ï¼Œå°æ•°éƒ¨åˆ†ã€æŒ‡æ•°ã€æˆ–ç±»å‹åç¼€æ˜¯å¯é€‰çš„ï¼Œä½†è‡³å°‘éœ€è¦ä¸€ä¸ª

```rust
let x = 5.    // ok
```



**æµ®ç‚¹æ•°é™·é˜±**ï¼š

- æµ®ç‚¹æ•°æ˜¯ä¸€ç§è¿‘ä¼¼è¡¨è¾¾ï¼Œå—é™äºæµ®ç‚¹æ•°ç²¾åº¦
- æµ®åŠ¨æ•°ä½¿ç”¨ `>`ï¼Œ`>=` ç­‰è¿›è¡Œæ¯”è¾ƒï¼Œåœ¨æŸäº›åœºæ™¯ä¸‹ä¸æ­£ç¡®ã€‚æ¨èä½¿ç”¨ `std::cmp::PartialEq` è¿›è¡Œæµ®ç‚¹æ•°æ¯”è¾ƒ

HashMap Key çš„ç±»å‹å¿…é¡»å®ç° `std::cmp::Eq` ç‰¹æ€§ã€‚ä½† f32 å’Œ f64 å‡æœªå®ç°è¯¥æ¥å£ï¼Œæ‰€ä»¥æ— æ³•ä½¿ç”¨æµ®ç‚¹æ•°ä½œä¸º HashMap çš„Keyã€‚

```rust
fn main() {
    assert!(0.1 + 0.2 == 0.3) // panic
}
```



f32 å’Œ f64 ç±»å‹å…³è”çš„ IEEE ç‰¹æ®Šå¸¸é‡å€¼ï¼š

- **INFINITY**
- **NEG_INFINITY**
- **MIN**
- **MAX**

- **NaN**ï¼šæ•°å­¦ä¸Šæœªå®šä¹‰çš„ç»“æœ(not a number)

```rust
fn main() {
    // è´Ÿæ•°å¹³æ–¹æ ¹
    let x = (-42.1_f32).sqrt();
    println!("{}", x);          // NaN
    println!("{}", x.is_nan()); // true
}
```



### 1.1.3 åºåˆ—(Range)

åºåˆ—åªå…è®¸ç”¨äºæ•°å­—æˆ–å­—ç¬¦ç±»å‹ï¼Œå®ƒä»¬æ˜¯è¿ç»­ï¼Œç¼–è¯‘å™¨åœ¨ç¼–è¯‘æœŸå¯ä»¥æ£€æŸ¥è¯¥åºåˆ—æ˜¯å¦ä¸ºç©ºï¼Œ**å­—ç¬¦å’Œæ•°å­—å€¼æ˜¯ Rust ä¸­ä»…æœ‰çš„å¯ä»¥ç”¨äºåˆ¤æ–­æ˜¯å¦ä¸ºç©ºçš„ç±»å‹**

```rust
fn main() {
    // [1, 5)
    for i in 1..5 {
        print!("{} ", i)
    }
    println!();

    // ['a', 'z']
    for i in 'a'..='z' {
        print!("{} ", i)
    }
}
```



### 1.1.4 å¤æ•°

æœªåŒ…å«åœ¨æ ‡å‡†åº“ä¸­ï¼Œéœ€è¦å¼•å…¥ç¤¾åŒºåº“ `num = "0.4.0"`

```rust
use num::complex::Complex;

fn main() {
    let a = Complex {re: 2.1, im: -1.2};
    let b = Complex::new(1.5, 0.7);

    let result = a + b;
    println!("{} + {}i", result.re, result.im);
}
```



## 1.2 å­—ç¬¦ (char)

Rust å­—ç¬¦åŒ…å« `ASCII`ã€`Unicode` ï¼ˆå•ä¸ªä¸­æ—¥éŸ©æ–‡å­—ã€emojiç­‰ï¼ŒèŒƒå›´ä» `U+0000 ~ U+D7FF` å’Œ `U+E000 ~ U+10FFFF`ï¼‰

```rust
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let g = 'ä¸­';
    let e = 'ğŸ˜»';

    println!("{}: {}, {}", c, c.len_utf8(), std::mem::size_of_val(&c)); // 1, 4
    println!("{}: {}, {}", z, z.len_utf8(), std::mem::size_of_val(&z)); // 3, 4
    println!("{}: {}, {}", g, g.len_utf8(), std::mem::size_of_val(&g)); // 3, 4
    println!("{}: {}, {}", e, e.len_utf8(), std::mem::size_of_val(&e)); // 4, 4
}
```



Rust çš„å­—ç¬¦ç±»å‹ char ä»£è¡¨ä¸€ä¸ªå•ç‹¬çš„ Unicode å­—ç¬¦ï¼Œæ˜¯ä¸€ä¸ª 32 ä½çš„å€¼ã€‚å­—ç¬¦å­—é¢é‡è¢«å•å¼•å·åŒ…å›´ï¼š`'*'` å’Œ `'\x2A'`

Rust ä½¿ç”¨ char è¡¨ç¤ºå•ä¸ªå­—ç¬¦ï¼Œä½†æ˜¯ä¹Ÿ UTF-8 ç¼–ç å­—ç¬¦ä¸²å’Œæ–‡æœ¬æµã€‚å› æ­¤ï¼Œ**String è¡¨ç¤ºçš„æ–‡æœ¬æ—¶ä¸€ä¸ª UTF-8 å­—èŠ‚åºåˆ—ï¼Œè€Œä¸æ˜¯å­—ç¬¦çš„æ•°ç»„**ã€‚



## 1.3 å¸ƒå°” (bool)

å€¼ä¸º `true` å’Œ `false`ï¼Œå†…å­˜å ç”¨ `1` ä¸ªå­—èŠ‚



## 1.4 å•å…ƒç±»å‹

å•å…ƒç±»å‹`()`ï¼š

- main å‡½æ•°è¿”å›å€¼
- `println!()` å®çš„è¿”å›å€¼

`()` ä¸å ç”¨å†…å­˜ï¼Œå¯ä½œä¸º HashMap çš„å€¼ï¼Œç”¨æ³•å’Œ Go è¯­è¨€çš„ `struct{}` ç±»ä¼¼ï¼Œåªç”¨æ¥å ä½

**å‘æ•£å‡½æ•° ( diverge function )**ï¼šRust ä¸­æ²¡æœ‰è¿”å›å€¼çš„å‡½æ•°ï¼Œå…¶ç‰¹ç‚¹æ˜¯æ— æ³•æ”¶æ•›



# 2. å¤åˆç±»å‹

## 2.1 å…ƒç»„  (Tuple)

å…ƒç»„æ˜¯ä¸€ç§å¯ä»¥ç»„åˆä¸åŒç±»å‹å€¼å¾—æ•°æ®ç»“æ„ï¼Œé•¿åº¦å›ºå®šã€‚å¯ä½œä¸ºå‡½æ•°è¿”å›å€¼æ¥è¿”å›å¤šä¸ªå€¼ï¼›

å­—é¢é‡ `("lonely hearts",)` æ˜¯ä¸€ä¸ªåŒ…å«å•ä¸ªå­—ç¬¦ä¸²çš„å…ƒç»„ï¼Œç±»å‹æ˜¯ `(&str,)`ã€‚æœ€åçš„é€—å·æ˜¯å¿…é¡»çš„ï¼Œä¸ºäº†å’Œå•çº¯åœ°ç”¨æ‹¬å·æŠŠè¡¨è¾¾å¼æ‹¬èµ·æ¥ç›¸åŒºåˆ†ã€‚

**è¶…è¿‡12ä¸ªå…ƒç´ ä¸èƒ½è¢«ç›´æ¥println**

```rust
fn main() {
    let tup: (i64, f64, i8) = (100, 3.14, 1);

    // è§£æ„
    let (x, y, z) = tup;
    println!("x={}, y={}, z={}", x, y, z);

    // ç´¢å¼•
    let a = tup.1;
    println!("{}", a);
}
```



## 2.2 æ•°ç»„ (Array)

Rust ä¸­çš„ä¸¤ç§æ•°ç»„ï¼š

- arrayï¼šå›ºå®šé•¿åº¦ï¼Œé€Ÿåº¦å¿«ã€‚ç±»æ¯” `&str`ï¼Œ**å­˜å‚¨åœ¨æ ˆä¸Š**
- vectorï¼šå¯åŠ¨æ€å¢é•¿ï¼Œä½†æœ‰æ€§èƒ½æŸè€—ï¼Œä¹Ÿç§°åŠ¨æ€æ•°ç»„ï¼›ç±»æ¯” `String`ï¼Œ**å­˜å‚¨åœ¨å †ä¸Š**

**ç±»å‹ `[T; N]` è¡¨ç¤ºä¸€ä¸ªæœ‰ N ä¸ª T ç±»å‹å…ƒç´ çš„æ•°ç»„ï¼Œæ¯ä¸ªæ•°ç»„çš„é•¿åº¦å¿…é¡»åœ¨ç¼–è¯‘æœŸå·²çŸ¥ï¼Œä¸èƒ½æ·»åŠ æ–°å…ƒç´ æˆ–ç¼©å‡å…ƒç´ ã€‚**



### 2.2.1 æ•°ç»„å£°æ˜

```rust
fn main() {
    // è‡ªåŠ¨æ¨å¯¼ç±»å‹
    let a = [1, 2, 3, 4, 5];
    println!("{:?}", a);

    // å£°æ˜ç±»å‹
    let b: [f64; 3] = [1.0, 2.2, 2.5];
    println!("{:?}", b);

    // æŸä¸ªå€¼é‡å¤å‡ºç° N æ¬¡
    let c = [6; 3];
    println!("{:?}", c);

    // è®¿é—®æ•°ç»„
    println!("{}", a[1]);
}
```



### 2.2.2 é‡å¤èµ‹å€¼

```rust
fn main() {
    let a = [String::from("just a test"); 8];
    println!("{:?}", a);
}
```

é”™è¯¯ï¼š`error[E0277]: the trait bound String: Copy is not satisfied`

åŸå› ï¼šç”±äºæ‰€æœ‰æƒåŸåˆ™ï¼Œ**åŸºæœ¬ç±»å‹çš„èµ‹å€¼æ”¯æŒç›´æ¥æ‹·è´ï¼Œä½†å¤æ‚ç±»å‹æ²¡æœ‰æ·±æ‹·è´ï¼Œåªèƒ½ä¸€ä¸ªä¸ªåˆ›å»º**ã€‚

```rust
fn main() {
    let a = [String::from("just a test"), String::from("just a test"), String::from("just a test")];
    println!("{:?}", a);
}
```

ä¼˜åŒ–ï¼šè°ƒç”¨`std::array::from_fn`

```rust
fn main() {
    let a: [String; 8] = std::array::from_fn(|_i| String::from("just a test"));
    println!("{:?}", a);
}
```



### 2.2.3 äºŒç»´æ•°ç»„

```rust
fn main() {
    let a1: [u8; 3] = [1, 2, 3];
    let a2 = [4, 5, 6];
    let a3: [u8; 3] = [0; 3];
    let a4 = [1; 3];

    // a2 & a4 çš„ç±»å‹ï¼Œè‡ªåŠ¨ç”±é»˜è®¤çš„ i32 è½¬ä¸º u8
    let two_dim_array = [a1, a2, a3, a4];
    println!("{:?}", two_dim_array);

    // éå†
    for i in two_dim_array {
        println!("{:?}", i);

        for j in i.iter() {
            println!("\t{:?} + 10 = {:?}", j, j+10)
        }

        let mut sum = 0;
        for j in 0..i.len() {
            sum += i[j];
        }
        println!("\tsum({:?}) = {}", i, sum)
    }
}
```



## 2.3 åˆ‡ç‰‡ (Slice)

**åˆ‡ç‰‡ [T]**ï¼Œæ²¡æœ‰é•¿åº¦ã€‚æ˜¯å¯¹æ•°ç»„æˆ– vector çš„éƒ¨åˆ†è¿ç»­å¼•ç”¨ï¼Œå®ƒä½¿å¾—å¯ä»¥é«˜æ•ˆåœ°è®¿é—®åºåˆ—çš„å­éƒ¨åˆ†è€Œä¸éœ€è¦å¤åˆ¶ã€‚åˆ‡ç‰‡å¯¹äºå‡½æ•°å‚æ•°éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºå®ƒä»¬å…è®¸å‡½æ•°å¤„ç†æ•°ç»„æˆ–å‘é‡çš„ä»»ä½•éƒ¨åˆ†ã€‚

å› ä¸ºåˆ‡ç‰‡å¯ä»¥æ˜¯ä»»æ„é•¿åº¦ï¼Œå› æ­¤åˆ‡ç‰‡ä¸èƒ½ç›´æ¥å­˜å‚¨åœ¨å˜é‡ä¸­æˆ–è€…ä½œä¸ºå‚æ•°ä¼ é€’ã€‚åˆ‡ç‰‡å¿…é¡»é€šè¿‡å¼•ç”¨ä¼ é€’ã€‚



**åˆ‡ç‰‡çš„å¼•ç”¨æ˜¯èƒ–æŒ‡é’ˆ**ï¼šåŒ…å«æŒ‡å‘åˆ‡ç‰‡ä¸­ç¬¬ä¸€å…ƒç´ çš„æŒ‡é’ˆå’Œåˆ‡ç‰‡ä¸­å…ƒç´ æ•°æ®çš„åŒå­—å€¼ã€‚

**åˆ‡ç‰‡æ˜¯å¯¹é›†åˆçš„éƒ¨åˆ†å¼•ç”¨**ï¼Œé€šè¿‡ `&s[START:END]`

```rust
fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];

    // let world = &s[6..11];

    // let len = s.len();
    // let world = &s[6..len];

    let world = &s[6..];

    println!("{}, {}", hello, world);
}
```

![img](https://cdn.jsdelivr.net/gh/elihe2011/bedgraph@master/rust/rust-slice.jpg)

### 2.3.1 UTF-8 å­—ç¬¦åˆ‡ç‰‡

```rust
fn main() {
    let s = "ä¸­å›½äºº";

    // UTF8 ä¸‰ä¸ªå­—èŠ‚ï¼Œbyte index 2 is not a char boundary
    //let a = &s[..2];

    // OK
    let a = &s[..3];

    println!("{}", a);
}
```



### 2.3.2 åˆ‡ç‰‡å€Ÿç”¨

åˆ‡ç‰‡å€Ÿç”¨é—®é¢˜ï¼š**å·²ç»æ‹¥æœ‰å¯å˜å€Ÿç”¨æ—¶ï¼Œå°±æ— æ³•å†æ‹¥æœ‰ä¸å¯å˜å€Ÿç”¨ã€‚**

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    // mutable borrow occurs here
    // pub fn clear(&mut self)
    s.clear();  // error

    // immutable borrow later used here
    println!("the first word is: {}", word);
}

fn first_word(s: &String) -> &str {
    &s[..1]
}
```



### 2.3.3 æ•°ç»„åˆ‡ç‰‡

æ•°ç»„åˆ‡ç‰‡ï¼Œå³å¯¹æ•°ç»„ä¸€éƒ¨åˆ†çš„å¼•ç”¨ã€‚å…¶ç‰¹ç‚¹å¦‚ä¸‹ï¼š

- åˆ‡ç‰‡å¤§å°å–å†³äºæŒ‡å®šçš„èµ·å§‹å’Œç»“æŸä½ç½®
- åˆ›å»ºåˆ‡ç‰‡çš„ä»£ä»·éå¸¸å°ï¼Œå®ƒåªæ˜¯é’ˆå¯¹åº•å±‚æ•°ç»„çš„ä¸€ä¸ªå¼•ç”¨
- **åˆ‡ç‰‡ç±»å‹`[T]`ä¸å›ºå®šçš„å¤§å°ï¼Œè€Œåˆ‡ç‰‡å¼•ç”¨ç±»å‹`&[T]`åˆ™å…·æœ‰å›ºå®šçš„å¤§å°**ã€‚Rustå¾ˆå¤šæ—¶å€™éœ€è¦å›ºå®šå¤§å°çš„æ•°æ®ç±»å‹ï¼Œå› æ­¤ `&[T]` åŠ `&str` æ›´æœ‰ç”¨

```rust
fn main() {
    let array = [1, 2, 3, 4, 5];
    let slice = &array[1..3];
    println!("{:?}", slice);

    assert_eq!(slice, &[2, 3]);
}
```



### 2.3.4 æ•°ç»„ä¸åˆ‡ç‰‡

**æ•°ç»„**ï¼š`[T; n]`ï¼Œé•¿åº¦åœ¨ç¼–è¯‘æ—¶å·²ç¡®å®šã€‚

**åˆ‡ç‰‡**ï¼š`[T]`ï¼Œè¿è¡Œæ—¶æ•°æ®ç»“æ„ï¼Œé•¿åº¦æ— æ³•åœ¨ç¼–è¯‘æ—¶å¾—çŸ¥ã€‚å®é™…å¼€å‘ä¸­ï¼Œä¸€èˆ¬é€šè¿‡å¼•ç”¨çš„æ–¹å¼ä½¿ç”¨`&[T]`ï¼Œå› ä¸ºå®ƒå›ºå®šå¤§å°



## 2.4 å­—ç¬¦ä¸²

**Rust å­—ç¬¦æ˜¯ Unicode ç±»å‹ï¼Œæ¯ä¸ªå­—ç¬¦å æ® 4 ä¸ªå­—èŠ‚å†…å­˜ç©ºé—´ï¼›å­—ç¬¦ä¸²æ˜¯ UTF-8 ç¼–ç ï¼Œå…¶ä¸­æ‰€å çš„å­—èŠ‚æ•°æ•°å˜åŒ–çš„(1-4)**ï¼Œè¿™æ ·æœ‰åŠ©äºå¤§å¹…é™ä½å­—ç¬¦ä¸²æ‰€å çš„å†…å­˜ç©ºé—´ã€‚

ä¸¤ç±»å­—ç¬¦ä¸²ï¼š

- `&str`ï¼šç¡¬ç¼–ç å­—ç¬¦ä¸²ï¼Œå­˜å‚¨åœ¨ç¨‹åºç‰‡æ®µä¸­ï¼Œé™æ€åˆ†é…ï¼Œå›ºå®šå¤§å°ï¼Œä¸”ä¸å¯å˜ï¼Œ**å­—ç¬¦å­—é¢é‡æ˜¯åˆ‡ç‰‡**ã€‚æŒ‡å‘ä¸€ä¸ªæœ‰æ•ˆ UTF-8 åºåˆ—çš„åˆ‡ç‰‡ `&[u8]`
- Stringï¼šå¯å˜å­—ç¬¦ä¸²ï¼Œå­˜å‚¨åœ¨**å †å†…å­˜ä¸Š**ï¼Œå¯åŠ¨æ€æ”¹å˜å¤§å°å’Œå€¼ï¼Œä¸”å…·æœ‰æ‰€æœ‰æƒ

```rust
fn main() {
    // å †åªè¯»å†…å­˜ä¸­åˆ†é…çš„å­—ç¬¦ä¸²çš„å¼•ç”¨
    let pangram: &'static str = "the quick brown fox jumps over the lazy dog";
    println!("Pangram: {}", pangram);

    // reverse
    println!("Words in reverse");
    for word in pangram.split_whitespace().rev() {
        println!("> {}", word);
    }

    // å¤åˆ¶å­—ç¬¦åˆ° vectorï¼Œæ’åºå¹¶å»é‡
    let mut chars: Vec<char> = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // å¯å˜å­—ç¬¦ä¸²
    let mut string = String::new();
    for c in chars {
        string.push(c);
        string.push_str(", ");
    }
    println!("String: {}", string);

    // åˆ é™¤å­—ç¬¦
    let chars_to_trim: &[char] = &[' ', ','];
    let trimmed_str: &str = string.trim_matches(chars_to_trim);
    println!("Used characters: {}", trimmed_str);
}
```



**æ³¨æ„ï¼šä¸æ”¯æŒå­—ç¬¦ä¸²ç´¢å¼•**

```rust
let s = String::from("hello");
let h = s[0];    // cannot be indexed by `{integer}`
let h = s[0..1]  // ok
```



### 2.4.1 `&str` ä¸ `String` äº’è½¬

```rust
fn main() {
    // &str -> String
    let s1 = String::from("hello");
    let s2= "world".to_string();
    println!("{}, {}", s1, s2);

    // String -> &str
    let s = String::from("hello world");
    let a1 = &s;  // &String -> &str, deref éšå¼å¼ºåˆ¶è½¬æ¢
    let a2 = &s[..];
    let a3 = s.as_str();

    println!("{}, {}, {}", a1, a2, a3);
}
```

**String ç±»å‹**ï¼š

- æŒ‡é’ˆã€é•¿åº¦ã€å®¹é‡å­˜å‚¨åœ¨æ ˆä¸Š
- å®é™…çš„å­—ç¬¦ä¸²å€¼å­˜å‚¨åœ¨å †ä¸Š



### 2.4.2 å­—ç¬¦ä¸²æ“ä½œ

```rust
fn push() {
    let mut s = String::from("hello");
    s.push_str(" rust");
    s.push_str("!");
    println!("{}", s);
}

fn insert() {
    let mut s = String::from("hello rust!");
    s.insert(5, ',');
    s.insert_str(6, " I like");
    println!("{}", s);
}

fn replace() {
    let s1 = String::from("I like rust. Learning rust is my favorite!");
    let r1 = s1.replace("rust", "RUST");
    println!("{}", r1);

    let r2 = s1.replacen("rust", "RUST", 1);
    println!("{}", r2);

    let mut s2 = String::from("I like rust");
    s2.replace_range(7..8, "R");
    println!("{}", s2);
}

fn delete() {
    let mut s = String::from("Rust test ä¸­æ–‡");
    
    // åˆ é™¤æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œè¿”å› Some(char)
    let c1 = s.pop();
    println!("c1: {:?}", c1);  // Some('æ–‡')
    println!("s: {}", s);      // Rust test ä¸­
    
    // åˆ é™¤æŒ‡å®šä½ç½®å­—ç¬¦ï¼Œè¿”å›å­—ç¬¦
    let c2 = s.remove(2);
    println!("c2: {}", c2);  // s
    println!("s: {}", s);    // Rut test ä¸­
    
    // ä»æŒ‡å®šä½ç½®æˆªæ–­å­—ç¬¦ä¸²ï¼Œè¿”å› ()
    s.truncate(6);
    println!("s: {}", s);    // Rut te
    
    // æ¸…ç©ºå­—ç¬¦ä¸²ï¼Œè¿”å› ()
    s.clear();
    println!("s: {}", s);   // ""
}

fn concatenate() {
    // +, +=
    let s1 = String::from("hello");
    let s2 = String::from(" rust");

    // let s = s1 + &s2;  // è‡ªåŠ¨ç”± &String è½¬ä¸º &str
    let s = s1.add(&s2);  // 1.79 å·²ä¸æ”¯æŒ
    println!("{}", s);

    // format!()
    let s3 = String::from("hello");
    let s4 = "rust";
    let s = format!("{} {}", s3, s4);
    println!("{}", s);
}
```



### 2.4.3 å­—ç¬¦ä¸²è½¬ä¹‰

```rust
fn main() {
    // \x  åå…­è¿›åˆ¶
    let byte_escape = "I'm writing \x52\x75\x73\x74!";
    println!("What are you doing\x3F (\\x3F means ?) {}", byte_escape);

    // \u Unicodeå­—ç¬¦
    let unicode_codepoint = "\u{211D}";
    let character_name = "\"DOUBLE-STRUCT CAPITAL R\"";
    println!("Unicode character {} (U+211D) is called {}", unicode_codepoint, character_name);

    // \ å¿½ç•¥æ¢è¡Œ
    let long_string = "String literals
                              can span multiple lines.
                              The linebreak and indentation here ->\
                              <- can be escaped too!";
    println!("{}", long_string);
}
```



### 2.4.4 UTF-8 å­—ç¬¦ä¸²

```rust
use utf8_slice;

fn main() {
    let s = "ä¸­å›½äºº";

    // å­—ç¬¦
    for c in s.chars() {
        println!("{}", c);
    }

    // å­—èŠ‚
    for b in s.bytes() {
        println!("{}", b);
    }

    // å­å­—ç¬¦ä¸²
    let ss = utf8_slice::slice(s, 0, 2);
    println!("{}", ss);
}
```



### 2.4.5 ç±»å‹è½¬æ¢

```rust
let f = 24.4321;
let s = format!("{:.2}", f);
let f2: f64 = s.parse().unwrap();
```



### 2.4.6 åŸå§‹å­—ç¬¦ä¸² (raw string)

```rust
fn main() {
    let raw_str = r"Escapes don't work here: \x3F \u{211D}";
    println!("{}", raw_str);

    // åŸå§‹å­—ç¬¦ä¸²ä¸­æœ‰å¼•å·ï¼Œéœ€æ·»åŠ  #
    let quotes = r#"And then I said: "There is no escape!""#;
    println!("{}", quotes);

    // åŸå§‹å­—ç¬¦ä¸²ä¸­æœ‰ "#" å·ï¼Œå®šç•Œç¬¦ä½¿ç”¨å¤šä¸ª #
    let longer_delimiter = r###"A string with "# in it. And even "##!"###;
    println!("{}", longer_delimiter);
}
```



### 2.4.7 å­—èŠ‚ä¸² (byte string)

é UTF-8 å­—ç¬¦ï¼Œä½¿ç”¨å­—èŠ‚ä¸² (byte string)

```rust
use std::str;

fn main() {
    // ä¸æ˜¯ &str
    let byte_string: &[u8; 20] = b"this is a bytestring";
    println!("A byte string: {:?}", byte_string);

    // å­—èŠ‚ä¸²å¯ä»¥ä½¿ç”¨å•å­—èŠ‚è½¬ä¹‰å­—ç¬¦
    let escaped = b"\x52\x75\x73\x74 as bytes";
    println!("Some escaped bytes: {:?}", escaped);

    // åŸå§‹å­—èŠ‚ä¸²ä½•åŸå§‹å­—ç¬¦ä¸²å†™æ³•ä¸€æ ·
    let raw_byte_string = br"\u{211D} is not escaped here";
    println!("Raw byte string: {:?}", raw_byte_string);

    // å­—èŠ‚ä¸²è½¬ &str å¯èƒ½å¤±è´¥
    if let Ok(my_str) = str::from_utf8(raw_byte_string) {
        println!("And the same as the text: '{}'", my_str);
    }

    let quotes = br#"You can also use "fancier" formmating, \
                              like with normal raw strings"#;
    println!("Quotes: {:?}", quotes);

    // å­—èŠ‚ä¸²ä¸ä½¿ç”¨ utf8 ç¼–ç , SHIFT-JIS ç¼–ç çš„ "ã‚ˆã†ã“ã"
    let shift_jis = b"\x82\xe6\x82\xa8\x82\xb1\x82";

    match str::from_utf8(shift_jis) {
        Ok(my_str) => println!("Conversion successfully: '{}'", my_str),
        Err(e) => println!("Conversion failed: {:?}", e),
    };
}
```



# 3. è‡ªå®šä¹‰ç±»å‹

## 3.1 æšä¸¾ (Enum)

æšä¸¾(enum æˆ– enumeration)å…è®¸ä½ é€šè¿‡åˆ—ä¸¾å¯èƒ½çš„æˆå‘˜æ¥å®šä¹‰ä¸€ä¸ª**æšä¸¾ç±»å‹**

```rust
enum PokerSuit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,
}
```

æšä¸¾é»˜è®¤æ˜¯ç§æœ‰çš„ï¼Œé€šè¿‡ pub å…³é”®å­—å˜ä¸ºå…¬æœ‰ï¼Œå…¶å†…éƒ¨å…ƒç´ ä¹ŸåŒæ—¶å˜ä¸ºå…¬æœ‰ã€‚(è¿™ç‚¹ä¸ç»“æ„ä½“ä¸åŒï¼Œç»“æ„ä½“å…ƒç´ å…¬æœ‰éœ€è¦åœ¨å±æ€§å‰æ·»åŠ pub)



### 3.1.1 æšä¸¾å€¼

```rust
// å®šä¹‰ä¸€ä¸ªæšä¸¾ï¼ŒåŒ…æ‹¬è‹¥å¹²ä¸ªå˜ä½“
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    // åˆ›å»ºä¸€ä¸ª Write æšä¸¾å˜ä½“çš„å®ä¾‹
    let msg = Message::Write(String::from("hello"));

    // åŒ¹é…æšä¸¾å˜ä½“
    match msg {
        Message::Write(text) => println!("{}", text),
        _ => println!("å…¶ä»–æ¶ˆæ¯ç±»å‹"),
    }
}
```

æšä¸¾çš„ `match` è¡¨è¾¾å¼ç¡®ä¿æ‰€æœ‰å¯èƒ½çš„æƒ…å†µéƒ½è¢«å¤„ç†



### 3.1.2 åŒä¸€åŒ–ç±»å‹

æœ‰ä¸€ä¸ª WEB æœåŠ¡ï¼Œéœ€è¦æ¥å—ç”¨æˆ·çš„é•¿è¿æ¥ï¼Œå‡è®¾è¿æ¥æœ‰ä¸¤ç§ï¼š`TcpStream` å’Œ `TlsStream`ï¼Œä½†å¸Œæœ›å¯¹è¿™ä¸¤ä¸ªè¿æ¥çš„å¤„ç†æµç¨‹ç›¸åŒï¼Œä¹Ÿå°±æ˜¯ç”¨åŒä¸€ä¸ªå‡½æ•°æ¥å¤„ç†è¿™ä¸¤ä¸ªè¿æ¥

```rust
fn new (stream: TcpStream) {
  let mut s = stream;
  if tls {
    s = negotiate_tls(stream)
  }

  // websocketæ˜¯ä¸€ä¸ªWebSocket<TcpStream>æˆ–è€…
  //   WebSocket<native_tls::TlsStream<TcpStream>>ç±»å‹
  websocket = WebSocket::from_raw_socket(
    stream, ......)
}

enum Websocket {
  Tcp(Websocket<TcpStream>),
  Tls(Websocket<native_tls::TlsStream<TcpStream>>),
}
```



### 3.1.3 Option

ç©ºå€¼ null çš„è¡¨è¾¾éå¸¸æœ‰æ„ä¹‰ï¼Œå› ä¸ºç©ºå€¼è¡¨ç¤ºå½“å‰æ—¶åˆ»å˜é‡çš„å€¼æ˜¯ç¼ºå¤±çš„ã€‚Rust æŠ›å¼ƒ `null`ï¼Œæ”¹ä¸ºä½¿ç”¨ `Option` æšä¸¾å˜é‡æ¥å¤„ç†ç©ºå€¼

`Option` æšä¸¾æˆå‘˜ï¼š

- `Some(T) ` è¡¨ç¤ºå«æœ‰å€¼
- `None` è¡¨ç¤ºæ²¡æœ‰å€¼

`Option<T>` æšä¸¾è¢«åŒ…å«åœ¨ `prelude`ï¼ˆRust æ ‡å‡†åº“ï¼Œæå‰å°†æœ€å¸¸ç”¨çš„ç±»å‹ã€å‡½æ•°ç­‰å¼•å…¥å…¶ä¸­ï¼Œçœå¾—å†æ‰‹åŠ¨å¼•å…¥ï¼‰ä¹‹ä¸­ï¼Œä¸éœ€è¦å°†å…¶æ˜¾å¼å¼•å…¥ä½œç”¨åŸŸã€‚å®ƒçš„æˆå‘˜ `Some` å’Œ `None` ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œæ— éœ€ä½¿ç”¨ `Option::` å‰ç¼€å°±å¯ç›´æ¥ä½¿ç”¨ã€‚

```rust
let some_number = Some(5);
let some_string = Some("a string");

let absent_number: Option<i32> = None;
```

`match` è¡¨è¾¾å¼ï¼Œå¯ç”¨äºå¤„ç† `Option<T>` ï¼Œä¼šæ ¹æ®æšä¸¾çš„æˆå‘˜è¿è¡Œä¸åŒçš„ä»£ç ï¼Œè¿™äº›ä»£ç å¯ä»¥ä½¿ç”¨åŒ¹é…åˆ°çš„å€¼ä¸­çš„æ•°æ®ã€‚

```rust
fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    println!("{}", six.unwrap());
    println!("{}", none.is_none());
}

fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i+1),
    }
}
```



## 3.2 ç»“æ„ä½“ (Struct)

```rust
// é€šç”¨ç»“æ„ä½“
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

// å…ƒç»„ç»“æ„ä½“
struct Point(i32, i32);

// å•å…ƒç»“æ„ä½“
struct AlwaysEqual;
```



### 3.2.1 é€šç”¨ç»“æ„ä½“

#### 3.2.1.1 åˆ›å»ºå®ä¾‹

æ³¨æ„ï¼š**æ¯ä¸ªå­—æ®µéƒ½å¿…é¡»åˆå§‹åŒ–**

```rust
#[derive(Debug)]
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(username: String, email: String) -> User {
    User {
        active: true,
        username: username,   // init explict
        email,                // use field init shorthand
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(String::from("luna"), String::from("luna@hy.io"));
    
    let user2 = User {
        username: String::from("eli"),
        email: String::from("eli@hy.io"),
        ..user1  // struct update syntax
    };
    
    println!("{:?}\n{:?}", user1, user2);
}
```



#### 3.2.1.2 å†…å­˜æ’åº

```rust
struct File {
    name: String,
    data: Vec<u8>,
}

fn main() {
    let f = File {
        name: String::from("abc.txt"),
        data: Vec::new(),
    };

    let name = &f.name;
    let len = &f.data.len();

    println!("{:?}", f);
    println!("name: {}, length: {}", name, len);
}
```

![img](https://cdn.jsdelivr.net/gh/elihe2011/bedgraph@master/rust/rust-struct-mem.png)

#### 3.2.1.3 å†…å­˜å¯¹é½

```rust
// é»˜è®¤å¯¹é½
struct Default {
    a: u8,  // 1å­—èŠ‚
    b: u32, // 4å­—èŠ‚
    c: u16, // 2å­—èŠ‚
}

// ç´§å‡‘å¸ƒå±€
#[repr(packed)]
struct Packed {
    a: u8,
    b: u32,
    c: u16,
}

// æŒ‡å®šå¯¹å…¶
#[repr(align(8))]
struct Aligned {
    a: u8,
    b: u32,
    c: u16,
}
```



### 3.2.2 å…ƒç»„ç»“æ„ä½“(Tuple-Struct)

å…ƒç»„ç»“æ„ä½“ï¼š**ç»“æ„ä½“æœ‰åç§°ï¼Œä½†å­—æ®µæ²¡æœ‰åç§°**ã€‚å½“å…ƒç»„ç»“æ„ä½“åªæœ‰ä¸€ä¸ªå­—æ®µæ—¶ï¼Œæˆä¸ºæ–°ç±»å‹(newtype)ã€‚

```rust
struct Point(i32, i32);
struct Color(u8, u8, u8);

fn main() {
    let origin = Point(0, 0);
    let black = Color(0, 0, 0);
    ...
}

/**-----------------------**/
// a tuple struct
struct Pair(i32, f32);
let pair = Pair(1, 0.1);
let Pair(integer, decimal) = pair;

// A tuple struct's constructors can be used as functions
struct Digit(i32);
let v = vec![0, 1, 2];
let d: Vec<Digit> = v.into_iter().map(Digit).collect();

// newtype: a tuple struct with only one element
struct Inches(i32);
let length = Inches(10);
let Inches(integer_length) = length;
```



### 3.2.3 å•å…ƒç»“æ„ä½“(Unit-like Struct)

æ²¡æœ‰ä»»ä½•å­—æ®µå’Œå±æ€§ã€‚

å¦‚æœå®šä¹‰ä¸€ä¸ªç±»å‹ï¼Œä½†æ˜¯ä¸å…³å¿ƒè¯¥ç±»å‹çš„å†…å®¹ï¼Œåªå…³å¿ƒå®ƒçš„è¡Œä¸ºæ—¶ï¼Œå°±å¯ä»¥ä½¿ç”¨ `å•å…ƒç»“æ„ä½“`

```rust
struct Null;
let empty = Null;

impl SomeTrait for Null {

}
```



### 3.2.4 æ“ä½œç»“æ„ä½“

#### 3.2.4.1 æ•°æ®æ‰€æœ‰æƒ

```rust
struct User {
    username: &str,    // slice is a reference, expected named lifetime parameter
    email: &str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user = User {
        email: "lolly@test.io",
        username: "ly",
        active: true,
        sign_in_count: 1,
    };

    println!("{:?}", user);
}
```

åœ¨ç»“æ„ä½“ä¸­ï¼Œä½¿ç”¨åŸºäºå¼•ç”¨çš„ `&str` å­—ç¬¦ä¸²åˆ‡ç‰‡ç±»å‹ï¼Œå³`User` ç»“æ„ä½“ä»å…¶å®ƒå¯¹è±¡å€Ÿç”¨æ•°æ®ã€‚ä½†æ­¤å¤„å¿…é¡»ç”¨åˆ°ç”Ÿå‘½å‘¨æœŸ(lifetimes)ï¼Œå¦åˆ™å°†å‡ºç° `error[E0106]: missing lifetime specifier`ï¼Œä¿®æ­£ï¼š

```rust
struct User<'a> {
    username: &'a str,
    email: &'a str,
    sign_in_count: u64,
    active: bool,
}
```

æ³¨æ„ï¼š**ç»“æ„ä½“ä¸­æœ‰å¼•ç”¨å­—æ®µæ—¶ï¼Œéœ€è¦å¯¹ç”Ÿå‘½å‘¨æœŸå‚æ•°è¿›è¡Œå£°æ˜ `<'a>`**ã€‚è¯¥ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨è¯´æ˜ï¼Œç»“æ„ä½“ `User` æ‰€å¼•ç”¨çš„å­—ç¬¦ä¸² `str` å¿…é¡»æ¯”è¯¥ç»“æ„ä½“æ´»å¾—æ›´ä¹…ã€‚



#### 3.2.4.2 æ‰“å°ç»“æ„ä½“

```rust
#[derive(Debug)]     // æ‰“å°
#[derive(Default)]   // é»˜è®¤å€¼
struct Point3D {
    x: i32,
    y: i32,
    z: i32
}

fn main() {
    let origin = Point3D::default();
    println!("{:?}", &origin);
    
    let point = Point3D{y: 1, ..origin};
    let Point3D{x: x0, y: y0, ..} = point;
    
    println!("x={}, y={}", x0, y0);
}
```



#### 3.2.4.3 å­—æ®µå¯å˜æ€§

Rust ä¸æ”¯æŒåŸŸå¯å˜æ€§(field mutability):

```rust
struct Point {
    mut x: i32,  // ä¸æ”¯æŒ
    y: i32,
}
```



å¯å˜æ€§æ˜¯ç»‘å®šçš„ä¸€ä¸ªå±æ€§ï¼Œè€Œä¸æ˜¯ç»“æ„ä½“è‡ªèº«çš„ï¼š

```rust
use std::cell::Cell;

#[derive(Debug)]
struct Point2D {
    x: i32,
    y: Cell<i32>
}

fn main() {
    let mut point = Point2D{x: 1, y: Cell::new(5)};
    println!("{:?}", &point);
    
    point.y.set(8);
    println!("{:?}", point);
}
```



### 3.2.5 æ–¹æ³•å®ç°

```rust
struct Reactangle {
    width: u32,
    height: u32,
}

impl Reactangle {
    // æ„é€ æ–¹æ³•
    fn new(width: u32, height: u32) -> Self {
        Reactangle { width, height }
    }
    
    // ä¸å¯å˜æ–¹æ³•
    fn area(&self) -> u32 {
        self.width * self.height
    }
    
    // å¯å˜æ–¹æ³•
    fn resize(&mut self, width: u32, height: u32) {
        self.width = width;
        self.height = height;
    }
    
    // å…³è”å‡½æ•° (é™æ€æ–¹æ³•)
    fn square(size: u32) -> Reactangle {
        Rectangle { width: size, height: size }
    }
}
```



### 3.2.6 é«˜çº§ç‰¹æ€§

#### 3.2.6.1 ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨

```rust
struct Container<'a> {
    data: &'a str,
}

impl<'a> Container<'a> {
    fn get_data(&self) -> &str {
        self.data
    }
}
```



#### 3.2.6.2 æ³›å‹çº¦æŸ

```rust
struct Stack<T: Clone> {
    items: Vec<T>,
}

impl<T: Clone> Stack<T> {
    fn push(&mut self, item: T) {
        self.items.push(item);
    }
}
```



#### 3.2.6.3 é›¶æˆæœ¬æŠ½è±¡

```rust
#[derive(Debug)]
struct Wrapper<T>(T);

impl<T> Wrapper<T> {
    fn new(value: T) -> Self {
        Wrapper(value)
    }
}
```



### 3.2.7 æ€§èƒ½ä¼˜åŒ–

#### 3.2.7.1 å†…è”ç»“æ„ä½“

```rust
struct SmallStruct {
    x: i32,
    y: i32,
}

impl SmallStruct {
    #[inline(always)]
    fn sum(&self) -> i32 {
        self.x + self.y
    }
}
```



#### 3.2.7.2 ç¼“å­˜å‹å¥½å¸ƒå±€

```rust
// æŒ‰è®¿é—®é¢‘ç‡æ’åºå­—æ®µ
struct CacheFriendly {
    frequently_accessed: u64,
    also_frequent: u32,
    rarely_used: String,
}
```



# 4. ç±»å‹ç³»ç»Ÿ

## 4.1 ç±»å‹è½¬æ¢

ä¸æä¾›åŸç”Ÿç±»å‹ä¹‹é—´çš„éšå¼ç±»å‹è½¬æ¢(coercion)ï¼Œä½†å¯ä»¥ä½¿ç”¨ `as` å…³é”®å­—è¿›è¡Œæ˜¾å¼ç±»å‹è½¬æ¢(casting)

```rust
#[allow(overflowing_literals)]
fn main() {
    let decimal = 6543.21_f32;

    // ä¸æ”¯æŒéšå¼è½¬æ¢
    //let integer: u8 = decimal;

    // æ˜¾ç¤ºè½¬æ¢
    let integer = decimal as u8;
    let character = integer as char;

    println!("integer: {}, character: {}", integer, character);

    // å¤„ç†æ–¹å¼ï¼šä»æœ€ä½æœ‰æ•ˆä½ï¼ˆLSB, least significant bitsï¼‰å¼€å§‹ä¿ç•™ 8 ä½ï¼Œ
    // ç„¶åå‰©ä½™ä½ç½®ï¼Œç›´åˆ°æœ€é«˜æœ‰æ•ˆä½ï¼ˆMSB, most significant bitï¼‰éƒ½è¢«æŠ›å¼ƒ
    // 0b0011 1110 1000 => 0b1110 1000
    println!("1000 as u8: {}", 1000 as u8);  // 232

    // 0b1111 1111
    println!("-1i8 as u8: {}", -1i8 as u8);  // 255

    println!("128 as i16: {}", 128 as u16);  // 128
    println!("128 as i8: {}", 128 as i8);    // -128
}
```



## 4.2 å­—é¢é‡

æ•°å€¼çš„å­—é¢é‡ï¼Œå°†ç±»å‹ä½œä¸ºåç¼€åŠ ä¸Šå»ï¼Œæ¥å®Œæˆç±»å‹è¯´æ˜ã€‚æ¯”å¦‚`42i32`è¡¨ç¤ºç±»å‹çš„ `i32`çš„ `42`

æ— åç¼€çš„æ•°å€¼å­—é¢é‡ï¼Œå…¶ç±»å‹å–å†³äºæ€æ ·ä½¿ç”¨å®ƒä»¬ã€‚å¦‚æœæ²¡æœ‰é™åˆ¶ï¼Œç¼–è¯‘å™¨ä¼šå¯¹æ•´æ•°ä½¿ç”¨ `i32`ï¼Œå¯¹æµ®ç‚¹æ•°ä½¿ç”¨ `f64`

```rust
use std;

fn main() {
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    let i = 1;   // i32
    let f = 1.0; // f64

    println!("bytes(x): {}", std::mem::size_of_val(&x));  // 1
    println!("bytes(y): {}", std::mem::size_of_val(&y));  // 4
    println!("bytes(z): {}", std::mem::size_of_val(&z));  // 4
    println!("bytes(i): {}", std::mem::size_of_val(&i));  // 4
    println!("bytes(f): {}", std::mem::size_of_val(&f));  // 8
}
```

æ³¨é‡Šï¼š

- `func(&bar)` å¼•ç”¨ä¼ é€’ (pass by reference)ï¼Œ`func(bar)` å€¼ä¼ é€’ (pass by value)
- `std::mem::size_of_val` ç³»ç»Ÿæ ‡å‡†åº“å‡½æ•°



## 4.3 ç±»å‹æ¨æ–­

ä¸åªåœ¨åˆå§‹åŒ–æ—¶çœ‹å€¼çš„ç±»å‹ï¼Œæ›´ä¼šæ ¹æ®å®é™…ä½¿ç”¨æƒ…å†µï¼Œè‡ªåŠ¨æ¨æ–­ç±»å‹

```rust
fn main() {
    let e = 3;

    // ç±»å‹ä¸º Vec<?>
    let mut vec = Vec::new();

    // æ¨æ–­ç±»å‹ä¸º Vec<i32>
    vec.push(e);

    println!("{:?}", vec);
}
```



# 5. ç±»å‹è½¬æ¢

Rust é€šè¿‡ `From`å’Œ `Into` ä¸¤ä¸ª Trait è§£å†³ç±»å‹è½¬æ¢é—®é¢˜



## 5.1 `From` & `Into`

### 5.1.1 `From`

`From` trait å…è®¸ç±»å‹å®šä¹‰ â€œæ€ä¹ˆæ ¹æ®å¦ä¸€ç§ç±»å‹ç”Ÿæˆè‡ªå·±â€ï¼Œå®ƒæä¾›äº†ä¸€ç§ç±»å‹è½¬æ¢çš„ç®€å•æœºåˆ¶

ä¾‹å¦‚ï¼š `&str`  è½¬ `String`

```rust
fn main() {
    let str = "hello";
    let string = String::from(str);

    println!("{}", string);
}
```



è‡ªå®šä¹‰ç±»å‹è½¬æ¢ï¼š

```rust
use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i64,
}

impl From<i64> for Number {
    fn from(value: i64) -> Self {
        Number{value}
    }
}

fn main() {
    let num = Number::from(56);

    println!("{:?}", num);
    println!("{}", num.value)
}
```



### 5.1.2 `Into`

`Into` æ˜¯ `From` çš„åæ“ä½œã€‚å¦‚æœç±»å‹å®ç°äº† `From`ï¼Œä¹Ÿè‡ªåŠ¨å®ç°äº† `Into`

ä½¿ç”¨ `Into` trait é€šå¸¸è¦æ±‚æŒ‡æ˜è¦è½¬æ¢åˆ°çš„ç±»å‹ï¼Œå› ä¸ºç¼–è¯‘å™¨å¤§å¤šæ•°æ—¶å€™ä¸èƒ½æ¨æ–­å®ƒã€‚

```rust
struct Number {
    value: i64
}

impl From<i64> for Number {
    fn from(value: i64) -> Self {
        Number{value}
    }
}

fn main() {
    let i = 5;

    let n: Number = i.into();  // å¿…é¡»æ˜¾å¼å£°æ˜ç±»å‹ä¸º Number

    println!("{}", n.value);
}
```



## 5.2 `TryFrom` & `TryInto`

### 5.2.1  `TryFrom` 

`TryFrom` trait ç”¨äºæ˜“å‡ºé”™çš„è½¬æ¢ï¼Œå…¶è¿”å›å€¼æ˜¯ `Result` å‹

```rust
#[derive(Debug,PartialEq)]
struct EvenNumber(i32);

impl TryFrom<i32> for EvenNumber {
    type Error = ();

    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    assert_eq!(EvenNumber::try_from(6), Ok(EvenNumber(6)));
    assert_eq!(EvenNumber::try_from(7), Err(()));
}
```



### 5.2.2  `TryInto`

 `TryInto` trait ç”¨äºæ˜“å‡ºé”™çš„è½¬æ¢ï¼Œå…¶è¿”å›å€¼æ˜¯ `Result` å‹

```rust
#[derive(Debug,PartialEq)]
struct EvenNumber(i32);

impl TryFrom<i32> for EvenNumber {
    type Error = ();

    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    let ret: Result<EvenNumber, ()> = 6.try_into();
    assert_eq!(ret, Ok(EvenNumber(6)));

    let ret: Result<EvenNumber, ()> = 7.try_into();
    assert_eq!(ret, Err(()));
}
```



## 5.3 `ToString` & `FromStr`

### 5.3.1  `ToString` 

 `ToString` trait å°†ä»»ä½•ç±»å‹è½¬æ¢ä¸º Stringã€‚ä¸€èˆ¬é€šè¿‡ `fmt::Display` trait å®ç°ï¼Œå®ƒè‡ªåŠ¨æä¾› `ToString`

```rust
struct Circle {
    radius: i32,
}

impl fmt::Display for Circle {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "Circle's radius {}", self.radius)
    }
}

fn main() {
    let circle = Circle{radius: 8};
    println!("{}", circle.to_string());
}
```

ç›´æ¥å®ç° `ToString` traitï¼Œä¸æ¨èï¼š

```rust
struct Circle {
    radius: i32,
}

// ToString should be implemented directly
impl ToString for Circle {
    fn to_string(&self) -> String {
        format!("Circle's radius {}", self.radius)
    }
}

fn main() {
    let circle = Circle{radius: 8};
    println!("{}", circle.to_string());
}
```



### 5.2.2 `FromStr`

`FromStr` trait å°†å­—ç¬¦ä¸²è½¬ä¸ºå…¶ä»–ç±»å‹ã€‚åœ¨æ ‡å‡†åº“ä¸­ï¼Œå­—ç¬¦ä¸²è½¬æ•°å­—çš„ `FromStr` å·²å®ç°

```rust
fn main() {
    // æ–¹æ³•ä¸€ï¼šå£°æ˜ç±»å‹
    let m: i32 = "3".parse().unwrap();
    println!("{}", m);

    // æ–¹æ³•äºŒï¼šæ¶¡è½®é±¼ (turbo fish <>)
    let n = "5".parse::<i32>().unwrap();
    println!("{}", n);
}
```















































