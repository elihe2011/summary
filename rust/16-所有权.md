

# 1. 所有权







## 1.2 所有权规则

Rust 中所有权的基本规则包括变量作用域、移动语义和借用规则。

1、**变量作用域**：一般在一个 `{ }` 内

```rust
{
    let s = "hello";
    // 有效
}
// 无效
```



2、**移动语义**：当将值赋给另一个变量时，原始变量将不再可用。

```rust
let s1 = String::from("hello");
let s2 = s1;   // s1 不再有效，因为它的值已经被移动到了 s2
```



3、**借用规则**：可以通过引用来借用值，而不会获取其所有权。有两种引用：可变引用和不可变引用。

```rust
let mut s = String::from("hello");
let r1 = &s;     // 不可变引用
let r2 = &mut s; // 可变引用
```



## 1.3 变量绑定

### 1.3.1 转移所有权

```rust
// 基础类型，栈上自拷贝赋值
let x = 5;
let y = x;

// 复杂类型，不支持自动拷贝
let s1 = String::from("hello");
let s2 = s1;
```

String 是一种复杂类型，由**存储在栈中的堆指针、字符串长度、字符串容量共同组成**

当变量离开作用域后，Rust会自动调用 drop 函数并清理变量的堆内存。如果一个值属于两个所有者，将会导致多次尝试清理同样的内存，即**二次释放(double free)错误**。两次释放同样的内存，会导致内存污染，可能导致潜在的安全漏洞。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    
    println!("{}", s2);  // ok
    println!("{}", s1);  // borrow of moved value s1
}
```

由于 Rust 禁止使用无效的引用，上述代码将出现错误：

```txt
error[E0382]: borrow of moved value: `s1`
 --> src\main.rs:5:20
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{}", s1);
  |                    ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly build
s, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
```

将类型String修改为 `&str`，则不会有问题：

```rust
fn main() {
    let s1 = "hello";
    let s2 = s1;
    println!("{}", s1)
}
```

区别：

- 在 `String` 例子中，`s1` 持有了通过`String::from("hello")` 创建的值的所有权
- 在 `&str` 例子中，`s1` 只是引用了存储在二进制中的字符串 `"hello"`，并没有持有所有权



### 1.3.2 拷贝

**深拷贝(克隆)**：Rust 不会自动创建数据的“深拷贝”，只能调用 `clone()` 方法进行深拷贝操作，它发生在堆上

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();
    println!("{}", s1);
}
```



**浅拷贝**：浅拷贝只发生在栈上，性能较高。

```rust
fn main() {
    let x = 5;
    let y = x;
    println!("{}", x);
}
```

可拷贝的类型：**任何基本类型的组合可以Copy，不需要分配内存或某种形式资源的类型是可以 Copy 的。**

- 整数类型，如 u32
- 浮点数类型：如 f64
- 布尔类型：bool
- 字符类型：char
- 元组：当且仅当其包含的类型也都是 Copy 的。如 (i32, i32) 可以 Copy，但 (i32, String) 则不能
- 不可改变引用 &T，如 &str。但**可变引用 `&mut T` 是不可以 Copy 的**



## 1.4 函数传值与返回

将值传递给函数，会发生 `move` 或`copy`，跟 `let` 语句一样

```rust
fn main() {
    let x = 5;
    makes_copy(x);
    println!("{}", x);

    let s = String::from("hello");
    takes_ownership(s);
    println!("{}", s);  // s 的所有权移交给了函数，此处打印将报错
}

fn makes_copy(n: i32) {
    println!("{}", n);
}

fn takes_ownership(s: String) {
    println!("{}", s);
}
```

所有权带来的麻烦：**总是把一个值传来传去来使用它**。 传入一个函数，很可能还要从该函数传出去，结果就是语言表达变得非常啰嗦



# 2. 借用

**获取变量的引用，称之为借用(borrowing)**



## 2.1 引用

常规引用是一个指针类型，指向了对象存储的内存地址。

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(x, 5);
    assert_eq!(*y, 5); // 解引用
}
```



## 2.2 不可变引用

```rust
fn main() {
    let x = String::from("hello");
    let len = calc_length(&x);
    println!("The length of '{}' is {}", x, len);
}

fn calc_length(s: &String) -> usize {
    s.len()   // s离开了作用域，但因为它不拥有引用值得所有权，所以什么也不会发生
}
```

`&` 符号即是引用，**它允许你使用值，但是不获取所有权**。

![img](https://cdn.jsdelivr.net/gh/elihe2011/bedgraph@master/rust/rust-immutable-reference.jpg)

## 2.3 可变引用

```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);

    println!("{}", s);
}

fn change(s: &mut String) {
    s.push_str(", world");
}
```



### 2.3.1 可变引用同时只能存在一个

```rust
// ok
fn immutable() {
    let s = String::from("hello");
    let r1 = &s;
    let r2 = &s;
    println!("{}, {}", r1, r2);
}

// error[E0499]: cannot borrow `s` as mutable more than once at a time
fn mutable() {
    let mut s = String::from("hello");
    let r1 = &mut s;
    let r2 = &mut s;
    println!("{}, {}", r1, r2);
}
```

编译器 `borrow checker` 特性，避免了数据竞争，数据竞争可能导致如下问题：

- 两个或更多的指针同时访问同一数据
- 至少有一个指针被用来写入数据
- 没有同步数据访问机制



### 2.3.2 可变引用与不可变引用不能同时存在

```rust
// error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
fn main() {
    let mut s = String::from("hello");
    let r1 = &s;         // ok, immutable borrow occurs here
    let r2 = &s;         // ok
    let r3 = &mut s;  // error, mutable borrow occurs here
    println!("{} {} {}", r1, r2, r3)
}

// Rust1.31+优化：引用作用域的结束位置从花括号变成最后一次使用的位置
fn main() {
    let mut s = String::from("hello");
    let r1 = &s;        // ok
    let r2 = &s;        // ok
    println!("{}, {}", r1, r2);

    let r3 = &mut s;    // ok
    println!("{}", r3);
}
```



### 2.3.3 NLL

**None-Lexical Lifetimes** ，Rust 编译器的一种优化行为，专门用于找到某个引用所在作用域( } )结束前就不再被使用的代码位置。



## 2.4 悬垂引用(Dangling References)

**也称悬垂指针，即指针指向的值被释放掉了，但指针依然存在**，其指向的内存可能不存在任何值或已被其他变量重新使用。

Rust 编译器可确保引用永远不会变成悬垂状态：当你获取数据的引用后，编译器可确保数据不会再引用结束前被释放，要想释放数据，必须先停止其引用的使用。

```rust
fn main() {
    let reference_to_nothing = dangle();
    println!("{:?}", reference_to_nothing);
}

// Missing lifetime specifier [E0106]
fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

解决办法：不返回引用，而返回值，最终 String 的所有权转移给外面的调用者。

```rust
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```



示例2：

```rust
fn main() {
    let r;

    {
        let x = 5;
        r = &x;    // 变量x在离开它的作用域后被释放，但是变量r仍然保留了对它的引用，这样就产生了一个悬垂引用
    }

    println!("r: {}", r);
}
```







## 2.5 借用规则总结

-  同一时刻，只能拥有要么一个可变引用，要么任意多个不可变引用
-  引用必须总是有效的

