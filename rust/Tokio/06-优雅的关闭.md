要让一个异步应用优雅的关闭往往需要做到三点：

- 找出合适的关闭时机
- 通知程序的每一个子部分开始关闭
- 在主线程等待各个部分的关闭结果



# 1. 找出合适的关闭时机

通过 `ctrl + c` 关闭正在运行的命令行程序。为了检测来自操作系统的关闭信号，`Tokio` 提供了一个 `tokio::signal::ctrl_c` 函数，它将一直睡眠直到收到对应的信号：

```rust
use tokio::signal;

#[tokio::main]
async fn main() {
    // ... spawn application as separate task ...
    // 在一个单独的任务中处理应用逻辑
    
    match signal::ctrl_c().await {
        Ok(()) => {},
        Err(err) => {
            eprintln!("Unable to listen for shutdown signal: {}", err);
        }
    }
    
    // 发送关闭信息给应用所在的任务，然后等待
}
```



# 2. 通知程序的每一个部分开始关闭

应用中的每个任务都持有一个广播消息通道的接收端，当消息被广播到该通道时，每个任务都可以收到该消息，并关闭自己

```rust
let next_frame = tokio::select! {
    res = self.connection.read_frame() => res?,
    _ = self.shutdown.recv() => {
        // 收到关闭信号后，直接从`select!`返回，此时`select!`中的另一个分支自动释放
        return Ok(());
    }
}
```



# 3. 等待各个部分的接收

`mpsc` 消息通道的一个重要特性：当所有发送端都 `drop` 时，消息通道自动关闭，此时继续接收消息就会报错

```rust
use tokio::sync::mpsc::{channel, Sender};
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    let (tx, mut rx) = channel(1);
    
    for i in 0..10 {
        tokio::spawn(some_operation(i, tx.clone()));
    }
    
    // 等待各个任务完成
    // drop发送端，因为`rx.recv()`调用会阻塞，如果不`drop`，那发送端就无法被
    // 全部关闭，`rx` 也就永远无法结束，这将陷入一个类似死锁的困境
    drop(tx);
    
    // 当所有发送端都超出作用域被`drop`时，`rx`调用会返回一个错误
    let _ = rx.recv().await;
}

async fn some_operation(i: u64, _sender: Sender<()>) {
    sleep(Duration::from_millis(100 * i)).await;
    println!("Task {} shutting down.", i);
    
    // 发送端超出作用域，然后被`drop`
}
```





































