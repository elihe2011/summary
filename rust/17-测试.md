# 1. 单元测试

测试 (test) 函数，通常会进行一些配置，运行想要测试的代码，然后断言(assert) 结果是不是所期望的。

单元测试一般会被放到一个叫 `tests` 的，带有 `#[cfg(test)]` 属性的模块中，测试函数要加上 `#[test]` 属性。

断言宏：

- `assert!(expression)`  如果表达式的值是 false 则 panic
- `assert_eq!(left, right)` 和 `assert_ne(left, right)` 检验左右两边是否相等/不等。

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[allow(dead_code)]
fn bad_add(a: i32, b: i32) -> i32 {
    a - b
}

#[cfg(test)]
mod tests {
    // 惯用写法：从外部作用域导入所有名字
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
    }

    #[test]
    fn test_bad_add() {
        assert_eq!(bad_add(1, 2), -1);
    }
}
```



## 7.1 测试 panic

函数在特定条件下的 panic，为测试这种行为，使用 `#[should_panic]` 属性，该属性接受可选参数 `excepted = ` 以指定 panic 时的消息。如果函数能以多种方式 panic，这个属性就保证了在测试的确实是所指定的 panic.

```rust
pub fn divide_non_zero_result(a: u32, b: u32) -> u32 {
    if b == 0 {
        panic!("Divide-by-zero error");
    } else if a < b {
        panic!("Divide result is zero");
    }

    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_divide() {
        assert_eq!(divide_non_zero_result(10, 2), 5);
    }

    #[test]
    #[should_panic]
    fn test_any_panic() {
        divide_non_zero_result(1, 0);
    }

    #[test]
    #[should_panic(expected = "Divide result is zero")]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    }
}
```

运行测试：

```bash
# 测试全部
cargo test

# 指定测试函数
cargo test test_any_panic
```



## 1.2 忽略测试

排除某些测试：

- 属性 `#[ignore]`
- 命令 `cargo test -- --ignored`    忽略全部

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(3, 8), 11);
    }

    #[test]
    fn test_add_hundred() {
        assert_eq!(add(2, 100), 102);
    }

    #[test]
    #[ignore]
    fn ignored_test() {
        assert_eq!(add(1, 2), 4);
    }
}
```



# 2. 文档测试

为 Rust 工程编写文档的主要方式是在源代码中写注释。文档注释使用 markdown 语法书写，支持diamagnetic块。

Rust 很注重正确性。这些注释中的代码块也会被编译并且用作测试。

```rust
/// 函数简述：整数相加
///
/// 详细文档。代码块用三个反引号开启，Rust会隐式在其中添加
/// `fn main()` 和 `extern crate <cratename>`，比如测试 `b01-doc-test` crate:
///
/// ```
/// let result = b01_doc_test::add(2, 3);
/// assert_eq!(result, 5);
/// ```
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

/// 两数相除
///
/// # Example
///
/// ```
/// let result = b01_doc_test::div(10, 2);
/// assert_eq!(result, 5);
/// ```
///
/// # Panics
///
/// 如果第二个参数是 0，函数将会 panic
///
/// ```rust, should_panic
/// // panics on division by zero
/// b01_doc_test::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("Divide-by-zero error");
    }

    a / b
}
```

执行测试：

```bash
cargo test
```



# 3. 集成测试

单元测试仅能单独测试一个模块，属小规模测试私有代码；

集成测试是 crate 外部的测试，并且仅使用 crate 的公共接口，其目的是检验库的各个部分是否能正确地协同工作。

**cargo 在 src 同级别的 tests 目录下寻找集成测试**

文件 `src/lib.rs`：

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

集成测试文件：`tests/integration_test.rs`

```rust
#[test]
fn test_add() {
    assert_eq!(adder::add(3, 2), 5);
}
```



tests 目录中的每个 Rust 源文件都被编译成一个单独的 crate。在集成测试中共享代码，可先创建具有公用函数的模块，测试时导入并使用它。

公共文件 `tests/common.rs`：

```rust
pub fn setup() {
    // 配置代码，如创建文件、目录，开启服务器等
}
```

测试文件：`tests/integration_test.rs`

```rust
// 导入公共模块
mod common;

#[test]
fn test_add() {
    common::setup();
    
    assert_eq!(adder::add(2, 3), 5);
}
```



# 4. 开发依赖

有些仅在测试中需要的依赖，如基准测试。这种依赖写在 Cargo.toml 的 `[dev-dependencies]` 部分，它们不会传播给其他依赖该包的包。

添加 `assert!` 宏扩展包，文件 `Cargo.toml`:

```toml
[dev-dependencies]
pretty_assertions = "1"
```

文件 `src/lib.rs`：

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq;

    #[test]
    fn test_add() {
        assert_eq!(add(8, 9), 17);
    }
}
```





















