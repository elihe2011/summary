# 1. 模块系统

模块系统：

- 包 Packages：cargo 提供的创建、测试及分享 Crates 的工具。
- 箱 Crates：提供类库或可执行文件的模块树，与其他语言中的library 或 package 作用一样
- 模块 Modules：管理和组织路径，及其作用域和访问权限
- 路径 Paths：结构体、函数、模块等事物的命名方式



# 2. Packages & Crates

## 2.1 创建

包(Package) 通过 Cargo 创建，每一个包都有一个 `Cargo.toml` 文件，包中箱(Crates)的规则：

- Library Crates：0~1个

  ```bash
  ❯ cargo new --lib my-lib
       Created library `my-lib` package
  ❯ tree my-lib
  my-lib
  ├── Cargo.toml
  └── src
      └── lib.rs
  ```

- Binary Crates：任意多个

  ```bash
  ❯ cargo new my-project
       Created binary (application) `my-project` package
  ❯ tree my-project
  my-project
  ├── Cargo.toml
  └── src
      └── main.rs



默认，一个箱(crate):

- src/main.rs 二进制箱(binary crate)的根文件
- src/lib.rs 类库箱(library crate)的根文件

多个二进制箱(binary crates)：在src/bin 目录下创建 `.rs` 文件，每个文件对应一个二进制箱(binary crate)



## 2.1 编译类库

```bash

```



## 2.2 使用类库

```bash

```







# 3. Modules 模块

模块(module)系统，可以将代码按层次分成多个逻辑单元(模块)，并管理这些模块直接的可见性 (public & private)

模块是函数、结构体、trait、impl块、其他模块的集合。



## 3.1 模块定义

通过关键字 mod 识别

```rust
// Filename: src/lib.rs 

mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```

文件 src/main.rs 和 src/lib.rs，对应的模块是 crate，箱(crate)的模块结构(module structure)，也叫模块树(module tree)：

```text
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```

:warning:模块 crate 默认存在，不需要通过关键字 mod 来定义



## 3.2 可见性

模块中的项默认是私有的，但可以通过 pub 修饰符使其公开，提供模块外作用域访问。

```rust
mod my_mod {
    fn private_function() {
        println!("called `my_mod::private_function()`");
    }

    pub fn function() {
        println!("called `my_mod::function()`");
    }

    pub fn indirect_access() {
        print!("called `my_mod::indirect_access()`, \n then ");
        private_function();
    }

    pub mod nested {
        pub fn function() {
            println!("called `my_mod::nested::function()`");
        }

        #[allow(dead_code)]
        fn private_function() {
            println!("called `my_mod::nested::private_function()`");
        }

        // pub(in path) 只在给定的路径中可见，path必须是父模块或祖先模块
        pub(in crate::my_mod) fn public_function_in_my_mod() {
            print!("called `my_mod::nested::public_function_in_my_mod()`, \n then ");
            public_function_in_nested();
        }

        // pub(self) 只在当前模块中可见
        pub(self) fn public_function_in_nested() {
            println!("called `my_mod::nested::public_function_in_nested()`");
        }

        // pub(super) 只在父模块中可见
        pub(super) fn public_function_in_super_mod() {
            println!("called `my_mod::nested::public_function_in_super_mod()`")
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!("called `my_mod::call_public_function_in_my_mod()`, \n then ");
        nested::public_function_in_my_mod();
        print!(" then ");
        nested::public_function_in_super_mod();
    }

    // pub(crate) 只在当前crate中可见
    pub(crate) fn public_func_in_crate() {
        println!("called `my_mod::public_function_in_crate()`");
    }

    mod private_nested {
        #[allow(dead_code)]
        pub fn function() {
            println!("called `my_mod::private_nested::function()`");
        }
    }
}

fn function() {
    println!("called `function()`");
}

fn main() {
    // 通过模块，消除相同名字项的冲突
    function();
    my_mod::function();
    println!("-----------------------------------------------");

    // 公有项，可在模块外调用
    my_mod::indirect_access();
    my_mod::nested::function();
    my_mod::call_public_function_in_my_mod();
    println!("-----------------------------------------------");

    // pub(crate)，可在crate中任何地方调用
    my_mod::public_func_in_crate();

    // pub(in path)，只能在给定的模块(my_mod)内部访问，所以此处无法调用
    // my_mod::nested::public_function_in_my_mod();

    // pub(self)，只允许模块内部访问，所以此处无法调用
    // my_mod::nested::public_function_in_nested();

    // pub(super)，只允许父模块访问，所以此处无法调用
    // my_mod::nested::public_function_in_super_mod();

    // 不允许访问模块私有项
    // my_mod::private_function();

    // 不允许访问公有嵌套模块的私有项
    // my_mod::nested::private_function();

    // 不允许访问私有嵌套模块的任何项
    // my_mod::private_nested::function();
}
```

总结：

- `pub(in path)`：只能在给定的模块内部访问
- `pub(self)`：只允许模块内部访问，效果和不加 pub(self) 一样
- `pub(super)`：只允许父模块访问
- `pub(crate)`：只在当前crate中可见



## 3.3 结构体可见性

结构体字段默认是私有的，需要加上 pub 修饰符来公开。之所以默认为私有，其意义是隐藏信息，即封装(encapsulation)

```rust
use crate::my_mod::OpenBox;

mod my_mod {
    pub struct OpenBox<T> {
        pub contents: T,
    }

    pub struct ClosedBox<T> {
        contents: T,
    }

    impl<T> ClosedBox<T> {
        pub fn new(contents: T) -> ClosedBox<T> {
            ClosedBox {
                contents,
            }
        }

        pub fn contents(self) -> T {
            self.contents
        }
    }
}

fn main() {
    // 可直接使用
    let open_box = my_mod::OpenBox{contents: "public contents"};
    println!("{}", open_box.contents);

    // 无法直接使用
    // let closed_box = my_mod::ClosedBox{contents: "private contents"};
    // println!("{}", closed_box.contents);

    // 间接使用
    let closed_nox = my_mod::ClosedBox::new("private contents");
    println!("{}", closed_nox.contents());
}
```









## 3.4 super & self

```rust
fn function() {
    println!("called `function()`");
}

mod cool {
    pub fn function() {
        println!("called `cool::function()`");
    }
}

mod my {
    fn function() {
        println!("called `my::function()`");
    }

    mod cool {
        pub fn function() {
            println!("called `my::cool::function()`");
        }
    }

    pub fn indirect_call() {
        println!("called `my::indirect_call()`, then ");

        // 相同
        self::function();
        function();

        // 内部模块
        self::cool::function();

        // 父作用域
        super::function();

        // 最外面的crate作用域
        {
            use crate::cool::function as root_function;
            root_function();
        }
    }
}

fn main() {
    my::indirect_call();
}
```



## 3.5 文件分层

模块可以分配到文件/目录的层次结构中：

```text
$ tree .
.
|-- my
|   |-- inaccessible.rs
|   |-- mod.rs
|   `-- nested.rs
`-- main.rs
```

`main.rs`

```rust
// 查找my.rs或my/mod.rs文件，并将内容放入my作用域
mod my;

fn function() {
    println!("called `function()`");
}

fn main() {
    my::function();

    function();

    my::indirect_access();

    my::nested::function();
}
```

`my/mod.rs`

```rust
// 模块主文件
pub mod nested;
mod inaccessible;

pub fn function() {
    println!("called `my::function()`");
}

fn private_function() {
    println!("called `my::private_function()`");
}

pub fn indirect_access() {
    print!("called `my::indirect_access()`, that \n>");
    private_function();
}
```

`my/nested.rs`

```rust
pub fn function() {
    println!("called `my::nested::function()`");
}

#[allow(dead_code)]
fn private_function() {
    println!("called `my::nested::private_function()`");
}
```

`my/inaccessible.rs`

```rust
#[allow(dead_code)]
pub fn function() {
    println!("called `my::inaccessible::function()`");
}
```



# 4. Paths

箱(crate)的根节点是 `crate`

- 绝对路径：从箱的根节点开始，箱的名称或crate
- 相对路径：从当前模块开始，可以使用 self 或 super

```rust
// 绝对路径 Absolute path
crate::front_of_house::hosting::add_to_waitlist();

// 相对路径 Relative path
front_of_house::hosting::add_to_waitlist();
```





# 2. crate

crate 包是 Rust 的编译单元。当调用 `rust some_file.rs` 时，`some_file.rs` 被当作 crate 文件。如果 `some_file.rs` 含有 mod 声明，那么模块文件内容将在编译前被导入到 crate 文件的相应声明处。

**模块不会被单独编译**，只有 crate 才会被编译。

crate 编译：

- 二进制可执行文件(binary)，默认
- 库文件(library)，`rustc --crate-type=lib`



## 2.1 库

```rust
pub fn public_function() {
    println!("called lib's `public_function()`");
}

fn private_function() {
    println!("called lib's `private_function()`");
}

pub fn indirect_access() {
    print!("called lib's `indirect_access()`, that\n>");

    private_function();
}
```

编译库：

```bash
$ rustc --crate-type=lib lib.rs
$ ls *.rlib
liblib.rlib
```



## 2.2 使用库

```rust
fn main() {
    lib::public_function();

    lib::indirect_access();
}
```

编译可执行文件：

```bash
$ rustc main.rs --extern lib=liblib.rlib --edition=2021

$ .\main.exe
called lib's `public_function()`
called lib's `indirect_access()`, that
>called lib's `private_function()`
```



## 1.3 use

use 声明，可以将一个完整的路径绑定到一个新的名字，使其更容易访问

```rust
fn function() {
    println!("called `function()`");
}

mod deeply {
    pub mod nested {
        pub fn function() {
            println!("called `deeply::nested::function()`");
        }
    }
}

use deeply::nested::function as other_function;

fn main() {
    other_function();

    {
        println!("entering block");

        use deeply::nested::function;
        function();

        println!("leaving block");
    }

    function();
}
```





# 3. 属性

属于是应用于某些模块、crate或项的元数据 (metadata):

- 条件编译代码
- 设置 crate 名称、版本即类型 (bin/lib)
- 禁用 lint 警告
- 启用编译前特性 (宏、全局导入等)

- 链接到一个非 Rust 语言库
- 标记函数作为单元测试
- 标记函数作为基准测试的某部分

根据作用域范围的两种属性语法：

- `#![crate_attribute]`：属性对整个 crate 有效
- `#[item_attribute]`：属性对特定的模块或项有效

属性参数语法：

```rust
#[attribute = "value"]
#[attribute(key = "value")]
#[attribute(value)]

// 多值属性
#[attribute(value1, value2)]
#[attribute(value1, value2, value3, value4, value5)]
```



## 3.1 dead_code

`dead_code` 属性，禁用 lint 对未使用的函数产生警告

```rust
#allow(dead_code)
fn unused_func() {}
```



## 3.2 crate

`crate_type` 属性告知编译器该 crate 是二进制可执行文件还是库

`crate_name` 属性设置 crate 的名称

但由于大多数Rust工程使用 cargo，这两个属性用处不大

```rust
#![crate_type = "lib"]
#![crate_name = "rary"]

pub fn public_function() {
    println!("called rary's `public_function()`");
}

fn private_function() {
    println!("called rary's `private_function()`");
}

pub fn indirect_access() {
    print!("called rary's `indirect_access()`, that\n> ");

    private_function();
}
```

编译：

```bash
# 无需指定 --crate-type=lib 参数
rustc lib.rs
```



## 3.3 cfg

条件编译的两种实现：

- `属性 #[cfg(...)]`：在属性位置中使用
- `宏 cfg!(...)`：在布尔表达式中使用

```rust
#[cfg(target_os = "linux")]
fn are_you_on_linux() {
    println!("Yes, I'm on linux");
}

#[cfg(not(target_os = "linux"))]
fn are_you_on_linux() {
    println!("No, I'm not on linux");
}

fn main() {
    are_you_on_linux();

    println!("What about your arch?");
    if cfg!(target_arch = "x86_64") {
        println!("x86_64")
    } else {
        println!("not x86_64");
    }
}
```

自定义条件：`target_os` 由 rustc 隐式提供，可通过 `--cfg` 标记传递自定义条件给 rustc

```rust
#[cfg(some_condition)]
fn conditional_function() {
    println!("condition met!");
}

fn main() {
    conditional_function();
}
```

编译时，满足条件：

```bash
rustc --cfg=some_condition .\main.rs
```



































