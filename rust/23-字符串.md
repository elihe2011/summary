# 1. åŸºç¡€çŸ¥è¯†

Rust ä¸­ä¸¤ç§å­—ç¬¦ä¸²ï¼š

- strï¼šåŸç”Ÿå­—ç¬¦ä¸²åˆ‡ç‰‡ç±»å‹ï¼Œå®ƒè¡¨ç¤º UTF-8 ç¼–ç çš„å­—ç¬¦åºåˆ—ã€‚ä¸ String çš„åŒºåˆ«åœ¨äºï¼Œstr æ˜¯ä¸å¯å˜åˆ‡ç‰‡
- Stringï¼šå¯å¢é•¿çš„å †åˆ†é…å­—ç¬¦ä¸²



## 1.1 åŸºæœ¬æ“ä½œ

```rust
fn str_basic_op() {
    let s = "hello, ä½ å¥½";
    
    // é•¿åº¦
    println!("å­—èŠ‚æ•°ï¼š{}", s.len());           // 13
    println!("å­—ç¬¦æ•°ï¼š{}", s.chars().count()); // 9
    
    // åˆ‡ç‰‡ï¼šå¿…é¡»å¼•ç”¨
    let s1 = &s[..5];  // or [0..5]
    println!("s1: {}", s1); // hello
    
    // UTF-8è¶Šç•Œ, ä¸­æ–‡3ä¸ªå­—èŠ‚
    let s2 = &s[7..9]; 
    println!("s2: {}", s2);  // panic 'ä½ ' (bytes 7..10)
}
```



## 1.2 è¿­ä»£æ“ä½œ

```rust
fn str_iter_op() {
    let s = "Rustä¸­æ–‡";
    
    // å­—èŠ‚è¿­ä»£
    for c in s.chars() {
        print!("{} ", c);
    }
    println!();
    
    // å­—ç¬¦è¿­ä»£
    for b in s.bytes() {
        print!("{:#x} ", b);
    }
    println!();
    
    // å­—ç¬¦èµ·å§‹ä½ç½®
    for (i, c) in s.char_indices() {
        println!("{}: {}", i, c);
    }
}
```



# 2. é«˜çº§ç‰¹æ€§

## 2.1 æ¨¡å¼åŒ¹é…

```rust
fn str_pattern_matching() {
    let s = "Rust is Awesome!";
    
    // å‰ç¼€åç¼€
    assert!(s.starts_with("Rust"));
    assert!(s.ends_with("!"));
    
    // åŒ…å«
    assert!(s.contains("is"));
    
    // ä½ç½®
    assert_eq!(s.find("is"), Some(5));
    assert_eq!(s.find("was"), None);
    
    // é«˜çº§åŒ¹é…
    let matches: Vec<&str> = s.matches(char::is_uppercase).collect();
    println!("å¤§å†™å­—æ¯ï¼š{:?}", matches); // ["R", "A"]
    
    // åˆ†å‰²
    let words: Vec<&str> = s.split_whitespace().collect();
    println!("å•è¯ï¼š{:?}", words);  // ["Rust", "is", "Awesome!"]
}
```



## 2.2 Unicode è§„èŒƒåŒ–

`unicode-normalization` åº“æä¾›äº†ä¸€ç§ç®€å•çš„æ–¹å¼æ¥å¤„ç†Unicodeå­—ç¬¦ä¸²çš„è§„èŒƒåŒ–ã€‚è¯¥åº“å›´ç»•ç€Unicodeå­—ç¬¦çš„ç»„åˆï¼ˆcompositionï¼‰å’Œåˆ†è§£ï¼ˆdecompositionï¼‰ï¼Œé€šè¿‡çµæ´»ä¸”é«˜æ•ˆçš„APIå®ç°äº†å¯¹å­—ç¬¦æ“ä½œçš„æ”¯æŒã€‚é‡è¦çš„æ˜¯ï¼Œå®ƒå®Œå…¨å…¼å®¹`no_std`å’Œ`alloc`

å­—ç¬¦ä¸²è§„èŒƒåŒ–ï¼š

- NFCï¼šè§„èŒƒåŒ–ç»„åˆå‹ï¼Œå¦‚ `Ã©` æ˜¯ä¸€ä¸ªå­—ç¬¦ã€‚Windows (NFS) å’Œ Linux(ext4) å¸¸ç”¨ NFC å­˜å‚¨æ–‡ä»¶å
- NFDï¼šè§„èŒƒåŒ–åˆ†è§£å‹ï¼Œå¦‚ `Ã©` æ˜¯ä¸¤ä¸ªå­—ç¬¦ `e` å’Œ `Â´`ã€‚MacOS ï¼ˆHFS / APFS) å¸¸ç”¨ NFD å­˜å‚¨æ–‡ä»¶å
- NFKCï¼šå…¼å®¹æ€§ NFC
- NFKDï¼šå…¼å®¹æ€§ NFD

```rust
use unicode_normalization::UnicodeNormalization;

fn unicode_handle() {
    // NFC
    let french = "raison d'Ãªtre";
    let normalized = french.nfc().collect::<String>();
    println!("normalized: {:?}", normalized);
    
    let unicode_str = "ä½ å¥½\u{200D}ğŸ‘¨ğŸ‘©";
    let nfc_str = unicode_str.nfc().collect::<String>();
    println!("nfc_str: {}", nfc_str); // "ä½ å¥½â€ğŸ‘¨ğŸ‘©"
    
    // å¤§å°å†™è½¬æ¢
    let s = french.to_uppercase();
    println!("{}", s);
    
    // é¦–å­—æ¯å¤§å†™
    let title_case = french.chars()
        .enumerate()
        .map(|(i, c)| {
            if i == 0 { c.to_uppercase().next().unwrap() }
            else { c.to_lowercase().next().unwrap() }
        })
        .collect::<String>();
    println!("{}", title_case);
}
```



# 3. æ€§èƒ½ä¼˜åŒ–

## 3.1 å­—ç¬¦ä¸²æœç´¢

```rust
fn efficient_search() {
    let haystack = "This is a very long text that we want to search through efficiently!";
    let needle = "efficiently";
    
    // å¸¸è§„æœç´¢
    if let Some(pos) = haystack.find(needle) {
        println!("Found at position: {}", pos);
    }
    
    // Boyer-Mooreç®—æ³•
    use memchr::memmem; // 2.7.4
    let finder = memmem::Finder::new(needle);
    if let Some(pos) = finder.find(haystack.as_bytes()) {
        println!("Found at position (fast): {}", pos);
    }
}
```



## 3.2 å­—ç¬¦ä¸²æ‹¼æ¥

```rust
fn str_concatenation() {
    let arr = vec!["hello", " ", "world", "!"];
    
    // ä½æ•ˆ
    let mut result = String::new();
    for s in &arr {
        result.push_str(s);
    }
    println!("{}", result);
    
    // é«˜æ•ˆï¼šé¢„åˆ†é…ç©ºé—´
    let length = arr.iter().map(|s| s.len()).sum();
    let mut result = String::with_capacity(length);
    for s in &arr {
        result.push_str(s);
    }
    println!("{}", result);
    
    // æœ€é«˜æ•ˆï¼šjoin
    let result = arr.join("");
    println!("{}", result);
}
```



# 4. åº”ç”¨æ¡ˆä¾‹

## 4.1 å­—ç¬¦ä¸²åˆ†æå™¨

```rust
struct StringAnalyzer<'a> {
    content: &'a str,
}

impl<'a> StringAnalyzer<'a> {
    fn new(content: &'a str) -> Self {
        Self { content }
    }
    
    fn word_frequency(&self) -> std::collections::HashMap<&str, usize> {
        let mut freq = std::collections::HashMap::new();
        for word in self.content.split_whitespace() {
            *freq.entry(word).or_insert(0) += 1;
        }
        freq
    }
    
    fn longest_word(&self) -> Option<&str> {
        self.content
            .split_whitespace()
            .max_by_key(|word| word.len())
    }
    
    fn character_stats(&self) -> (usize, usize, usize) {
        let mut letters = 0;
        let mut digits = 0;
        let mut whitespaces = 0;
        
        for c in self.content.chars() {
            match c {
                c if c.is_alphabetic() => letters += 1,
                c if c.is_numeric() => digits += 1,
                c if c.is_whitespace() => whitespaces += 1,
                _ => {},
            }
        }
        
        (letters, digits, whitespaces)
    }
}
```



## 4.2 å­—ç¬¦ä¸²æ± 

```rust
use std::collections::HashMap;
use std::rc::Rc;

struct StringPool {
    strings: HashMap<String, Rc<str>>,
}

impl StringPool {
    fn new() -> Self {
        Self { 
            strings: HashMap::new(),
        }
    }
    
    fn intern(&mut self, s: &str) -> Rc<str> {
        if let Some(interned) = self.strings.get(s) {
            Rc::clone(interned)
        } else {
            let rc = Rc::from(s.to_string());
            self.strings.insert(s.to_string(), Rc::clone(&rc));
            rc
        }
    }
}
```



# 5. æ€§èƒ½é™·é˜±

## 5.1 UTF-8é™·é˜±

```rust
fn utf8_pitfall() {
    let s = "Rust ä¸­æ–‡";
    
    // é”™è¯¯ç¤ºèŒƒï¼šç›´æ¥å­—èŠ‚ç´¢å¼•
    // let first_char = s[0];
    
    // æ­£ç¡®ç¤ºèŒƒï¼šchars().next()
    let first_char = s.chars().next().unwrap();
    println!("{}", first_char);
    
    // æ€§èƒ½è€ƒè™‘ï¼šéœ€è¦é¢‘ç¹è®¿é—®å­—ç¬¦æ—¶
    let chars: Vec<char> = s.chars().collect();
    let first_char = chars[2];
    println!("{}", first_char);
}
```



## 5.2 å†…å­˜ä¼˜åŒ–

```rust
fn memory_optimization() {
    let s = "hello world!";
    
    // è¾ƒå·®ï¼šåˆ›å»ºæ–°Stringï¼Œå †ä¸Šæ“ä½œ
    let s1 = s.to_string().to_uppercase();
    println!("{}", s1);
    
    // è¾ƒå¥½ï¼šç›´æ¥æ ˆä¸Šæ“ä½œ
    for c in s.chars().map(|c| c.to_uppercase()) {
        print!("{}", c);
    }
}
```

































