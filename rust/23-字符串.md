# 1. åŸºç¡€çŸ¥è¯†

Rust ä¸­ä¸¤ç§å­—ç¬¦ä¸²ï¼š

- strï¼šåŸç”Ÿå­—ç¬¦ä¸²åˆ‡ç‰‡ç±»å‹ï¼Œå®ƒè¡¨ç¤º UTF-8 ç¼–ç çš„å­—ç¬¦åºåˆ—ã€‚ä¸ String çš„åŒºåˆ«åœ¨äºï¼Œstr æ˜¯ä¸å¯å˜åˆ‡ç‰‡
- Stringï¼šå¯å¢é•¿çš„å †åˆ†é…å­—ç¬¦ä¸²



## 1.1 åŸºæœ¬æ“ä½œ

```rust
fn str_basic_op() {
    let s = "hello, ä½ å¥½";
    
    // é•¿åº¦
    println!("å­—èŠ‚æ•°ï¼š{}", s.len());           // 13
    println!("å­—ç¬¦æ•°ï¼š{}", s.chars().count()); // 9
    
    // åˆ‡ç‰‡ï¼šå¿…é¡»å¼•ç”¨
    let s1 = &s[..5];  // or [0..5]
    println!("s1: {}", s1); // hello
    
    // UTF-8è¶Šç•Œ, ä¸­æ–‡3ä¸ªå­—èŠ‚
    let s2 = &s[7..9]; 
    println!("s2: {}", s2);  // panic 'ä½ ' (bytes 7..10)
}
```



## 1.2 è¿­ä»£æ“ä½œ

```rust
fn str_iter_op() {
    let s = "Rustä¸­æ–‡";
    
    // å­—èŠ‚è¿­ä»£
    for c in s.chars() {
        print!("{} ", c);
    }
    println!();
    
    // å­—ç¬¦è¿­ä»£
    for b in s.bytes() {
        print!("{:#x} ", b);
    }
    println!();
    
    // å­—ç¬¦èµ·å§‹ä½ç½®
    for (i, c) in s.char_indices() {
        println!("{}: {}", i, c);
    }
}
```



# 2. é«˜çº§ç‰¹æ€§

## 2.1 æ¨¡å¼åŒ¹é…

```rust
fn str_pattern_matching() {
    let s = "Rust is Awesome!";
    
    // å‰ç¼€åç¼€
    assert!(s.starts_with("Rust"));
    assert!(s.ends_with("!"));
    
    // åŒ…å«
    assert!(s.contains("is"));
    
    // ä½ç½®
    assert_eq!(s.find("is"), Some(5));
    assert_eq!(s.find("was"), None);
    
    // é«˜çº§åŒ¹é…
    let matches: Vec<&str> = s.matches(char::is_uppercase).collect();
    println!("å¤§å†™å­—æ¯ï¼š{:?}", matches); // ["R", "A"]
    
    // åˆ†å‰²
    let words: Vec<&str> = s.split_whitespace().collect();
    println!("å•è¯ï¼š{:?}", words);  // ["Rust", "is", "Awesome!"]
}
```



## 2.2 Unicode è§„èŒƒåŒ–

`unicode-normalization` åº“æä¾›äº†ä¸€ç§ç®€å•çš„æ–¹å¼æ¥å¤„ç†Unicodeå­—ç¬¦ä¸²çš„è§„èŒƒåŒ–ã€‚è¯¥åº“å›´ç»•ç€Unicodeå­—ç¬¦çš„ç»„åˆï¼ˆcompositionï¼‰å’Œåˆ†è§£ï¼ˆdecompositionï¼‰ï¼Œé€šè¿‡çµæ´»ä¸”é«˜æ•ˆçš„APIå®ç°äº†å¯¹å­—ç¬¦æ“ä½œçš„æ”¯æŒã€‚é‡è¦çš„æ˜¯ï¼Œå®ƒå®Œå…¨å…¼å®¹`no_std`å’Œ`alloc`

å­—ç¬¦ä¸²è§„èŒƒåŒ–ï¼š

- NFCï¼šè§„èŒƒåŒ–ç»„åˆå‹ï¼Œå¦‚ `Ã©` æ˜¯ä¸€ä¸ªå­—ç¬¦ã€‚Windows (NFS) å’Œ Linux(ext4) å¸¸ç”¨ NFC å­˜å‚¨æ–‡ä»¶å
- NFDï¼šè§„èŒƒåŒ–åˆ†è§£å‹ï¼Œå¦‚ `Ã©` æ˜¯ä¸¤ä¸ªå­—ç¬¦ `e` å’Œ `Â´`ã€‚MacOS ï¼ˆHFS / APFS) å¸¸ç”¨ NFD å­˜å‚¨æ–‡ä»¶å
- NFKCï¼šå…¼å®¹æ€§ NFC
- NFKDï¼šå…¼å®¹æ€§ NFD

```rust
use unicode_normalization::UnicodeNormalization;

fn unicode_handle() {
    // NFC
    let french = "raison d'Ãªtre";
    let normalized = french.nfc().collect::<String>();
    println!("normalized: {:?}", normalized);
    
    let unicode_str = "ä½ å¥½\u{200D}ğŸ‘¨ğŸ‘©";
    let nfc_str = unicode_str.nfc().collect::<String>();
    println!("nfc_str: {}", nfc_str); // "ä½ å¥½â€ğŸ‘¨ğŸ‘©"
    
    // å¤§å°å†™è½¬æ¢
    let s = french.to_uppercase();
    println!("{}", s);
    
    // é¦–å­—æ¯å¤§å†™
    let title_case = french.chars()
        .enumerate()
        .map(|(i, c)| {
            if i == 0 { c.to_uppercase().next().unwrap() }
            else { c.to_lowercase().next().unwrap() }
        })
        .collect::<String>();
    println!("{}", title_case);
}
```



# 3. æ€§èƒ½ä¼˜åŒ–

## 3.1 å­—ç¬¦ä¸²æœç´¢

```rust
fn efficient_search() {
    let haystack = "This is a very long text that we want to search through efficiently!";
    let needle = "efficiently";
    
    // å¸¸è§„æœç´¢
    if let Some(pos) = haystack.find(needle) {
        println!("Found at position: {}", pos);
    }
    
    // Boyer-Mooreç®—æ³•
    use memchr::memmem; // 2.7.4
    let finder = memmem::Finder::new(needle);
    if let Some(pos) = finder.find(haystack.as_bytes()) {
        println!("Found at position (fast): {}", pos);
    }
}
```



## 3.2 å­—ç¬¦ä¸²æ‹¼æ¥

```rust
fn str_concatenation() {
    let arr = vec!["hello", " ", "world", "!"];
    
    // ä½æ•ˆ
    let mut result = String::new();
    for s in &arr {
        result.push_str(s);
    }
    println!("{}", result);
    
    // é«˜æ•ˆï¼šé¢„åˆ†é…ç©ºé—´
    let length = arr.iter().map(|s| s.len()).sum();
    let mut result = String::with_capacity(length);
    for s in &arr {
        result.push_str(s);
    }
    println!("{}", result);
    
    // æœ€é«˜æ•ˆï¼šjoin
    let result = arr.join("");
    println!("{}", result);
}
```



# 4. åº”ç”¨æ¡ˆä¾‹

## 4.1 å­—ç¬¦ä¸²åˆ†æå™¨

```rust
struct StringAnalyzer<'a> {
    content: &'a str,
}

impl<'a> StringAnalyzer<'a> {
    fn new(content: &'a str) -> Self {
        Self { content }
    }
    
    fn word_frequency(&self) -> std::collections::HashMap<&str, usize> {
        let mut freq = std::collections::HashMap::new();
        for word in self.content.split_whitespace() {
            *freq.entry(word).or_insert(0) += 1;
        }
        freq
    }
    
    fn longest_word(&self) -> Option<&str> {
        self.content
            .split_whitespace()
            .max_by_key(|word| word.len())
    }
    
    fn character_stats(&self) -> (usize, usize, usize) {
        let mut letters = 0;
        let mut digits = 0;
        let mut whitespaces = 0;
        
        for c in self.content.chars() {
            match c {
                c if c.is_alphabetic() => letters += 1,
                c if c.is_numeric() => digits += 1,
                c if c.is_whitespace() => whitespaces += 1,
                _ => {},
            }
        }
        
        (letters, digits, whitespaces)
    }
}
```



## 4.2 å­—ç¬¦ä¸²æ± 

```rust
use std::collections::HashMap;
use std::rc::Rc;

struct StringPool {
    strings: HashMap<String, Rc<str>>,
}

impl StringPool {
    fn new() -> Self {
        Self { 
            strings: HashMap::new(),
        }
    }
    
    fn intern(&mut self, s: &str) -> Rc<str> {
        if let Some(interned) = self.strings.get(s) {
            Rc::clone(interned)
        } else {
            let rc = Rc::from(s.to_string());
            self.strings.insert(s.to_string(), Rc::clone(&rc));
            rc
        }
    }
}
```



# 5. æ€§èƒ½é™·é˜±

## 5.1 UTF-8é™·é˜±

```rust
fn utf8_pitfall() {
    let s = "Rust ä¸­æ–‡";
    
    // é”™è¯¯ç¤ºèŒƒï¼šç›´æ¥å­—èŠ‚ç´¢å¼•
    // let first_char = s[0];
    
    // æ­£ç¡®ç¤ºèŒƒï¼šchars().next()
    let first_char = s.chars().next().unwrap();
    println!("{}", first_char);
    
    // æ€§èƒ½è€ƒè™‘ï¼šéœ€è¦é¢‘ç¹è®¿é—®å­—ç¬¦æ—¶
    let chars: Vec<char> = s.chars().collect();
    let first_char = chars[2];
    println!("{}", first_char);
}
```



## 5.2 å†…å­˜ä¼˜åŒ–

```rust
fn memory_optimization() {
    let s = "hello world!";
    
    // è¾ƒå·®ï¼šåˆ›å»ºæ–°Stringï¼Œå †ä¸Šæ“ä½œ
    let s1 = s.to_string().to_uppercase();
    println!("{}", s1);
    
    // è¾ƒå¥½ï¼šç›´æ¥æ ˆä¸Šæ“ä½œ
    for c in s.chars().map(|c| c.to_uppercase()) {
        print!("{}", c);
    }
}
```



# 6. SmallVec

## 6.1 SmallVec è®¾è®¡

SmallVec æ˜¯ smallvec crate æä¾›çš„ä¸€ç§æ•°æ®ç»“æ„ï¼Œæ—¨åœ¨é€šè¿‡æ ˆåˆ†é…ä¼˜åŒ–å°å‹å‘é‡çš„å­˜å‚¨ï¼ŒåŒæ—¶åœ¨æ•°æ®é‡è¾ƒå¤§æ—¶æ— ç¼åˆ‡æ¢åˆ°å †åˆ†é…ã€‚è¿™ç§æ··åˆå­˜å‚¨æ–¹å¼ç±»ä¼¼äºå­—ç¬¦ä¸²ä¸­çš„â€œå°å‹å­—ç¬¦ä¸²ä¼˜åŒ–â€ (Small String Optimization, SSO)ï¼Œèƒ½å¤Ÿæ˜¾è‘—é™ä½å°å‹æ•°æ®é›†çš„å †åˆ†é…å¼€é”€ã€‚

- **ç»“æ„**ï¼š`SmallVec<[T; N]>` æœ€å¤šå¯åœ¨æ ˆä¸Šå­˜å‚¨ N ä¸ªç±»å‹ä¸º T çš„å…ƒç´ ã€‚å½“å…ƒç´ æ•°é‡è¶…è¿‡ N æ—¶ï¼Œæ•°æ®ä¼šæº¢å‡ºåˆ°å †ä¸Šï¼Œè¡Œä¸ºç±»ä¼¼äºæ ‡å‡† `Vec<T>`
- **å…³é”®ç‰¹æ€§**ï¼š
  - å®ç°äº† `Deref` å’Œ `DerefMut`ï¼Œå¯è½¬æ¢ä¸º `&[T]` å’Œ `&mut [T]`ï¼Œæ”¯æŒåˆ‡ç‰‡æ“ä½œ
  - æ”¯æŒå¸¸è§çš„ `Vec` æ“ä½œï¼Œå¦‚ `push`ã€`pop`ã€`insert` å’Œ `remove`
- ä½¿ç”¨åœºæ™¯ï¼šé€‚ç”¨äºé›†åˆé€šå¸¸è¾ƒå°ï¼ˆä¾‹å¦‚1-8ä¸ªå…ƒç´ ï¼‰ä¸”å †åˆ†é…æˆæœ¬è¾ƒé«˜çš„åœºæ™¯ï¼Œå¦‚æ€§èƒ½æ•æ„Ÿçš„ç³»ç»Ÿæˆ–åµŒå…¥å¼ç¯å¢ƒ

```rust
use smallvec::SmallVec;

fn main() {
    let mut sv: SmallVec<[i32; 4]> = SmallVec::new();
    sv.push(1);
    sv.push(2);
    
    assert_eq!(sv.len(), 2);
    assert!(!sv.spilled());   // åœ¨æ ˆä¸Š
    
    sv.extend_from_slice(&[3, 4, 5]);
    assert!(sv.spilled());  // åˆ‡æ¢åˆ°å †ä¸Š
}
```



## 6.2 String è®¾è®¡

String æ˜¯ Rust æ ‡å‡†åº“ä¸­ç”¨äºå­˜å‚¨å’Œæ“ä½œ UTF-8 ç¼–ç æ–‡æœ¬çš„å¯å¢é•¿å­—ç¬¦ä¸²ç±»å‹ï¼ŒåŸºäº `Vec<u8>` å®ç°ï¼Œå¹¶ä¿è¯æ•°æ®çš„ UTF-8 åˆæ³•æ€§ã€‚

- ç»“æ„ï¼šString å†…éƒ¨æ˜¯å¯¹ `Vec<u8>` çš„å°è£…ï¼Œé™„åŠ äº† UTF-8 ç¼–ç çš„çº¦æŸ
- å…³é”®ç‰¹æ€§ï¼š
  - å®ç°äº† `Deref`ï¼Œå¯ä»¥è½¬æ¢ä¸º `&str`ï¼Œä¾¿äºå­—ç¬¦ä¸²åˆ‡ç‰‡æ“ä½œ
  - æ”¯æŒ `push`ï¼Œ`push_str`ï¼Œ`insert` å’Œ `clear` ç­‰æ“ä½œ
- ä½¿ç”¨åœºæ™¯ï¼šé€‚åˆåŠ¨æ€æ–‡æœ¬å¤„ç†ï¼Œä¾‹å¦‚æ‹¼æ¥å­—ç¬¦ä¸²ã€å¤„ç†ç”¨æˆ·è¾“å…¥æˆ–ç”Ÿæˆæ ¼å¼åŒ–è¾“å‡º

```rust
fn main() {
    let mut s = String::from("Hello");
    s.push_str(", World!");
    assert_eq!(s, "Hello, World!");
}
```



## 6.3 å¯¹æ¯”åˆ†æ

ç›¸ä¼¼ä¹‹å¤„ï¼š

- åŠ¨æ€å¢é•¿ï¼š`SmallVec` å’Œ `String` éƒ½ä¹‹å¤„åŠ¨æ€è°ƒæ•´å¤§å°ï¼ŒæŒ‰éœ€æ‰©å±•å®¹é‡
- å †åˆ†é…ï¼šä¸¤è€…åœ¨å®¹é‡ä¸è¶³æ—¶éƒ½ä¼šä½¿ç”¨å †åˆ†é… (`SmallVec` åœ¨è¶…è¿‡å†…è”å®¹é‡æ—¶ï¼Œ`String` å§‹ç»ˆä½¿ç”¨å †)
- å†…å­˜å®‰å…¨ï¼šä¸¤è€…éƒ½éµå¾ª Rust çš„å®‰å…¨ä¿è¯ï¼Œé¿å…æ— æ•ˆå†…å­˜è®¿é—®æˆ–æœªå®šä¹‰è¡Œä¸º
- `Deref`æ”¯æŒï¼šä¸¤è€…å‡å®ç°äº† `Deref`ï¼Œä¾¿äºè®¿é—®åº•å±‚æ•°æ®(`SmallVec` ä¸º `&[T]`ï¼Œ`String` ä¸º `&str`)



ä¸åŒä¹‹å¤„ï¼š

| ç‰¹æ€§           | SmallVec              | String                     |
| -------------- | --------------------- | -------------------------- |
| **ç”¨é€”**       | é€šç”¨å°å‹å‘é‡          | UTF-8 ç¼–ç çš„æ–‡æœ¬           |
| **å­˜å‚¨æ–¹å¼**   | æ ˆ (æœ€å¤šNä¸ªå…ƒç´ ) æˆ–å † | å§‹ç»ˆåœ¨å †ä¸Š (é€šè¿‡`Vec<u8>`) |
| **ç±»å‹çµæ´»æ€§** | æ³›å‹ (T)              | å›ºå®šä¸º u8 (UTF-8 å­—èŠ‚)     |
| **ä¼˜åŒ–ç­–ç•¥**   | å°å‹å­—ç¬¦ä¸²ä¼˜åŒ–        | æ— å†…è”å­˜å‚¨                 |
| **API**        | ç±»å‹å‘é‡ (push, pop)  | å­—ç¬¦ä¸²ä¸“ç”¨ (push_str)      |
| **ä½¿ç”¨åœºæ™¯**   | æ€§èƒ½æ•æ„Ÿçš„å°å‹é›†åˆ    | æ–‡æœ¬å¤„ç†                   |



## 6.4 å®é™…åº”ç”¨

### 6.4.1 SmallVec è§£æä»¤ç‰Œ

åœ¨ç¼–è¯‘å™¨æˆ–è§£é‡Šå™¨çš„ä»¤ç‰Œè§£æåœºæ™¯ä¸­ï¼Œè¡¨è¾¾å¼é€šå¸¸åŒ…å«å°‘é‡ä»¤ç‰Œï¼Œ`SmallVec` æ˜¯ç†æƒ³é€‰æ‹©

```rust
use smallvec::SmallVec;

fn parse_tokens(input: &str) -> SmallVec<[&str; 8]> {
    let mut tokens: SmallVec<[&str; 8]> = SmallVec::new();
    for token in input.split_whitespace() {
        tokens.push(token);
    }
    
    tokens
}

fn main() {
    let tokens = parse_tokens("let x = 42");
    assert_eq!(tokens, &["let", "x", "=", "42"]);
}
```



### 6.4.2 String ç”Ÿæˆ CSVè¡Œ

åœ¨åŠ¨æ€ç”Ÿæˆ CSV æ•°æ®æ—¶ï¼Œ`String` é€‚åˆæ‹¼æ¥å­—æ®µ

```rust
fn build_csv_row(fields, &[&str]) -> String {
    let mut row = String::new();
    for (i, field) in fields.iter().enumerate() {
        if i > 0 {
            row.push(',');
        }
        row.push_str(feild);
    }
    row
}

fn  main() {
    let row = build_csv_row(&["Alice", "25", "Engineer"]);
    assert_eq!(row, "Alice,25,Engineer");
}
```



### 6.4.3 ç»“åˆä½¿ç”¨

ä¸€ä¸ªæ—¥å¿—è§£æå™¨å¯èƒ½ä½¿ç”¨ `SmallVec` å­˜å‚¨æ—¥å¿—çº§åˆ«ï¼Œ`String` å­˜å‚¨æ¶ˆæ¯å†…å®¹

```rust
use smallvec::SmallVec;

struct LogEntry {
    levels: SmallVec<[&str; 4]>,
    message: String,
}

fn create_log_entry(levels: &[&str], msg: &str) -> LogEntry {
    LogEntry {
        levels: levels.iter().copied().collect(),
        message: msg_to_string(),
    }
}

fn main() {
    let entry = create_log_entry(&["INFO", "DEBUG"], "ç³»ç»Ÿå¯åŠ¨");
    assert_eq!(entry.levels.len(), 2);
    assert_eq!(entry.message, "ç³»ç»Ÿå¯åŠ¨");
}
```





























