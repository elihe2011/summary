# 1. 宏 Macro

宏系统允许开发者编写代码来生成其它代码，也称*元编程* (meta programming)。与函数不同，宏在编译时展开，这意味着它们可以用来减少重复代码、实现编译时检查、创建领域特定语言 (DSL) 等。

函数签名必须声明函数具有的参数数量和类型。宏可以采用可变数量的参数：可以使用一个参数调用 `println!("hello")` 或使用两个参数调用 `println!("hello {}", name)`。此外，宏在编译器解释代码含义之前会进行扩展，因此宏可以例如在给定类型上实现特征。函数不能，因为它在运行时被调用，并且特征需要在编译时实现。

**宏不产生函数调用，而是展开成源码，并和程序的其余部分一起被编译**。

Rust 的宏与 C 不同之处在于，**Rust的宏会展开成抽象语法树 (AST, abstract syntax tree)**，而不是像字符串预处理那样直接替换成代码，这样就不会产生无法预料的优先权错误。

Rust 中的两类宏：

- **声明式宏 (*Declarative Macros*)**  `macro_rules!`
- **过程宏 (*Procedural Macros*)**
  - **派生宏 (Derive Macros)**：通过 `#[derive]` 为目标结构体或枚举派生指定的代码，如 Debug 特征
  - **属性宏 (Attribute Macros)**：为目标添加自定义属性
  - **函数式宏 (Function-like Macros)**：类似函数调用



适用场景：

- 快速生成样板代码，如 `println!`、`vec!`
- 实现特定领域的 DSL (领域特定语言)
- 自动实现 trait，如 `#[derive(Debug)]`
- 简化复杂逻辑或配置



# 2. 声明式宏

声明式宏 `macro_rules!` 类似 match：

```rust 
macro_rules! macro_name {
    (pattern) => (expansion);
}
```

宏将一个值跟对应的模式进行匹配，且该模式会与特定的代码相关联。与 `match` 不同的是，**宏里的值是一段 Rust 源代码(字面量)**，模式用于跟这段源代码的结构相比较，一旦匹配，传入宏的那段源码将被模式关联的代码所替换，最终实现宏展开。**所有的这些都是在编译期发生，并没有运行期的性能损耗**。



声明式宏的参数可以使用 `()` 、`[]` 及 `{}`：

```rust
fn main() {
    println!("a");
    println!["b"];
    println!{"c"};
}
```



示例1：**日志记录宏**

```rust
macro_rules! log {
    ($msg:expr) => {
        println!("{} - {}", chrono::Local::now().format("%Y-%m-%d %H:%M:%S"), $msg)
    };
}

// 调用示例
log!("程序开始运行！");
```



示例2：**自动生成 getter 方法**

```rust
macro_rules! create_getters {
    ($struct_name:ident, $($field_name:ident), *) => {
        impl $struct_name {
            $(
                pub fn $field_name(&self) -> &str {
                    &self.$field_name
                }
            )*
        }
    }
}

struct Person {
    name: String,
    age: u8,
    country: String,
}

fn main() {
    create_getters!(Person, name, country);

    let p = Person { name: "jack".to_string(), age: 18, country: "UK".to_string() };
    println!("{}, {}, {}", p.name(), p.age, p.country());
}
```



## 2.1 声明式宏基础

```rust
macro_rules! say_hello {
    () => {
        println!("Hello, Rust Macro!");
    };
}

// 调用示例
say_hello!();
```



## 2.2 带参数的声明式宏

声明式宏支持参数匹配，参数用 `$` 符号定义，并使用指示符 (designator) 来注明类型。

```rust
macro_rules! greet {
    ($name:expr) => {
        println!("Hello, {}!", $name);
    };
    ($name:expr, $times:expr) => {
        for _ in in..$times {
            println!("Hello, {}!", $name);
        }
    };
}

fn main() {
    greet!("Alice");
    greet!("Bob", 3);
}
```

指示符:

- `item`: an Item
- `block`: a `BlockExpression`
- `stmt`: a Statement without the trailing semicolon (except for item statements that require semicolons)
- `pat_param`: a `PatternNoTopAlt`
- `pat`: at least any `PatternNoTopAlt`, and possibly more depending on edition
- `expr`: an Expression
- `ty`: a Type
- `ident`: an IDENTIFIER_OR_KEYWORD or RAW_IDENTIFIER
- `path`: a `TypePath` style path
- `tt`: a *Token Tree*  (a single token] or tokens in matching delimiters `()`, `[]`, or `{}`)
- `meta`: an *Attribute*, the contents of an attribute
- `lifetime`: a LIFETIME_TOKEN]
- `vis`: a possibly empty *`Visibility`* qualifier
- `literal`: matches `-`? *`LiteralExpression`*



## 2.3 声明式宏的高级用法

### 2.3.1 复杂匹配

声明式宏支持。一个生成嵌套向量初始化的宏：

```rust
macro_rules! nvec {
    ($($x:expr),*) => {
        vec![$($x),*];
    };
    ($($x:expr,)*) => {
        nvec![$($x),*];
    };
    ($($x:expr),* ; $n:expr) => {
        vec![nvec![$($x),*]; $n];
    };
}


fn main() {
    let v1 = nvec![1, 2, 3];
    let v2 = nvec![1, 2, 3,];
    let v3 = nvec![1, 2, 3; 2];
    
    println!("{:?}", v1);  // [1, 2, 3]
    println!("{:?}", v2);  // [1, 2, 3]
    println!("{:?}", v3);  // [[1, 2, 3], [1, 2, 3]]
}
```



### 2.3.2 重载

宏可以重载，从而接受不同的参数组合

```rust
macro_rules! test {
    ( $left:expr; and $right:expr ) => {
        println!("{:?} and {:?} is {:?}", stringify!($left), stringify!($right), $left && $right);
    };

    ( $left:expr; or $right:expr ) => {
        println!("{:?} or {:?} is {:?}", stringify!($left), stringify!($right), $left || $right);
    };
}

fn main() {
    test!(1u32 + 1 == 2u32; and 2i32 * 2 == 4i32);
    test!(true; or false);
}
```



### 2.3.3 重复

宏在参数列表中参数出现的次数：

-  `+` 可能出现一次或多次
-  `*` 可能出现零次或多次

```rust 
macro_rules! find_min {
    ($x:expr) => ($x);
    
    ($x:expr, $($y:expr),+) => {
        std::cmp::min($x, find_min!($($y),+));
    };
}

fn main() {
    println!("{}", find_min!(1));
    println!("{}", find_min!(1+2, 0));
    println!("{}", find_min!(5, 6, 4));
}
```



## 2.4 声明式宏的用途

- 不写重复代码 (DRY, don't repeat yourself)
- 领域专用语言 (DSL, domain-specific language) ，允许为特定的目的创造特定的语法
- 可变接口 (variable interface)。能够接受不定数目参数的接口，比如 `println!` ，根据格式化字符串的不同，它需要接受任意多的参数。



### 2.4.1 DRY (不写重复代码)

通过提取函数或测试集的公共部分

```rust
use std::ops::{Add, Mul, Sub};

macro_rules! assert_equal_len {
    // `tt`（token tree，标记树）指示符表示运算符和标记。
    ( $a:ident, $b:ident, $func:ident, $op:tt ) => (
        assert!($a.len() == $b.len(),
                "{:?}: dimension mismatch: {:?} {:?} {:?}",
                stringify!($func),
                ($a.len(),),
                stringify!($op),
                ($b.len(),));
    )
}

macro_rules! op {
    ( $func:ident, $bound:ident, $op:tt, $method:ident ) => (
        fn $func<T: $bound<T, Output=T> + Copy>(xs: &mut Vec<T>, ys: &Vec<T>) {
            assert_equal_len!(xs, ys, $func, $op);

            for (x, y) in xs.iter_mut().zip(ys.iter()) {
                *x = $bound::$method(*x, *y);
                // *x = x.$method(*y);
            }
        }
    )
}

// 实现 `add_assign`、`mul_assign` 和 `sub_assign` 等函数。
op!(add_assign, Add, +=, add);
op!(mul_assign, Mul, *=, mul);
op!(sub_assign, Sub, -=, sub);

mod test {
    use std::iter;
    macro_rules! test {
        ( $func: ident, $x:expr, $y:expr, $z:expr ) => {
            #[test]
            fn $func() {
                for size in 0usize..10 {
                    let mut x: Vec<_> = iter::repeat($x).take(size).collect();
                    let y: Vec<_> = iter::repeat($y).take(size).collect();
                    let z: Vec<_> = iter::repeat($z).take(size).collect();

                    super::$func(&mut x, &y);

                    assert_eq!(x, z);
                }
            }
        }
    }

    // 测试 `add_assign`、`mul_assign` 和 `sub_assign`
    test!(add_assign, 1u32, 2u32, 3u32);
    test!(mul_assign, 2u32, 3u32, 6u32);
    test!(sub_assign, 3u32, 2u32, 1u32);
}
```



### 2.4.2 DSL (领域专用语言)

DSL 是 Rust 的宏中集成的微型“语言”，宏系统会把它转换成普通的 Rust 语法树，它只不过看起来是另一种语言。

```rust
macro_rules! calculate {
    (eval $e:expr) => {{
        {
            let val: usize = $e;  // 强制类型转换
            println!("{} = {}", stringify!($e), val);
        }
    }};
}

fn main() {
    calculate! {
        eval 1 + 2    // eval 并不是 rust 的关键字
    }

    calculate!(
        eval (1 + 2) * (3 / 4)
    );
}
```



### 2.4.3 可变参数接口

可变参数接口可以接受任意数量的参数。

```rust
macro_rules! calculate {
    (eval $x: expr) => {
        {
            let val: usize = $x;
            println!("{} = {}", stringify!($x), val);
        }
    };

    (eval $x: expr, $(eval $y: expr), +) => {
        {
            calculate!(eval $x);
            calculate!($(eval $y), +)
        }
    }
}

fn main() {
    calculate! {
        eval 1 + 2,
        eval 3 + 4,
        eval 2 * (3 + 1)
    };
}

// Output
1 + 2 = 3
3 + 4 = 7
2 * (3 + 1) = 8
```



## 2.5 示例：简化版的 `vec!`

```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
            	temp_vec.push($x);
            )*
            temp_vec
        }
    }
}
```



`( $( $x:expr ),* )` 解析：

- 最外层 `()` 将整个宏模式包裹其中
- `$()` 中包含的模式是 `$x:expr`，该模式中的 `expr` 表示会匹配任何 Rust 表达式，并给予该模式一个名称 `$x`
- 因此 `$x` 模式可以跟整数 `1` 进行匹配
- `$()` 之后的逗号`,`，意味着 `1` 和 `2` 之间可以使用逗号进行分割，也意味着 `3` 既可以没有逗号，也可使用逗号：`vec![1, 2, 3,]`
- `*` 说明之前的模式可以出现零次或任意多次，这里出现了三次。



模式相关联的代码：

- `$()` 中的 `temp_vec.push()` 将根据模式匹配的次数生成对应的代码
- `*` 匹配多数



# 3. 过程宏

过程宏是 Rust 宏系统的“告警魔法”，通过自定义函数处理代码的抽象语法树 (AST)。过程宏需要单独的 crate，并依赖 `proc-macro`、`sync` 、`quote` 等库。

过程宏有三种类型：

- **派生宏**：为结构体或枚举自动实现 trait
- **属性宏**：为代码块添加自定义属性
- **函数式宏**：类似声明宏，但更灵活

创建过程宏时，它的定义必须要放入一个独立的包中，且包的类型也是特殊的。原因在于**它必须先被编译后才能使用，如果过程宏和使用它的代码在一个包中，就必须先独立对过程宏的代码进行编译，然后再对业务代码进行编译，但 Rust 的编译单元是包，因为无法做到这一点**。



创建一个 `derive` 类型的过程宏：

```rust
use proc_macro;

#[proc_macro_derive(HelloMacro)]
pub fn some_name(input: TokenStream) -> TokenStream {}
```



## 3.1 派生宏

### 3.1.1 定义特征

Step 1: 创建一个库项目

```bash
cargo new hello-macro --lib
```



Step 2：定义特征

```rust
pub trait Hello {
    fn say_hello(&self);
}
```



### 3.1.2 定义派生宏

Step 1: 创建一个库项目

在上一个库项目下创建

```bash
cargo new hello-macro-derive --lib
```



Step 2：添加依赖

```toml
[dependencies]
syn = "2.0"
quote = "1.0"

[lib]
proc-macro = true
```



Step 3: 实现派生宏

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(Hello)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&ast)
}

fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let g = quote! {
        impl Hello for #name {
            fn say_hello(&self) {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    g.into()
}
```



### 3.1.3 使用派生宏

Step 1: 创建一个二进制项目

```bash
cargo new hello
```



Step 2: 添加依赖包

```toml
[dependencies]
hello-macro = { path = "../hello-macro" }
hello-macro-derive = { path = "../hello-macro/hello-macro-derive" }
```



Step 3: 使用过程宏

```rust
use hello_macro::Hello;
use hello_macro_derive::Hello;

#[derive(Hello)]
struct Person;

fn main() {
    let p = Person;
    p.say_hello();
}
```



## 3.2 类属性宏 

类属性过程宏与 derive 宏类似，但它允许定义资源的属性。除此之外，derive 只能用于结构体和枚举，而类属性宏可以用于其它类项，例如函数

```rust
#[route(GET, "/")]
fn index() {}
```



`#[route]` 属性是一个过程宏，其定义大概如下：

```rust
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokeStream {}
```



与 `derive` 宏不同，类属性宏的定义函数有两个参数：

- 第一个参数是属性，这里是 `Get, "/"` 
- 第二个参数是属性所标注的类型项，这里是 `fn index() {}` 整个函数体



## 3.3 类函数宏

类函数宏可以定义像函数那样调用的宏，它跟声明宏 `macro_rules` 较为类似。

区别在于，`macro_rules` 的定义形式与 `match` 匹配非常相像，而类函数宏的定义形式则类似derive宏和类属性宏

```rust
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {}
```

使用形式类似于函数调用：

```rust
let sql = sql!(SELECT * FROM posts WHERE id=1);
```



# 4. 调试宏

## 4.1 `cargo expand` 

```bash
cargo install cargo-expand
cargo expand
```

示例：一个声明式宏，用于生成键值对结构体

```rust
macro_rules! key_value {
    ($key:expr, $value:expr) => {
        #[derive(Debug)]
        struct Pair {
            key: String,
            value: $value,
        }
    };
}

key_value!("id", i32);

fn main() {
    let pair = Pair {
        key: "id".to_string(),
        value: 42,
    };
    println!("{:?}", pair);
}
```

通过 `cargo expand` 查询错误：

```
error: expected type, found expression `i32`
  --> src\main.rs:6:20
   |
4  |         struct Pair {
   |                ---- while parsing this struct
5  |             key: String,
6  |             value: $value,
   |                    ^^^^^^ expected type
...
11 | key_value!("id", i32);
   | --------------------- in this macro invocation
```

修复代码：通过**将 `$value:expr` 改为 `$value:ty`**，确保宏只接受合法的 Rust 类型

```rust
macro_rules! key_value {
    ($key:expr, $value:ty) => {
        #[derive(Debug)]
        struct Pair {
            key: String,
            value: $value,
        }
    };
}
```



## 4.2 log 和 eprintln!

过程宏运行在编译期，无法使用运行时调试器，但可以通过 `eprintln!` 输出调试信息

创建 `debug_macro` crate：

```rust
// Cargo.toml
[package]
name = "debug-macro"
version = "0.1.0"
edition = "2024"

[lib]
proc-macro = true

[dependencies]
proc-macro2 = "1.0"
quote = "1.0.40"
syn = { version = "2.0.106", features = ["full"] }


// src/lib.rs
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(DebugPrint)]
pub fn debug_print(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    eprintln!("Debug: Processing struct {}", quote!(#name).to_string());

    let expanded = quote! {
        impl #name {
            fn debug_print(&self) {
                println!("Debugging struct {}", stringify!(#name));
            }
        }
    };

    TokenStream::from(expanded)
}
```



使用宏：

```rust
// Cargo.toml
[package]
name = "marco-eprintln"
version = "0.1.0"
edition = "2024"

[dependencies]
debug-macro = { path = "./debug_macro" }

// src/main.rs
use debug_macro::DebugPrint;

#[derive(DebugPrint)]
struct MyStruct {}

fn main() {
    let s = MyStruct {};
    s.debug_print();
}
```



## 4.3 `syn::Error`

过程宏的错误信息对用户体验至关重要。下面时一个为结构体字段添加验证的派生宏，包含详细的错误处理：

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, Data, DeriveInput, Error, Fields};

#[proc_macro_derive(Validate)]
pub fn validate_derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;

    let fields = match input.data {
        Data::Struct(ref data) => match data.fields {
            Fields::Named(ref fields) => &fields.named,
            _ => {
                return Error::new_spanned(&input, "Only named fields are supported")
                    .to_compile_error()
                    .into();
            }
        },
        _ => {
            return Error::new_spanned(&input, "Only structs are supported")
                .to_compile_error()
                .into();
        }
    };

    let field_validations = fields.iter().map(|f| {
        let field_name = f.ident.as_ref().unwrap();
        quote! {
            if self.#field_name.is_empty() {
                return Err(format!("Field {} cannot be empty", stringify!(#field_name)));
            }
        }
    });

    let expanded = quote! {
        impl #name {
            fn validate(&self) -> Result<(), String> {
                #(#field_validations)*
                Ok(())
            }
        }
    };

    TokenStream::from(expanded)
}
```

使用宏：

```rust
use validate_macro::Validate;

#[derive(Validate)]
struct User {
    name: String,
    email: String,
}

fn main() {
    let user = User {
        name: "".to_string(),
        email: "test@example.com".to_string(),
    };

    match user.validate() {
        Ok(()) => println!("Validation passed"),
        Err(e) => println!("Validation failed: {}", e),
    }
}
```



## 4.4 总结

- `cargo-expand`：查看宏展开结果
- `sync` 和 `quote`：过程宏开发核心库
- `proc-macro2`：优化 `TokenStream` 处理

































