# 1. 使用场景

## 1.1 入参模式

```rust
nums.iter().fold(0, |acc, &x| acc ^ x)
```

- `iter()` 产生 `&i32`。`nums` 是 `vec` 类型，默认返回引用
- 闭包参数 `&x` 表示匹配到一个 `&i32`，把里面的 `i32` 绑定给 `x`
- 等价于 `|acc, x_ref| acc ^ *x_ref`

这是模式匹配的 **解构引用** 写法。



## 1.2 表达式

```rust
let a = 5;
let r: &i32 = &a;   // 取引用

fn foo(x: &i32) { println!("{}", x); }
let a = 8;
foo(&a);    // 取引用
```



## 1.3 模式匹配

闭包参数本质上也是模式匹配的一种，`&` 也可以出现在 `let / match` 等地方

```rust
let v = &5;

// 方式一：手动解引用
let x = *v;

// 方式二：模式匹配解引用
let &x = v;
```

在 match 中：

```rust
let r = &Some(10);

match r {
    &Some(x) => println!("value = {}", x),  // 模式匹配解引用
    _ => {}
}
```



# 2. 使用对比

| 语境   | 符合 | 含义         | 示例                 | 说明                               |
| ------ | ---- | ------------ | -------------------- | ---------------------------------- |
| 表达式 | &    | 取引用       | let r = &x;          | 从 x 创建一个引用 &T               |
|        | *    | 解引用       | let y = *r;          | 从 &T 或 &mut T 解出值             |
| 模式   | &    | 解构引用     | let &y = r;          | 从 T 中直接取值给 y                |
|        | *    | 解构智能指针 | let Box::new(y) = b; | 从 `Box<T>` 或解引用模式中直接取值 |



# 3. `vec` 和 `Box` 的 `&` 区别

## 3.1  `vec[index]` 得到的是一个引用，而不是值拷贝

```rust
impl<T> Index<usize> for Vec<T> {
    type Output = T;
    
    fn index(&self, index: usize) -> &Self::Output {
        // 返回 &T
    }
}
```



## 3.2 有的 `let val = nums[1]` 可直接得到值，而不需要解引用

原因：

- `nums[1]` 实际返回 `&i32`
- 但 `i32` 是 `Copy` 类型，编译器会自动把 `&i32` 解引用，并拷贝一份值出来

如果是 **非 Copy 类型**，如 String，则需要手动解引用：

```rust
fn main() {
    let v = vec![String::from("hello"), String::from("world")];
    
    // ❌ cannot move out of index of `Vec<String>`
    // let s = v[1];
    // println!("{}", s);  
    
    // ✅ :解引用
    let r: &String = &v[1];
    println!("{}", r);
    
    // ✅： 拷贝值
    let s: String = v[1].clone();
    println!("{}", s);
}
```



## 3.3 Box 是一个智能指针，它返回的确实是指针，一个“带所有权的堆指针”

Box 可以自动管理堆内存 (作用域结束时自动释放)，实现了 `Deref`，用起来像普通指针

```rust
let reader: Box<dyn Read> = if input == '-' {
    Box::new(std::io::stdin())
} else {
    Box::new(File::open(input)?)
}
```

不用 Box 的实现：

```rust
let stdin = std::io::stdin();
let file = File::open("foo.txt")?;

let reader: &dyn Read = &stdin;  // 或 &file
```

引用 `&T / &mut T`：指向栈或堆上的数据，但不拥有数据，生命周期受限。





























