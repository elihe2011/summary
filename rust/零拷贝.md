# 1. 零拷贝

零拷贝 (Zero-Copy) 技术的核心在于**避免数据在内存中的冗余复制**，尤其是在多个执行上下文 (如线程或任务) 之间传递数据时。

传统编程中，为保证数据安全，往往需要通过克隆或复制来传递值，但这在高频数据处理中，会导致严重的性能开销。**Rust 通过其所有权模型和生命周期检查，允许开发者在编译期就确保访问的安全性，从而能够在并发场景中安全地使用引用而非实际拷贝。**

这种方法不仅减少了内存分配和复制的开销，还提高了缓存利用率，因为相同的数据可以被多个执行流同时访问而不必复制多份。



# 2. 经典示例

## 2.1 借用而非克隆：广泛使用切片类型

在读取或解析数据时，常常需要从原始缓冲区中提取多个视图。例如，在解析网络协议或文件格式时，可以利用 `&[u8]` 和 `&str` 这类切片类型来创建数据的只读视图，而不必复制原始内容。

```rust
fn find_header<'a>(buf: &'a [u8], key: &str) -> Option<&'a [u8]> {
    let haystack = std::str::from_utf8(buf).ok()?;
    for line in haystack.split("\r\n") {
        if let Some((k, v)) = line.split_once(':') {
            if k.eq_ignore_ascii_case(key) {
                return Some(v.trim_start().trim_end().as_bytes());
            }
        }
    }

    None
}
```

底层调用：

```rust
// library (core/src/str/convert.rs)
pub const fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {
    // FIXME(const-hack): This should use `?` again, once it's `const`
    match run_utf8_validation(v) {
        Ok(_) => {
            // SAFETY: validation succeeded.
            Ok(unsafe { from_utf8_unchecked(v) })
        }
        Err(err) => Err(err),
    }
}

pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {
    // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.
    // Also relies on `&str` and `&[u8]` having the same layout.
    unsafe { mem::transmute(v) }
}

// library (core/src/intrinsics/mod.rs)
pub const unsafe fn transmute<Src, Dst>(src: Src) -> Dst;
```



## 2.2 `Arc<[T]>` 实现多线程数据共享

当多个线程需要访问同一份不可变数据时，可以使用 `Arc<[T]>` 来共享数据。与 `Arc<Vec<T>>` 相比，`Arc<[T]>` 更清晰地表达了数据的不可变性，并且具有切片的内存布局，无需额外的指针间接层。

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    let data: Arc<[u8]> = Vec::from("hello world").into();

    let mut handlers = Vec::new();
    for _ in 0..5 {
        let data_ref = data.clone();
        handlers.push(thread::spawn(move || {
            assert!(data_ref.starts_with(b"hello"));
        }));
    }

    for h in handlers {
        h.join().unwrap();
    }
}
```

每个线程通过克隆 `Arc` 增加引用计数，实际数据仅保存一份。线程安全由 Arc 内部机制保障，而零拷贝的特性使得数据共享极为高效。



## 2.3 写时复制 (Cow) 优化潜在修改场景

Cow (Copy-on-Write) 是一个枚举类型，可以表示 borrowed 或 owned 数据。它在可能修改数据的场景中非常有用：**默认情况下使用借用，仅在需要修改时才进行复制。**

```rust
use std::borrow::Cow;

fn normalize<'a>(s: &'a str) -> Cow<'a, str> {
    if s.is_ascii() {
        Cow::Borrowed(s)
    } else {
        Cow::Owned(s.to_lowercase())
    }
}
```



## 2.4 `IoSlice` 进行向量化 `I/O` 操作

在进行网络或文件 I/O 时，如果需要同时写入多个缓冲区，可以使用 `IoSlice` 来表示一个缓冲区的视图，并通过 `write_vectored` 一次性提交多个缓冲区，从而减少系统调用次数并避免临时拼接数据。

```rust
use std::io;

fn write_response(mut w: impl io::Write, header: &[u8], body: &[u8]) -> io::Result<()> {
    let bufs = [io::IoSlice::new(header), io::IoSlice::new(body)];
    w.write_vectored(&bufs)?;
    Ok(())
}
```

操作系统会一次性处理多个缓冲区，开发者无需先将多个切片合并为一个大的 `Vec<u8>`，既节约内存又提升效率。



## 2.5 基于 `Arc` 和 `RwLock` 的配置快照机制

在需要频繁读取但偶尔更新的配置管理场景中，可以使用 `RwLock<Arc<T>>` 结构。读取时克隆 `Arc` 获得快照，写入时替换整个 `Arc`，这样读取操作几乎无锁竞争，且能保证数据一致性。

```rust
use std::sync::{Arc, RwLock};

#[derive(Clone)]
struct Config {
    host: String,
    port: u16,
}

struct GlobalConfig {
    cfg: RwLock<Arc<Config>>,
}

impl GlobalConfig {
    fn get(&self) -> Arc<Config> {
        self.cfg.read().unwrap().clone()
    }
    
    fn set(&self, cfg: Config) {
        *self.cfg.write().unwrap() = Arc::new(cfg);
    }
}
```

通过快照获取配置，无需阻塞；写者原子性地更新整改配置对象。这种方式在高并发读取场景中表现优异。



## 2.6 使用有界异步通道实现反压

在异步系统中，为了避免生产者过度生成导致内存膨胀，可以使用有界通道 (bounded channel) 来实现反压 (back pressure)。当通道满时，发送操作会等待，从而迫使生产者减速。

```rust
async fn bounded() {
    let (tx, mut rx) = mpsc::channel::<Arc<[u8]>>(256);

    let producer = tokio::spawn({
        let tx = tx.clone();
        async move {
            for n in 0..10_000 {
                let bytes: Arc<[u8]> = format!("msg: {}", n).into_bytes().into();
                tx.send(bytes).await.unwrap();
            }
        }
    });

    while let Some(data) = rx.recv().await {
        println!("{:?}", String::from_utf8_lossy(&data));
    }

    producer.await.unwrap();
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn it_works() {
        bounded().await;
    }
}
```

消息通过 `Arc<[u8]>` 共享，通道容量限制避免了无限制内存增长，同时保持了零拷贝传递。



## 2.7 基于任务分片的核心本地化处理

对于高吞吐数据处理任务，可以将任务分片 (sharding) 并绑定到特定 CPU 核心，避免跨核心数据共享带来的缓存一致性问题。每个分片处理本地的数据，减少竞争。

```rust
use std::sync::{Arc, mpsc, Mutex};
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel::<Arc<[u8]>>();
    let num_workers = num_cpus::get();
    let rx = Arc::new(Mutex::new(rx));

    let mut workers = vec![];
    for _ in 0..num_workers {
        let rx = Arc::clone(&rx);
        workers.push(thread::spawn(move || {
            while let Ok(data) = rx.lock().unwrap().recv() {
                // 处理数据，无需跨线程同步
                let _len = data.len();
                println!("处理数据长度：{}", _len)
            }
        }));
    }

    for n in 0..10_000 {
        let bytes: Arc<[u8]> = format!("evt: {}", n).into_bytes().into();
        tx.send(bytes).unwrap();
    }

    drop(tx);
    for w in workers {
        w.join().unwrap();
    }
}
```

通过分片和通道传递 `Arc<[u8]>`，实现了零拷贝数据传输，且每个分片内部无竞争。

由于标准库 `mpsc::channel` 的 `rx` 无法直接 clone，需要使用 `Arc<Mutex<T>>` 包装。改用 crossbeam-channel，简化代码：

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    let (tx, rx) = crossbeam_channel::unbounded::<Arc<[u8]>>();
    let num_workers = num_cpus::get();

    let mut workers = vec![];
    for _ in 0..num_workers {
        let rx = rx.clone();
        workers.push(thread::spawn(move || {
            for data in rx.iter() {
                // 处理数据，无需跨线程同步
                let _len = data.len();
                println!("处理数据长度：{}", _len)
            }
        }));
    }

    for n in 0..10_000 {
        let bytes: Arc<[u8]> = format!("evt: {}", n).into_bytes().into();
        tx.send(bytes).unwrap();
    }

    drop(tx);
    for w in workers {
        w.join().unwrap();
    }
}
```



## 2.8 通过缓冲池重用内存分配

频繁创建和销毁缓冲区会导致内存分配器压力增大。通过实现一个简单的缓冲池，可以复用已分配的缓冲区，减少内存分配次数。

```rust
use std::sync::{Arc, Mutex};

struct BufferPool {
    free: Mutex<Vec<Vec<u8>>>,
}

impl BufferPool {
    fn new() -> Self {
        BufferPool { free: Mutex::new(Vec::new()) }
    }

    fn get(&self) -> Vec<u8> {
        self.free.lock().unwrap().pop().unwrap_or_else(|| Vec::with_capacity(1024))
    }

    fn put(&self, buf: Vec<u8>) {
        self.free.lock().unwrap().push(buf);
    }

    fn clear(&self) {
        self.free.lock().unwrap().clear();
    }
}

fn main() {
    let pool = Arc::new(BufferPool::new());

    // 写数据
    let mut buf = Vec::new();
    buf.extend(b"hello");
    pool.put(buf);

    // 读并写入数据
    let mut buf = pool.get();
    buf.extend_from_slice(b" world");
    pool.put(buf);

    // 读数据
    let buf = pool.get();
    println!("{:?}", buf);

    // 清空数据
    pool.clear();

    // 读数据
    let buf = pool.get();
    println!("{:?}", buf);
}
```

通过重用已分配的 `Vec<u8>`，避免了频繁的内存分配和释放，特别适用于需要反复处理相似大小数据的场景。



## 2.9 线程局部存储实现无锁临时空间

对于每个线程需要独立临时缓冲区场景，可以使用线程局部存储 (Thread Local Storage) 来为每个线程分配独立的可复用缓冲区，避免同步开销。

```rust
use std::cell::RefCell;

thread_local! {
    static SCRATCH: RefCell<Vec<u8>> = RefCell::new(Vec::with_capacity(1024));
}

fn render_line(s: &str) -> usize {
    SCRATCH.with(|buf| {
        let mut buf = buf.borrow_mut();
        buf.clear();
        buf.extend_from_slice(s.as_bytes());
        buf.len()
    })
}
```

每个线程独立访问自己的缓冲区，无需加锁，且缓冲区容量可复用，实现了高效零拷贝操作。



## 2.10 基于切片包装类型的零拷贝解析

在协议解析或数据包处理中，通常需要将原始字节切片转化为结构化数据。通过包装切片类型，可以实现零拷贝解析，避免字节级的内存分配

```rust
struct Frame<'a>(&'a [u8]);

impl<'a> Frame<'a> {
    fn header(&self) -> Option<&'a [u8]> {
        self.0.get(0..4)
    }
    
    fn payload(&self) -> Option<&'a [u8]> {
        self.0.get(4..)
    }
}

fn handle_packet(buf: &[u8]) {
    let frame = Frame(buf);
    if let (Some(header), Some(payload)) = (frame.header(), frame.payload()) {
        // 直接使用切片操作，无拷贝
        let _ = (header.len(), payload.len());
    }
}
```

通过新类型包装，实现了对字节切片的结构化访问，无需任何内存分配，解析过程完全零拷贝。



# 3. 总结

在实际项目中使用零拷贝技术时，需注意以下几点：

- 优先选择 `Arc<T>` 而非 `Arc<Vec<T>>` 来表达不可变数据共享，前者更符合切片语义且更容易优化
- 使用有限通道避免内存无限增长，并通过反压机制维持系统稳定性
- 在实际负载下进行性能测试，避免微基准测试的误导，特别时注意缓存行与预取行为对性能的影响。



































