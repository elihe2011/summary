# Sync Trait

**Sync & Send**：

- 如果一个类型 `T` 是 `Sync` 的，那么它的引用 `&T` 可以被安全地在多个线程之间共享。即 `T` 是可以被同步访问的类型。

- 一个类型 `T` 是 `Sync` 的，那么 `&T` 将是 `Send` 的。`Send` 标记一个只得所有权可以在线程之间移动。
- **`T` is `Sync` <=> `&T` is `Send`**



**Sync 是一个自动 Trait**：

- 和 `Send` 一样，通常不需要手动为类型实现 Sync
- 如果一个 struct 或 enum 得所有字段都是 Sync 的，那么这个类型本身也是 Sync 的



**Sync 的类型**：

- **基本类型**：`u8`，`f64`，`bool`，`&T` 等。它们的值不可变，共享引用它们不会产生任何副作用
- **聚合类型**：如果一个元组、结构体、枚举的所有成员都是 Sync 的，那么它也是 Sync 的
- **大部分集合**：`Box<T>`，`Vec<T>` 等。只要其包含的类型 `T` 是 `Sync` 的，那么它也是 Sync 的
- **&mut T**：前提 `T` 必须是 `Sync` 的。因为无法从一个共享引用 `&(&mut T)` 中获取可变性，这个引用被降级为只读，即 `&(&T)`。因此线程间共享的 `&mut T` 的引用不会引起数据竞争



**不是 Sync 的类型**：

- **内部可变性**：即一个类型允许通过共享引用 `&self` 修改其内部数据
- **`Cell<T>` 和 `RefCell<T>` **：`Cell` 的 `set` 方法签名是 `fn set(&self, val: T)`。它只需要一个共享引用就能修改内部值，这种修改不是同步的，没有任何锁或原子操作保护。
- **引用计数 `Rc<T>`**：`Rc` 的 `clone` 方法签名是 `fn clone(&self) -> Rc<T>` ，通过它来增加引用计数，该计数操作是非原子的。



**在线程间安全地共享状态** ：

- **锁**：`Mutex<T>`(互斥锁)、`RwLock<T>` (多读单写锁)
- **`Arc<T>`** : 线程安全的引用计数
- **`std::sync::atomic`**：原子类型，包含 `AtomicUsize` 、`AtomicBool` 等







































