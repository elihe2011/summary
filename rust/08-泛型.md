# 1. 泛型

泛型(generic) 是一种多态实现，通过泛化类型和函数功能，扩大其适用范围。泛型能极大减少代码的重复，但它自身的语法细节要求较高。

**类型参数**是泛型最简单和常用的用法。

定义一个泛型函数，它接受类型为 T 的任意参数 arg：

```rust
fn foo<T>(arg: T) {}
```

指定泛型类型参数 `<T>`后，`(arg: T)` 中的 T 就是泛型类型，即使T之前被自定义为 struct，在这里 T 任然表示泛型。



# 2. 函数

为函数指定泛型类型`<T>`，那么它就变成了泛型函数

```rust
struct A;          // 具体类型
struct S(A);       // 具体类型
struct SGen<T>(T); // 泛型类型

// 常规函数
fn reg_func(_s: S) {}

// SGen<A>显式接受类型参量A，函数非泛型
fn gen_spec_t(_s: SGen<A>) {}

// SGen<i32>显示接受类型参量i32，函数非泛型
fn gen_spec_i32(_s: SGen<i32>) {}

// 泛型函数
fn generic<T>(_s: SGen<T>) {}

fn main() {
    // 使用非泛型函数
    reg_func(S(A));
    gen_spec_t(SGen(A));
    gen_spec_i32(SGen(6));

    // 显式指定类型参数char
    generic::<char>(SGen('a'));

    // 隐式指定类型参数char
    generic(SGen('a'));
}
```



# 3. 实现(impl)

```rust
struct Val {
    val: f64,
}

impl Val {
    fn value(&self) -> &f64 {
        &self.val
    }
}

struct GenVal<T> {
    gen_val: T,
}

impl <T> GenVal<T> {
    fn value(&self) -> &T {
        &self.gen_val
    }
}

fn main() {
    let x = Val{val: 5.1};
    let y = GenVal{gen_val: 3i16};

    println!("{}, {}", x.value(), y.value());
}
```



# 4. trait

实现 Drop trait 的泛函方法，drop调用者本身和一个输入参数

```rust
struct Empty;
struct Null;

trait DoubleDrop<T> {
    fn double_drop(&self, _: T) { }
}

impl <T, U> DoubleDrop<T> for U {
    fn double_drop(&self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null = Null;

    // 释放 empty 和 null
    empty.double_drop(null);

    // empty被引用，null被借用，无法再使用
    //empty;
    // null;
}
```



# 5. 约束

在使用泛型时，类型参数常常必须使用 trait 作为约束(bound) 来明确规定类型应该实现那些功能。

```rust 
// T 必须实现 Display
fn printer<T: Display>(t: T) {
    println!("{}", t);
}

struct S<T: Display>(T);
```

泛型的实例，可以访问作为约束的 trait 的方法：

```rust
use std::fmt::Debug;

trait HasArea {
    fn area(&self) -> f64;
}

#[derive(Debug)]
struct Rectangle {
    width: f64,
    height: f64,
}

#[allow(dead_code)]
#[derive(Debug)]
struct Triangle {
    base_len: f64,
    height: f64,
}

impl HasArea for Rectangle {
    fn area(&self) -> f64 {
        self.width * self.height
    }
}

fn print_debug<T: Debug>(t: T) {
    println!("{:?}", t);
}

fn area<T: HasArea>(t: &T) -> f64 {
    t.area()
}

fn main() {
    let rectangle = Rectangle{width: 3.5, height: 2.9};
    print_debug(&rectangle);
    println!("area: {}", area(&rectangle));

    let triangle = Triangle{base_len: 6.1, height: 3.5};
    print_debug(&triangle);
    // println!("area: {}", area(&triangle));
}
```

空约束：

```rust
struct Cardinal;
struct BlueJay;
struct Turkey;

trait Red {}
trait Blue {}

impl Red for Cardinal {}
impl Blue for BlueJay {}

fn red<T: Red>(_: &T) -> &'static str { "red" }
fn blue<T: Blue>(_: &T) -> &'static str { "blue" }

fn main() {
    let cardinal = Cardinal;
    let blue_jay = BlueJay;
    let _turkey = Turkey;

    println!("A cardinal is {}", red(&cardinal));
    println!("A blue jay is {}", blue(&blue_jay));
    // println!("A turkey is {}", red(&_turkey));
}
```



# 6. 多重约束

多重约束 (multiple bounds) 可用 `+` 连接，类型之间使用 `,` 隔开

```rust
use std::fmt::{Debug, Display};

fn compare_print<T: Debug + Display>(t: &T) {
    println!("Debug: {:?}", t);
    println!("Display: {}", t);
}

fn compare_types<T: Debug, U: Debug>(t: &T, u: &U) {
    println!("Debug: {:?}", t);
    println!("Debug: {:?}", u);
}

fn main() {
    let string = "abcd";
    let array = [1, 2, 3, 4];
    let vec = vec![1, 2, 3, 4];

    compare_print(&string);

    // array & vec 未实现Display
    // compare_print(&array);
    // compare_print(&vec);

    compare_types(&array, &vec);
}
```



# 7. where 子句

where 子句，用于对任意类型的限定，而不局限于类型参数本身。

where 的一些使用：

- 分别指定泛函的类型和约束，会更清晰

```rust
impl <A: TraitB + TraitC, D: TraitE + TraitF> MyTrait<A, D> for YourType { ... }
  
// where
impl <A, D> MyTrait<A, D> for YourType where
  	A: TraitB + TraitC,
  	D: TraitE + TraitF { ... }
```

- 比正常语法更有表现力

```rust
use std::fmt::Debug;

trait PrintInOption {
    fn print_in_option(self);
}

impl <T> PrintInOption for T where
    Option<T>: Debug {
        fn print_in_option(self) {
            println!("{:?}", Some(self));
        }
}

fn main() {
    let vec = vec![1, 2, 3];
    vec.print_in_option();
}
```



# 8. newtype

newtype 是一种**使用结构体（通常只包含一个字段）来定义新类型的模式**。使用 newtype 模式，可以为现有类型定义新的类型，并为这些新类型提供自定义行为或限制。这样做有助于在编译时捕获类型错误，并提高代码的可读性和可维护性。

```rust
struct Years(i64);

struct Days(i64);

impl Years {
    pub fn to_days(&self) -> Days {
        Days(self.0 * 365)
    }
}

impl Days {
    pub fn to_years(&self) -> Years {
        Years(self.0 / 365)
    }

    pub fn add(&self, days: i64) -> Days {
        Days(self.0 + days)
    }
}

fn old_enough(age: &Years) -> bool {
    age.0 >= 18
}

fn main() {
    let age = Years(5);
    let age_days = age.to_days();

    println!("old enough {}", old_enough(&age));

    println!("old enough {}", old_enough(&age_days.add(15*365).to_years()));
}
```



newtype vs alias：

- newtype 模式会产生新类型，而类型别名不会；
- 别名也不能在编译时捕获类型错误，别名最大的用处是提高代码的可读性，减少类型名称的重复。

```rust
type Kilometers = i32;
type LongType = Box<dyn Fn() + Send + 'static>;
```



New Type模式的优点：

- 类型安全

- 零成本抽象，没有运行时开销

  - **无额外内存开销**

  - **无额外运行时开销**



# 9. 关联项

关联项 (associated item) 指与多种类型的项有关的一组规则。它是 trait 泛型的扩展，允许再 trait 内部定义新的项。

## 9.1 存在问题

trait 如果对实现了它的容器类型时泛型的，则须遵守类型规范要求：**trait 的使用者必须指出 trait 的全部泛型类**型。

```rust
struct Container(i32, i32);

trait Contains<A, B> {
    fn contains(&self, _: &A, _: &B) -> bool;
    fn first(&self) -> i32;
    fn last(&self) -> i32;
}

impl Contains<i32, i32> for Container {
    fn contains(&self, n1: &i32, n2: &i32) -> bool {
        (&self.0 == n1) && (&self.1 == n2)
    }

    fn first(&self) -> i32 {
        self.0
    }

    fn last(&self) -> i32 {
        self.1
    }
}

// 容器C包含了`A`和`B`类型，但在此必须指出`A`和`B`显得很麻烦
fn difference<A, B, C>(c: &C) -> i32 where
    C: Contains<A, B> {
    c.last() - c.first()
}

fn main() {
    let n1 = 5;
    let n2 = 9;

    let c = Container(n1, n2);

    println!("contains: {}", c.contains(&n1, &n2));
    println!("first: {}", c.first());
    println!("last: {}", c.last());
    println!("difference: {}", difference(&c));
}
```



## 9.2 关联类型

通过把容器内部的类型放到 trait 中作为输出类型，使用“关联类型”增加了代码的可读性。语法如下：

```rust
trait Contains {
    type A;   // 定义类型
    type B;
    
    fn contains(&self, _: &Self::A, _: &Self::B) -> bool;
}
```

使用关联类型：

```rust
// 未使用关联类型
fn difference<A,B,C>(c: &C) -> i32 { ... }

// 使用关联类型
fn difference<C: Contains>(c :&C) -> i32 { ... }
```

使用关联类型重写：

```rust
struct Container(i32, i32);

trait Contains {
    type A;
    type B;
    
    fn contains(&self, _: &Self::A, _: &Self::B) -> bool;
    fn first(&self) -> i32;
    fn last(&self) -> i32;
}

impl Contains for Container {
    type A = i32;
    type B = i32;

    fn contains(&self, n1: &Self::A, n2: &Self::B) -> bool {
        (&self.0 == n1) && (&self.1 == n2)
    }

    fn first(&self) -> i32 {
        self.0
    }

    fn last(&self) -> i32 {
        self.1
    }
}

fn difference<C: Contains>(c: &C) -> i32 {
    c.last() - c.first()
}

fn main() {
    let n1 = 5;
    let n2 = 9;
    let c = Container(n1, n2);

    println!("contains: {}", c.contains(&n1, &n2));
    println!("first: {}", c.first());
    println!("last: {}", c.last());
    println!("difference: {}", difference(&c));
}
```



# 10. 虚类型参数

虚类型 (phantom type) 参数是一种在运行时不出现，仅在编译时进行静态检查的类型参数。

可以用额外的泛型类型参数指定数据类型，该类型可以充当标记，也可以提供编译时类型检查使用。这些额外的参数没有存储值，也没有运行时行为。

```rust
use std::marker::PhantomData;

// 虚元组结构体，`A`是泛型的，并且带有隐藏参数`B`
// 泛型`A`会分配存储空间，但`B`不会，因此`B`不能参与运算
#[derive(PartialEq)] // 允许进行相等测试
struct PhantomTuple<A, B>(A, PhantomData<B>);

// 虚类型结构体，`A`是泛型的，并且带有隐藏参数`B`
// 泛型`A`会分配存储空间，但`B`不会，因此`B`不能参与运算
#[derive(PartialEq)]
struct PhantomStruct<A, B> { first: A, phantom: PhantomData<B> }

fn main() {
    // f32 & f64 为隐藏参数
    let _tuple1: PhantomTuple<char, f32> = PhantomTuple('Q', PhantomData);
    let _tuple2: PhantomTuple<char, f32> = PhantomTuple('Q', PhantomData);

    let _struct1: PhantomStruct<char, f32> = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    let _struct2: PhantomStruct<char, f64> = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };

    println!("phantom tuple: {}", _tuple1 == _tuple2);
    // println!("phantom struct: {}", _struct1 == _struct2);
}
```

实例：单位检测，通过带一个虚类型参数的 Add trait 实现

```rust
// 要求 `Self + RHS = Output`
// `<RHS = Self>` 表示 RHS 的默认值为 Self 类型
pub trait Add<RHS = Self> {
    type Output;
    
    fn add(self, rhs: RHS) -> Self::Output;
}
```



单位检测代码：

```rust
use std::marker::PhantomData;
use std::ops::Add;

#[derive(Debug, Copy, Clone)]
enum Inch {}

#[derive(Debug, Copy, Clone)]
enum Mm {}

// Length 是一个带虚类型参数Unit的类型
#[derive(Debug, Copy, Clone)]
struct Length<Unit>(f64, PhantomData<Unit>);

impl <Unit> Add for Length<Unit> {
    type Output = Length<Unit>;
    
    fn add(self, rhs: Self) -> Self::Output {
        Length(self.0 + rhs.0, PhantomData)
    }
}

fn main() {
    let one_foot : Length<Inch> = Length(3.12, PhantomData);
    let one_meter: Length<Mm> = Length(5.76, PhantomData);

    // 使用 + 调用 Length<Unit> 实现的 add 方法
    let two_feet = one_foot + one_foot;
    let two_meters = one_meter + one_meter;

    println!("two feet: {:?}", two_feet.0);
    println!("two meters: {:?}", two_meters.0);
}
```



# 11. 应用示例

## 11.1 不同类型加法

```rust
fn add<T: std::ops::Add<Output = T>>(x: T, y: T) -> T {
    x + y
}

fn main() {
    println!("add i8: {}", add(3i8, 5i8));
    println!("add i32: {}", add(14, 9));
    println!("add f64: {}", add(1.5f64, 3.1f64));
}
```



## 11.2 获取数组最大值

```rust
fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {
    let mut max= &list[0];

    for item in list.iter() {
        if item > max {
            max = item;
        }
    }

    max
}

fn main() {
    let number_list = vec![32, 17, 25, 68, 23];
    let result = largest(&number_list);
    println!("the largest number in list: {}", result);

    let char_list = vec!['a', 'z', 'g', 'x'];
    let result = largest(&char_list);
    println!("the largest char in list: {}", result);
}
```



