# 1. 生命周期

**生命周期(lifetime)**：用来跟踪引用有效性的机制。它确保引用不会再其指向的数据被清理后继续存在。

生命周期注释不会改变任何引用的生存期。相反，它们描述了多个引用彼此之间的生命周期关系，而不会影响生命周期。就像函数在签名指定泛型类型参数时可以接受任何类型一样，函数可以通过指定泛型生命周期参数来接受具有任何生命周期的引用。

```rust
&i32         // a reference
&'a i32      // a reference with an explicit lifetime
&'a mut i32  // a mutable reference with an explicit lifetime
```



## 1.1 显式标注

借用检查器使用显式的生命周期标记来明确引用的有效时间应该持续多久。在生命周期没有省略的情况下，需要显式标注来确定引用的生命周期应该时什么样的。语法如下：

```rust
foo<'a>        // foo 带一个生命周期参数 'a
foo<'a, 'b>    // 带有生命周期参数 'a 和 'b
```

和闭包类似，使用生命周期需要泛型。若要给类型显式标注生命周期，其语法是 `&'a T`

`'a` 是一个生命周期参数，它表示参数 `x` 、`y` 和返回值的引用至少在 `'a` 表示的作用域内有效。 

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let s1 = String::from("long string is long");
    let result;
    
    {
        let s2 = String::from("xyz");
        result = longest(s1.as_str(), s2.as_str());
    }
    
    // 错误：`result` 的生命周期不能超过 `s2`
    println!("The longest string is {}", result);
}
```



## 1.2 省略标注

大多数情况下，Rust编译器可以自动推断生命周期，不需要显式标注，这被称为“生命周期省略规则”：

- 每个引用参数都有自己的生命周期参数
- <font color="green">如果只有一个输入生命周期参数，那么它被赋给所有输出生命周期参数</font>
- <font color="orange">如果有多个输入生命周期参数，但其中一个是 `&self` 或 `&mut self`，那么 `self` 的生命周期被付给所有输出生命周期参数。</font>

```rust
// 检查器自动添加生命周期 'a
fn elided_input(x: &i32) {
    println!("`elided_input`: {}", x);
}

fn annotated_input<'a>(x: &'a i32) {
    println!("`annotated_input`: {}", x);
}

// 检查器自动添加生命周期 'a
fn elided_pass(x: &i32) -> &i32 {
    x
}

fn annotated_pass<'a>(x: &'a i32) -> &'a i32 {
    x
}

fn main() {
    let x = 3;

    elided_input(&x);
    annotated_input(&x);

    println!("`elided_pass`: {}", elided_pass(&x));
    println!("`annotated_pass`: {}", annotated_pass(&x));
}
```



## 1.3 生命周期规则

生命周期是 Rust 中实现内存安全的关键机制之一，**它帮助编译器在编译时验证引用的有效性，防止悬挂引用(dangling references)和内存泄漏**。

```rust
// 编译错误：缺少生命周期标注
fn create_dangling_reference() -> &str {
    let s = String::from("hello");
    &s  // s将在此被销毁，但返回了它的引用
}
```



生命周期的基本规则：

- **没有引用都有一个生命周期**
- **借用的生命周期不能超过所有者的生命周期**
- **返回的引用的生命周期必须与某个参数的生命周期相关联**



# 2. 使用场景

## 2.1 函数

排除省略(elision)的情况，带上生命周期的函数签名有一些限制：

- 任何引用都必须拥有标注好的生命周期
- 任何**被返回的引用都必须有和某个输入量相同的生命周期或静态类型**(static)

```rust
fn main() {
    let s1 = String::from("abc");
    let s2 = "xyz";

    let result = longest(s1.as_str(), s2);
    println!("The longest string is {result}");
}

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

将触发一个错误：***missing lifetime specifier***，返回类型需要一个通用生命周期参数，因为 Rust 无法判断返回的引用是指“x”还是“y”。

正确的写法：

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```



指定生命周期参数的方式取决于函数正在执行的操作。如果将“longest”函数的实现更改为始终返回第一个参数而不是最长的字符串切片，则不需要在“y”参数上指定生命周期。

```rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```



从函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期参数匹配。如果返回的引用不引用其中一个参数，则它必须引用在此函数内创建的值。但是，这将是悬垂引用，因为该值将在函数结束时超出范围。

```rust
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```



综合示例：

```rust
fn print_one<'a>(x: &'a i32) {
    println!("`print_one`: x is {}", x);
}

fn add_one<'a>(x: &'a mut i32) {
    *x += 1;
}

fn print_multi<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("`print_multi`: x is {}, y is {}", x, y);
}

fn pass_x<'a, 'b>(x: &'a i32, _: &'b i32) -> &'a i32 {
    x
}

/*// 'a 的生命周期比函数长，创建的String类型在函数结束时被销毁，将返回一个指向无效数据的引用
// cannot return reference to temporary value
fn invalid_output<'a>() -> &'a String {
    &String::from("foo")
}*/

fn main() {
    let x = 7;
    let y = 9;

    print_one(&x);
    print_multi(&x, &y);

    let z = pass_x(&x, &y);
    print_one(&z);

    let mut t = 3;
    add_one(&mut t);
    print_one(&t);
}
```



## 2.2 方法

方法的标注和函数类似：

```rust
struct Owner(i32);

impl Owner {
    fn add_one<'a>(&'a mut self) {
        self.0 += 1;
    }

    fn print<'a>(&'a self) {
        println!("`print`: {}", self.0);
    }
}

fn main() {
    let mut owner = Owner(5);

    owner.add_one();
    owner.print();
}
```

方法一般不需要标记生命周期，因为 self 的生命周期会赋给所有的输出生命周期参数。

输入生命周期有两个，因此 Rust 应用第一个生命周期省略规则，并赋予 `&self` 和 `announcement` 各自的生命周期。然后，由于其中一个参数是 `&self`，返回类型获得 `&self` 的生命周期，并且所有生命周期都已考虑在内。

```rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
    
    // the third lifetime elision rule applies
    ffn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {annoucement}");
        self.part
    }
}
```



## 2.3 结构体中的引用

**当结构体包含引用时，必须为这些引用指定生命周期**

```rust
// 在结构体中使用生命周期
struct BookExcerpt<'a> {
    content: &'a str,
}

// 为结构体实现方法
impl<'a> BookExcerpt<'a> {
    fn get_first_line(&self) -> &str {
        let lines = self.content.lines();
        if let Some(line) = lines.next() {
            line
        } else {
            ""
        }
    }
    
    // 方法可以有不同的生命周期参数
    fn announce_and_return<'b>(&'a self, announcement: &'b str) -> &'a str {
        println!("{}", announcement);
        self.get_first_line()
    }
}
```



## 2.4 trait

trait 方法中生命周期的标注基本与函数类似，注意， impl 也可能有生命周期的标注。

```rust
#[derive(Debug)]
struct Borrowed<'a> {
    x: &'a i32,
}

impl<'a> Default for Borrowed<'a> {
    fn default() -> Self {
        Self {
            x: &10,
        }
    }
}

fn main() {
    let x: Borrowed = Default::default();
    println!("x is {:?}", x);
}
```



## 2.5 约束

生命周期约束语法：

- `T: 'a`：在 T 中的所有引用都必须比生命周期 `'a` 活得更长
- `T: Trait +'a `：必须为 T 实现 Trait，并且在 T 中的所有引用都必须比 `'a` 活得更长

```rust
use std::fmt::Debug;

#[derive(Debug)]
struct Ref<'a, T: 'a>(&'a T);

fn print<T>(t: T) where
    T: Debug {
    	println!("`print`: t is {:?}", t);
}

fn print_ref<'a, T>(t: &'a T) where
    T: Debug + 'a {
    	println!("`print_ref`: t is {:?}", t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&x);
    
    print_ref(&ref_x);
    print(ref_x);
}
```



# 3. 强制转换

**一个较长的生命周期可以强制转成一个较短的生命周期**，使它在一个通常情况下不能工作的作用域内也能正常工作。强制转换可由编译器隐式地推导并执行，也可以通过声明不同的生命周期的形式实现。

```rust
// 编译器自动推导，其结果的生命周期为两个之中短的哪个
fn foo<'a, 'b>(x: &'a i32, y: &'b i32) -> i32 {
    x * y
}

// `<'a: 'b, 'b>`: LT(a) >= LT(b), 生命周期长的转化为短的
fn bar<'a: 'b, 'b>(x: &'a i32, _: &'b i32) -> &'b i32 {
    x
}

fn main() {
    let x = 5;
    
    {
        let y = 2;
        println!("foo: {}", foo(&x, &y));
        println!("bar: {}", bar(&x, &y));
    }
    
    {
        let y = 3;
        println!("foo: {}", foo(&y, &x)); 
        println!("bar: {}", bar(&y, &x));
    }
}
```



# 4. 边界约束(HRTB)

生命周期约束跟 trait 约束类似，通过形如 `'a: 'b` 的语法，来标记两个生命周期的长短关系。



## 4.1 `'a: 'b`

表示 `'a` 至少和 `'b` 一样长，即 `'b` >= `'a`

```rust
struct DoubleRef<'a, 'b: 'a, T> {
    r: &'a, T,
    s: &'b, T    // `s`的引用值必须比`r`的引用值活得更久
}

// 'b 的生命周期比 'a 长
fn complex_function<'a, 'b: 'a>(x: &'a str, y: &'b str) -> &'a str {
    x
}
```



## 4.2 `T: 'a`

表示类型 `T` 必须比 `'a` 活得更久：

```rust 
struct Ref<'a, T: 'a> {
    r: &'a T
}
```

因为结构体字段 `r` 引用了 `T`，因此 `r` 的生命周期 `'a` 必须比 `T` 的生命周期更短（**被引用者的生命周期必须要比引用长**）

在 Rust 1.30 版本之前，该写法是必须的，但从 1.31 开始，编译器可以自动推导 `T: 'a` 类型约束，因此只需这样写即可：

```rust
struct Ref<'a, T> {
    r: &'a T
}
```



## 4.3 示例

必须添加约束 `'a: 'b` 后，才能编译成功，因为 `self.part` 的生命周期与 `self` 的生命周期一致，将 `&'a` 类型的生命周期强行转化为 `&'b` 类型，会报错，只有在 `'a` >= `'b` 的情况下，`'a` 才会转化为 `'b`

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a: 'b, 'b> ImportantExcerpt<'a> {
    fn announce_and_return_part(&'a self, announcement: &'b str) -> &'b str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
```



# 5. 静态生命周期

`'static` 生命周期是最长的，它会存在于整个程序运行的过程中。`'static` 生命周期可被强制转换成一个更短的生命周期。

有两种方式使变量拥有`'static` 生命周期，它们都把数据保存在可执行文件的只读内存区：

- 通过 `static` 声明常量 (constant)
- 产生一个拥有 `&'static str` 类型的 string 字面量

```rust
// 声明具有 'static 生命周期的常量
static NUM: i32 = 8;

// 强制转换生命周期
fn coerce_static<'a>(_: &'a i32) -> &'a i32 {
    &NUM
}

fn main() {
    {
        let static_string = "I'm in read-only memory";
        println!("static_string: {}", static_string);

        // 离开了该作用域，其引用不能再使用，但数据依旧存储在二进制文件中
    }

    {
        let lifetime_num = 9;
        let coerced_static = coerce_static(&lifetime_num);
        println!("coerced_static: {}", coerced_static);
    }

    println!("NUM: {} stays accessible", NUM);
}
```



`'static` 是一个特殊的生命周期，表示**引用在整个程序运行期间都有效**



## 5.1 字符串字面量

对字符串字面量 (`str`) 来说，它直接被打包到二进制文件中，永远不会被drop，因此它跟程序活得一样久，自然它的生命周期是 `'static`

```rust
// 字符串字面量拥有'static生命周期
let s: &'static str = "Hello, world!";

// 但要小心使用'static
fn return_static_str() -> &'static str {
    "This is safe because string literals are static"
}
```



`&'static` 引用指向的数据

```rust
fn main() {
    let r;
    
    {
        let static_string = "I'm in read-only memory";
        println!("static_string: {}", static_string);
        
        r = static_string;
    }
    
    println!("static_string reference remains alive: {}", r);  // ok
}
```



## 5.2 作用域规则

**`&static` 生命周期指针针对的仅仅是引用，而不是持有该引用的变量，对于变量来说，还是要遵循相应的作用域规则**

```rust
use std::slice::from_raw_parts;
use std::str::from_utf8_unchecked;

fn get_memory_location() -> (usize, usize) {
    // "hello" 是字符串字面量，它的生命周期是 'static
    // 但持有它的变量 string，其生命周期取决于它本身作用域，即函数内
    let string = "hello";
    let pointer = string.as_ptr() as usize;
    let length = string.len();
    
    (pointer, length)
}

fn get_str_at_location(pointer: usize, length: usize) -> &'static str {
    unsafe {
        from_utf8_unchecked(from_raw_parts(pointer as *const u8, length))
    }
}

fn main() {
    let (pointer, length) = get_memory_location();
    println!("pointer: {}, length: {}", pointer, length);
    
    let message = get_str_at_location(pointer, length);
    println!("{}", message);
    
    // 测试裸指针，不一定能够命中数据
    let message = get_str_at_location(105443962294780, 10);
    println!("{}", message);
}
```



## 5.3 Box智能指针

`static` 生命周期表示引用在整个程序运行期间都有效。

Box 智能指针通过堆分配和所有权转移，避免了引用生命周期的限制。

```rust
fn main() {
    // 字符串字面量
    let s: &'static str = "Hello world";
    
    // 拥有'static生命周期的字符串引用
    let long_lived = create_static_str();
    println!("{}", long_lived);
    
    // 使用Box避免生命周期问题
    let owned_string = String::from("Owned string");
    let boxed = owned_to_box(owned_string);
    println!("{}", boxed);
}

// 返回'static生命周期的引用
fn create_static_str() -> &'static str {
    "This string is stored in the binary file and has a 'static lifetime"
}

// 通过转移所有权避免生命周期问题
fn owned_to_box(s: String) -> Box<str> {
    s.into_boxed_str()
}
```



## 5.4 `T: 'static`

`T: 'static` 与 `&'static` 有相同的约束：**T 必须活得和程序一样久**

```rust
use std::fmt::Debug;

// T 必须拥有'static生命周期，或者是一个不包含任何引用的类型
fn print1<T: Debug + 'static>(input: T) {
    println!("{:?}", input);
}

// input 必须拥有'static生命周期，或者是一个不包含任何引用的类型
fn print2(input: impl Debug + 'static) {
    println!("{:?}", input);
}

fn main() {
    let i = 3;
    
    print1(&i);
    print2(&i);
}
```

编译错误：

```
error[E0597]: `i` does not live long enough
  --> src/main.rs:16:12
   |
14 |     let i = 3;
   |         - binding `i` declared here
15 |     
16 |     print1(&i);
   |     -------^^-
   |     |      |
   |     |      borrowed value does not live long enough
   |     argument requires that `i` is borrowed for `'static`
17 |     print2(&i);
18 | }
   | - `i` dropped here while still borrowed
```



原因：**`&i` 的生命周期无法满足 `'static` 的约束**

解决方法：

1. 移除 `'static` 静态约束

```rust
use std::fmt::Debug;

fn print1<T: Debug>(input: T) {
    println!("{:?}", input);
}

fn print2(input: impl Debug) {
    println!("{:?}", input);
}

fn main() {
    let i = 3;
    
    print1(&i);
    print2(&i);
}
```



2. 使用泛型生命周期参数

```rust
use std::fmt::Debug;

fn print1<'a, T: Debug + 'a>(input: T) {
    println!("{:?}", input);
}

fn print2<'a>(input: impl Debug + 'a) {
    println!("{:?}", input);
}

fn main() {
    let i = 3;
    
    print1(&i);
    print2(&i);
}
```



3. 使用 **`&T`** 接收

   - `i` 是一个 `i32` 类型的局部变量，`i32` 是 `'static` 的。

   - `&i` 是一个指向 `i32` 的引用，它的生命周期是 `main` 函数的局部作用域。

   - 由于 `i32` 是 `'static`，`&i` 可以满足 `print1` 和 `print2` 的约束。

```rust
use std::fmt::Debug;

fn print1<T: Debug + 'static>(input: &T) {
    println!("{:?}", input);
}

fn print2(input: &(impl Debug + 'static)) {
    println!("{:?}", input);
}

fn main() {
    let i = 3;
    
    print1(&i);
    print2(&i);
}
```



# 6. 生命周期与泛型、trait 结合

生命周期可以与泛型和 trait bounds 结合使用：

```rust
use std::fmt::Display;

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";
    
    let result = longest_with_announcement(
        string1.as_str(),
        string2,
        "Just a test"
    );
    
    println!("Longest string: {}", result);
}

// 结合泛型T和生命周期'a
fn longest_with_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
   println!("Announcement: {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```







# 7. 闭包中使用生命周期

```rust
fn main() {
    fn fn_elision(x: &i32) -> &i32 { x }
    println!("{}", fn_elision(&5));
    
    let closure_elision = |x: &i32| -> &i32 { x };
    println!("{}", closure_elision(&8));
}
```

编译错误：

```
error: lifetime may not live long enough
 --> src/main.rs:5:47
  |
5 |     let closure_elision = |x: &i32| -> &i32 { x };
  |                               -        -      ^ returning this value requires that `'1` must outlive `'2`
  |                               |        |
  |                               |        let's call the lifetime of this reference `'2`
  |                               let's call the lifetime of this reference `'1`

error: could not compile `playground` (bin "playground") due to 1 previous error
```

生命周期消除规则：**如果函数参数中只有一个引用类型，那该引用的生命周期会被自动分配给所有的返回引用**。

针对普通函数，能够顺利编译通过。但闭包，并没有函数那么简单，它的**生命周期分散在参数和闭包函数体中(主要是在它没有确切的返回值签名)**：

```rust
let closure_elision = |x: &i32| -> &i32 { x };
```

编译器就必须深入到闭包中，取分析和推测生命周期，复杂度因此急剧提升。



**用 `Fn` trait 解决闭包生命周期**：

```rust
fn main() {
    let closure_elision = create_closure(|x: &i32| -> &i32 { x });
    println!("{}", closure_elision(&5));
}

fn create_closure<T, F: Fn(&T) -> &T>(f: F) -> F {
    f
}
```



闭包捕获环境中的引用时，也涉及生命周期：

```rust
fn create_closure<'a>(s: &'a str) -> impl Fn() -> &'a str {
    move || s
}
```



# 8. 生命周期消除规则

## 8.1 impl 块消除

```rust
impl<'a> Reader for BufReader<'a> {
    // methods go here
    // impl内部实际上没有用到'a
}
```

如果在 impl 内部方法中，根本没有用到 `'a`，那可以写成：

```rust
impl Reader for BufReader<'_> {
    // methods go here
}
```

`'_` 称为匿名生命周期 (anonymous lifetime)，在此表示 `BufReader` 有一个不使用的生命周期，可以忽略它，无需为其创建一个名称。



## 8.2 约束消除

```rust
// Rust 2015
struct Ref<'a, T: a'> {
    field: &'a T
}

// Rust 2018
struct Ref<'a, T> {
    field: &'a T
}
```



# 9. 常见问题分析

## 9.1 不聪明的生命周期检查

**示例1：**

```rust
#[derive(Debug)]
struct Foo;

impl Foo {
    fn mutate_and_share(&mut self) -> &Self {
        &*self
    }
    
    fn share(&self) {}
}

fn main() {
    let mut foo = Foo;
    let loan = foo.mutate_and_share();
    
    foo.share();
    println!("{:?}", loan);
}
```

`foo.mutate_and_share()` 虽然借用了 `&mut self`，但它最终返回一个 `&self`，然后赋值给 `loan`，因此理论上来说它最终是进行了不可变借用，同时 `foo.share()` 也进行了不可变借用。根据 Rust 借用规则：**多个不可变借用可以同时存在**，因此代码可编译通过。

但运行代码，将出现错误：

```
error[E0502]: cannot borrow `foo` as immutable because it is also borrowed as mutable
  --> src/main.rs:18:5
   |
16 |     let loan = foo.mutate_and_share();
   |                --- mutable borrow occurs here
17 |     
18 |     foo.share();
   |     ^^^ immutable borrow occurs here
19 |     println!("{:?}", loan);
   |                      ---- mutable borrow later used here
```

模拟编译器生命周期标注后的代码：`&mut foo` 和 `loan` 的生命周期都是 `'c`

```rust
struct Foo;

impl Foo {
    fn mutate_and_share<'a>(&'a mut self) -> &'a Self {
        &'a *self
    }
    
    fn share<'a>(&'a self) {}
}

fn main() {
    'b: {
        let mut foo: Foo = Foo;
        'c: {
            let loan: &'c Foo = Foo::mutate_and_share::<'c>(&'c mut foo);
            'd: {
                Foo::share::<'d>(&'d foo);
            }
            
            println!("{:?}", loan);
        }
    }
}
```

**编译器生命周期检查的三条规则**：

- <font color="red">每个引用参数都会拥有自己的生命周期参数</font>
- <font color="red">当只存在一个输入生命周期参数时，这个生命周期会被赋予给所有输出生命周期参数</font>
- <font color="red">当拥有多个输入生命周期参数，而其中一个是`&self` 或 `&mut self` 时，self 的生命周期会被赋予给所有的输出生命周期参数 </font>

根据上述生命周期消除规则第三条，再 `mutate_and_share` 方法中，参数 `&mut self` 和返回值 `&self` 的生命周期是相同的，因此，若返回值的生命周期在 `main` 函数有效，那 `&mut self` 的借用也是在 `main` 函数有效。这就是为什么可变借用会在 `main` 函数作用域内有效，最终导致 `foo.share()` 无法再进行不可变借用。



**示例2：**

```rust
#![allow(unused)]
fn main() {
    use std::collections::HashMap;
    use std::hash::Hash;
    
    fn get_default<'m, K, V>(map: &'m mut HashMap<K, V>, key: K) -> &'m mut V
    where
        K: Clone + Eq + Hash,
        V: Default,
    {
        match map.get_mut(&key) {
            Some(value) => value,
            None => {
                map.insert(key.clone(), V::default());
                map.get_mut(&key).unwrap()
            }
        }
    }
}
```

错误信息：

```
error[E0499]: cannot borrow `*map` as mutable more than once at a time
  --> src/main.rs:16:17
   |
8  |       fn get_default<'m, K, V>(map: &'m mut HashMap<K, V>, key: K) -> &'m mut V
   |                      -- lifetime `'m` defined here
...
13 |           match map.get_mut(&key) {
   |           -     --- first mutable borrow occurs here
   |  _________|
   | |
14 | |             Some(value) => value,
15 | |             None => {
16 | |                 map.insert(key.clone(), V::default());
   | |                 ^^^ second mutable borrow occurs here
17 | |                 map.get_mut(&key).unwrap()
18 | |             }
19 | |         }
   | |_________- returning this value requires that `*map` is borrowed for `'m`
```

在 `match map.get_mut(&key)` 方法调用完成后，对 `map` 的可变借用就可以结束了，但编译器不太聪明，它认为该借用持续到整个 `match` 语句块结束，这便导致后续借用的失败。



## 9.2 无界生命周期

不安全代码 (unsafe) 经常会凭空产生引用或生命周期，这些生命周期被称为是 **无界(unbound)** 的。

无界生命周期往往是在解引用一个裸指针(raw pointer)时产生的，换句话说，它是凭空产生的，因为输入参数根本就没有这个生命周期。

```rust
fn foo<'a, T>(x: *const T) -> &'a T {
    unsafe {
        &*x
    }
}
```

参数 `x` 是一个裸指针，它没有任何生命周期，然后通过 `unsafe` 操作后，它被解引用，变成一个 Rust 的标准引用类型，该类型必须要有生命周期，即 `'a`

这个 `'a` 是凭空产生的，因此它是无界生命周期，这种生命周期由于没有受到任何约束，因此它想要多大就多大，它实际比 `'static` 要强大。

例如 `&'static &'a T` 是无效类型，但无界生命周期 `&'unbounded &'a T` 会被视为 `&'a &'a` 从而通过编译检查。

在实际应用中，要尽量避免无界生命周期。最简单规避无界生命周期的方式就是在函数声明中运用生命周期消除规则。**若一个输出生命周期被消除，那么必定引用有一个输入生命周期与之对应**。



## 9.3 NLL (Non-Lexical Lifetime)

引用和借用：**引用的生命周期正常来说应该从借用开始一直持续到作用域结束**

```rust
fn main() {
    let mut s = String::from("hello");
    
    let r1 = &s;
    let r2 = &s;
    println!("{} and {}", r1, r2);
    // 新编译器中，r1, r2作用域在此结束
    
    let r3 = &mut s;
    println!("{}", r3);
}
```

按照上述规则，这段代码将会报错，因为 r1 和 r2 的不可变应用将持续到 main 函数结束，而在此范围内，又借用了 r3 的可变引用，这违反了借用的规则：要么多个不可变借用，要么可变借用。

该规则从 1.31 版本引入 NLL 后，就变成了：**引用的生命周期从借口处开始，一直持续到最后一次使用的地方**。



**Reborrow 再借用**：

```rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn move_to(&mut self, x: i32, y: i32) {
        self.x = x;
        self.y = y;
    }
}

fn main() {
    let mut p = Point { x: 0, y: 0 };
    let r = &mut p;
    
    // 再借用不会导致仅一次可变借用冲突
    let rr: &Point = &*r;
    
    // 再借用最后一次发生再次，其生命周期将在此结束
    println!("{:?}", rr);
    
    // 再借用结束后，才去使用原来的借用
    r.move_to(10, 10);
    println!("{:?}", r);
}
```

`rr` 是对 `r` 的再借用，不会破坏借用规则，但是不能再它的生命周期内再使用原来的借用 `r`



## 9.4 生命周期借用问题

```rust
struct Manager<'a> {
    text: &'a str
}

struct Interface<'a> {
    manager: &'a mut Manager<'a>
}

impl<'a> Interface<'a> {
    fn noop(self) {
        println!("interface consumed");
    }
}

struct List<'a> {
    manager: Manager<'a>
}

impl<'a> List<'a> {
    fn get_interface(&'a mut self) -> Interface {
        Interface {
            manager: &mut self.manager
        }
    }
}

fn main() {
    let mut list = List {
        manager: Manager {
            text: "hello"
        }
    };
    
    list.get_interface().noop();
    println!("Interface should be dropped here and the borrow released");
    
    // Interface中的可变借用，与list生命周期一致，导致同时存在可变和不可变借用
    use_list(&list);
}

fn use_list(list: &List) {
    println!("{}", list.manager.text);
}
```

运行后报错：

```
error[E0502]: cannot borrow `list` as immutable because it is also borrowed as mutable
  --> src/main.rs:39:14
   |
36 |     list.get_interface().noop();
   |     ---- mutable borrow occurs here
...
39 |     use_list(&list);
   |              ^^^^^
   |              |
   |              immutable borrow occurs here
   |              mutable borrow later used here
```

`list.get_interface()` 借用的可变引用，按理来说应该在改行代码执行后，就归还了。但由于因为在 `get_interface` 方法中声明的 `lifetime` 有问题。该方法的参数的生命周期是 `'a`，而 List 的生命周期也是 `'a`，说明该方法至少活得跟 List 一样久。在 main 函数的中，list 可以活到 main 函数的结束，因此 `list.get_interface()` 借用的可变引用也会活到 main 函数结束，在此期间，自然无法再进行借用。

要解决该问题，需要为 `get_interface` 方法的参数给予一个不同于 `List<'a>` 的生命周期 `'b`，如下

```rust
struct Manager<'a> {
    text: &'a str
}

struct Interface<'b, 'a: 'b> {
    manager: &'b mut Manager<'a>
}

impl<'b, 'a: 'b> Interface<'b, 'a> {
    fn noop(self) {
        println!("interface consumed");
    }
}

struct List<'a> {
    manager: Manager<'a>
}

impl<'a> List<'a> {
    fn get_interface<'b>(&'b mut self) -> Interface<'b, 'a>
    where 'a: 'b {
        Interface {
            manager: &mut self.manager
        }
    }
}

fn main() {
    let mut list = List {
        manager: Manager {
            text: "hello"
        }
    };
    
    list.get_interface().noop();
    println!("Interface should be dropped here and the borrow released");
    
    // Interface的生命周期比list短，在此已销毁，可进行借用
    use_list(&list);
}

fn use_list(list: &List) {
    println!("{}", list.manager.text);
}
```





























































