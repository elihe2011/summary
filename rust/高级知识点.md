

# 2. `for<'a>`

Higher-Rank Trait Bounds (HRTB) 让借用变得“可抽象”

```rust
where for<'a> F: Fn(&'a str) -> &'a str
```

它解决了一个很实际的问题：**这个函数/闭包对任何生命周期都成立**，而不是对某个特定生命周期成立。

在写通用库时非常常见：

- 接收一个 “可借用视图” 的函数
- 某个操作不捕获外部引用，不会把借用泄露出去
- iterator / adaptor 生命周期在组合中变复杂

更直观的类比：

- `F: Fn(&'a T)`  对某个具体的生命周期 `'a` 可用
- `for<'a> F: Fn(&'a T)` 对任意 `'a` 都可用



# 3. PhantomData

零大小类型（ZST），类型编码状态机（Type-state）

很多 Rust 代码“看起来安全”，但仍然可能出现非法状态：比如“未连接就发送”、“未初始化就使用”、“校验失败仍继续”

Rust 的一个硬核玩法是：**把状态放进类型参数里，让非法状态根本无法编译**

```rust
use std::marker::PhantomData;

struct Disconnected;
struct Connected;

struct Client<State> {
    addr: String,
    _marker: PhantomData<State>,
}

impl Client<Disconnected> {
    fn new(addr: impl Into<String>) -> Self {
        Self {
            addr: addr.into(),
            _marker: PhantomData,
        }
    }
    
    fn connect(self) -> Client<Connected> {
        // ... 建立连接 ...
        Client {
            addr: self.addr,
            _marker: PhantomData,
        }
    }
}

impl Client<Connected> {
    fn send(&self, msg: &str) {
        println!("send to {}: {}", self.addr, msg);
    }
}
```

`Client<Disconnected>`  => connect => `Client<Connected>` => send

该模式适用场景：

- 协议握手 (TLS/认证)
- 文件/设备生命周期 (open -> configured -> running)
- 构建器 (builder pattern) 确保字段齐全后才能 build



# 4. Pin 与 自引用

核心问题：为什么需要“固定住内存地址”？

因为某些结构可能内部持有指向自身字段的指针/引用 (自引用)，一旦对象被移到 (move)，内部指针就会悬空。

`async fn` 编译后通常会变成一个状态机，这个状态机可能包含跨 await 保存的借用，从而形成 “地址敏感” 的情况。为了安全，Rust 用 Pin 机制：“**这个值从限制起不能再被移动**”。

不一定要写自引用结构体，但需要懂：

- `Pin<&mut T>` 借用了可变引用，同时保证 T 不被 move
- `Unpin` 类型即使被 Pin，也允许移动 (多数普通类型都 Unpin)
- 许多异步底层 API 会要求 `Pin<&mut Future>`



# 5. unsafe

可以用 unsafe，但要让不安全可审计、可局部化、带不变量说明



## 5.1 真实含义

unsafe 不表示“这段代码一定会出错”，它表示：**编译器在这里放弃一部分检查，你需要保证某些不变量成立**。

优秀的 unsafe 代码通常这样：

- unsafe 只出现很小的函数/模块里
- 对外暴露的 API 是安全的 (safe wrapper)
- 注释清晰写出不变量 (Safety: ...)
- 由单元测试/模糊测试覆盖边界



## 5.2 常见安全封装模式

- FFI：把原始指针和生命周期包装成 RALL 类型
- `MaybeUninit`：初始化数组/性能敏感结构
- `slice::from_raw_parts`：把裸指针变切片 (前提：长度、对齐、有效性)
- `Send/Sync`：手动实现 (非常谨慎，写清楚线程安全证明)



## 5.3 使用 unsafe 的场景

- 确认瓶颈在这里，安全写法达不到性能/能力
- 能写清楚并证明不变量
- 能把 unsafe 封装起来，让团队其他人不需要碰它

高级 Rust 的一个标志就是：能写少量、正确、可审计的 unsafe，而不是完全逃避它



# 6. 宏

Rust 宏系统功能：

- 生成重复样板
- 在编译期做结构化代码生成
- 写 DSL (如测试框架、路由、SQL映射、序列化)



## 6.1 `macro_rules!`

模型匹配 + 重复展开。它的强大不在“替换文本”，而在于“**基于 token 的匹配与展开**”

```rust
macro_rules! vec_of_strings {
    ($($s:expr),* $(,)?) => {
        vec![$($s.to_string()),*]
    };
}

let v = vec_of_strings!["a", "b", "c"];
```

好处：

- 写内部 DSL (例如构造 AST、查询条件)
- 消除重复 impl / match 分支
- 编译期模板



## 6.2 过程宏 (proc-macro)

过程宏不是“更高级的宏”，而是你真的在**写一个编译器插件** (解析 token stream，再生成 token stream)

它适合：

- `#[derive(...)]` 自动生成大量 trait 实现
- `#[attribute]` 做路由、注入、注册表
- `sql!(...)` 之类的函数式宏做编译期检查 (需要配套生态)

过程宏的缺点：

- 增加编译时间
- 错误信息难做到友好
- 代码跳转/可读性变差



# 7. Const Generics

让 “尺寸、容量、维度” 成为类型的一部分

如果在运行期的 usize 来表达数组大小、矩阵维度、固定缓冲区长度，那 const generics 是更好的选择

```rust
struct FixedBuf<T, const N: usize> {
    data: [T; N],
}

impl<T: Copy, const N; usize> FixedBuf<T, N> {
    fn fill(value: T) -> Self {
        Self { data: [value; N] }
    }
}
```

这意味着：

- `FixedBuf<u8, 1024>` 和 `FxiedBuf<u8, 1024>` 是不同类型
- 编译期就能阻止维度不匹配 (配合 trait/impl 约束)
- 很多边界检查可以被优化掉 (更容易得到零开销)

典型应用：

- 密码学/协议 (固定 block size)
- 嵌入式 (静态内存)
- 数值计算 (矩阵维度)
- 网络包结构 (固定长度字段)



# 8. 错误处理分层

一般的 Rust 错误处理：

- 库里到处是 `Result<T, String>`
- 业务里 `anyhow::Result<T>`

进阶错误分层策略：

- 库 (library)：定义清晰的错误枚举 (可匹配、可组合、可携带 source)
- 应用 (application)：用“易用的上层错误”承载上下文 (如附加 context)，最终打印链路

需要掌握的能力：

- 用 From 做错误自动转换 (? 的基础)
- 错误链 (source) 与上下文
- 让错误类型携带足够信息，但不把内部实现细节泄露给 API 用户



# 9. 内部可变性与并发

Rust 在类型层面区分两件事：

- 可变性：`&mut T` 独占写
- 共享：`&T` 只读共享

内部可变性类型：**允许在 &T 下修改内部，但用运行期、原子、锁来维持规则**

常见选择：

- 单线程、少量可变：`Cell<T> (Copy) / RefCell<T>` 借用检查在运行期
- 多线程共享：`Mutex<T> / RwLock<T>`
- 高性能无锁：`Atomic*` + 正确的内存序

进阶的关键不是“会用”，而是：

- 能理解为什么某个类型能/不能 Send, Sync
- 能在 API 设计时选择 “共享读 + 消费式转移” 还是 “共享写 + 锁”
- 避免把锁暴露给调用者导致死锁、锁顺序问题



# 10. Rust API 设计风格

**用类型系统表达约束，而不是靠注释祈祷**

写库、公共模块、团队内部基础设施时，**代码的难点不是实现，而在“别人怎么用它”**

Rust API 设计：

- 用 `typestate` / `PhantomData` 防止非法状态
- 用 `impl Trait` 隐藏具体类型，减少暴露面
- 用 `newtype` （包一层 struct） 建立语义边界与不变量
- 泛型 or `dyn`：编译期优化 vs 运行期组合、可扩展性
- 用生命周期限制借用范围，避免资源泄露















