# 1. 类型系统

## 1.1 类型转换

Rust 不提供原生类型之间的隐式类型转换(coercion)，但可以使用 `as` 关键字进行显式类型转换(casting)

```rust
#[allow(overflowing_literals)]
fn main() {
    let decimal = 6543.21_f32;

    // 不支持隐式转换
    //let integer: u8 = decimal;

    // 显示转换
    let integer = decimal as u8;
    let character = integer as char;

    println!("integer: {}, character: {}", integer, character);

    // 处理方式：从最低有效位（LSB, least significant bits）开始保留 8 位，
    // 然后剩余位置，直到最高有效位（MSB, most significant bit）都被抛弃
    // 0b0011 1110 1000 => 0b1110 1000
    println!("1000 as u8: {}", 1000 as u8);  // 232

    // 0b1111 1111
    println!("-1i8 as u8: {}", -1i8 as u8);  // 255

    println!("128 as i16: {}", 128 as u16);  // 128
    println!("128 as i8: {}", 128 as i8);    // -128
}
```



## 1.2 字面量

对数值字面量，只要把类型作为后缀加上去，就完成了类型说明。比如`42i32`表示类型的 `i32`的 `42`

无后缀的数值字面量，其类型取决于怎样使用它们。如果没有限制，编译器会对整数使用 `i32`，对浮点数使用 `f64`。

```rust
use std;

fn main() {
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    let i = 1;   // i32
    let f = 1.0; // f64

    println!("bytes(x): {}", std::mem::size_of_val(&x));  // 1
    println!("bytes(y): {}", std::mem::size_of_val(&y));  // 4
    println!("bytes(z): {}", std::mem::size_of_val(&z));  // 4
    println!("bytes(i): {}", std::mem::size_of_val(&i));  // 4
    println!("bytes(f): {}", std::mem::size_of_val(&f));  // 8
}
```



## 1.3 类型推断

Rust 的类型推断引擎是很聪明的，它不只是在初始化时看看右值（r-value）的类型而已，它还会考察变量之后会怎样使用，借此推断类型.

```rust
fn main() {
    let elem = 5u8;

    // 类型为 Vec<?>
    let mut vec = Vec::new();

    // 推断类型为 Vec<u8>
    vec.push(elem);

    println!("{:?}", vec);
}
```



## 1.4 别名

可以用 `type` 语句给已有的类型取个新的名字。类型的名字必须遵循驼峰命名法（像是 `CamelCase` 这样），否则编译器将给出警告。

别名的主要用途是避免写出冗长的模板化代码（boilerplate code）。如 `IoResult<T>` 是 `Result<T, IoError>` 类型的别名。

```rust
type NanoSecond = u64;
type Inch = u64;

#[allow(non_camel_case_types)]
type u64_t = u64;

fn main() {
    let nanoseconds: NanoSecond = 5 as u64_t;
    let inches: Inch = 2 as u64_t;

    println!("nanoseconds: {} + inches: {} = {} units?", nanoseconds, inches, nanoseconds+inches);
}
```



# 2. 类型转换

Rust 使用 trait 解决类型之间的转换问题。最一般的转换会用到 `From`和 `Into` 两个 trait。不过，即便常见的情况也可能会用到特别的 trait，尤其是从 `String` 转换到别的类型，以及把别的类型转换到 `String` 时。



## 2.1 From 和 Into

`From` 和 `Into` 两个 trait 是内部相关联的，实际上这是它们实现的一部分。如果我们能够从类型 B 得到类型 A，那么很容易相信我们也能够把类型 B 转换为类型 A。

### 2.1.1 From

`From` trait 允许一种类型定义 “怎么根据另一种类型生成自己”，因此它提供了一种类型转换的简单机制。在标准库中有无数 `From` 的实现，规定原生类型及其他常见类型的转换功能。

比如，把 `str` 转换成 `String`：

```rust
let my_str = "hello";
let my_string = String::from(my_str);
```

自己的类型定义转换机制：

```rust
use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32
}

impl From<i32> for Number {
    fn from(item: i32) -> Self {
        Number{ value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!("num: {:?}", num);
}
```



### 2.1.2 Into

`Into` trait 是 `From` trait 的反操作。如果为类型实现了 `From`，那么同时也就免费获得了 `Into`。

使用 `Into` trait 通常要求指明要转换到的类型，因为编译器大多数时候不能推断它。

```rust
use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32
}

impl From<i32> for Number {
    fn from(item: i32) -> Self {
        Number{ value: item }
    }
}

fn main() {
    let int = 5;
    let num: Number = int.into();   // 必须显示指定类型Number
    println!("num: {:?}", num);
}
```



## 2.2 `TryFrom` 和 `TryInto`

不同于 `From`/`Into` 的是，`TryFrom` 和 `TryInto` trait 用于易出错的转换，也正因如此，其返回值是 `Result` 型。

```rust
use std::convert::TryFrom;

#[derive(Debug, PartialEq)]
struct EvenNumber(i32);

impl TryFrom<i32> for EvenNumber {
    type Error = ();

    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    assert_eq!(EvenNumber::try_from(4), Ok(EvenNumber(4)));
    assert_eq!(EvenNumber::try_from(3), Err(()));

    let result: Result<EvenNumber, ()> = 4i32.try_into();
    assert_eq!(result, Ok(EvenNumber(4)));

    let result: Result<EvenNumber, ()> = 5i32.try_into();
    assert_eq!(result, Err(()));
}
```



## 2.3 `ToString` 和 `FromStr`