# 1. RAII

Rust 强制实现 RAII (Resource Acquisition Is Initialization，资源获取即初始化)，所以任何对象在离开作用域时，它的析构函数(destructor) 被调用，释放占用的资源。

RAII 的目的是为了避免资源泄漏 (resource leak)，不再需要手动释放内存或担心内存泄漏 (memory leak)

Rust 中的析构函数通过 Drop trait 提供。当资源离开作用域，就调用析构函数，无需为每种类型都实现 Drop trait，只要为那么小需要自己的析构函数逻辑的类型实现即可。

```rust
struct ToDrop;

impl Drop for ToDrop {
    fn drop(&mut self) {
        println!("ToDrop is being dropped")
    }
}

fn main() {
    let _x = ToDrop;
    println!("Made a ToDrop");
}
```



# 2. 所有权

## 2.1 栈与堆

**栈(Stack)**：遵循 先进后出FILO 原则，所有数据都必须占用已知且固定大小的内存空间。

**堆(Heap)**：存储大小未知或可能变化的数据。在堆上存放数据时，需要申请一定大小的内存空间。系统会在堆的某处找到一块足够大的空位，将其标记为已使用，并返回一个表示该位置地址的指针，该过程被称为**在堆上分配(allocating)内存**。接着该指针会被推入**栈**中。

**性能区别**：

- 写入：入栈比在堆上分配内存块，因为入栈无须申请新的内存空间
- 读取：栈数据一般直接存储在CPU高速缓存中，而堆数据只能存储在内存中，且访问堆数据必须先访问栈数据获取堆数据地址，所以相对慢

**所有权与堆栈**：

- 调用函数时，传递给函数的参数依次入栈，当函数调用结束，这些值将被从栈中反序依次移除
- **堆上的数据缺乏组织，需要堆其进行跟踪，确保其分配和释放，不在堆上产生内存泄漏问题(数据无法被回收)**



## 2.2 所有权系统

在其他语言中，一般通过GC来确保内存安全，但GC会引起性能、内存占用及 Stop the world 等问题，在高性能场景和系统编程上时不可接受的。Rust 采用 **所有权系统** 来解决这一问题。

Rust 的所有权系统旨在解决两个主要问题：内存安全和并发安全。

- **内存安全**：通过在编译时检查变量作用域、移动语义和借用规则来确保程序在运行时不会出现悬垂指针、空指针解引用、数据竞争等内存安全问题。
- **并发安全**：通过限制可变引用的数量和作用域来确保程序在并发执行时不会出现数据竞争等并发安全问题。

所有权系统的**核心思想：每个值都有一个变量作为它的所有者。在任何时候，每个值都只能有一个所有者。当所有者离开作用域时，该值将被销毁。**

因为变量要负责释放它们拥有的资源，为防止资源的重复释放，所以**资源只能拥有一个所有者**。需要注意的是，不是所有变量都拥有资源(如：引用)

在进行赋值 (let x = y) 或通过值给函数传递参数 ( `foo(x)` ) 时，资源的所有权 (ownership) 会发生转移，即资源的移动 (move)。当资源发生移动后，为了避免悬挂指针 (dangling pointer) ，原来的所有者不能再被使用。

```rust
fn main() {
    // 栈上分配整型
    let x = 5;

    // 值拷贝，所有权未转移
    let y = x;

    println!("x={}, y={}", x, y);

    // 堆上分配整型指针
    let a = Box::new(8_i16);

    // 指针拷贝，所有权发生转移
    let b = a;  // value moved here

    // 错误
    // println!("a={}, b={}", a, b);

    // 传递值参数，所有权发生转移
    destroy(b);

    // 错误
    // println!("b={}", b);
}

fn destroy(x: Box<i16>) {
    println!("destroy a box that contains {}", x);
}
```

































