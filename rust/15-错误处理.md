# 1. 错误处理

## 1.1 Panic 

### 1.1.1 触发条件

- 显式触发：通过调用 `panic!` 宏实现
- 隐式触发：数组越界、除零操作等，例如 `let v = vec![1, 2 , 3]; println!("{}", v[4]);`



显示触发 panic，它会打印一个错误消息，然后回退(unwind)任务，退出程序

```rust
fn give_princess(gift: &str) {
    if gift == "snake" {
        panic!("god damn!!!");
    }

    println!("I love {}s!!!", gift);
}

fn main() {
    give_princess("teddy bear");
    give_princess("snake");
    give_princess("babbie");
}
```



### 1.1.2 处理模式

panic 的两种模式：

- Unwind：回溯栈，并清理栈上的数据
- Abort：直接终止程序，不进行任何清理

使用 Unwind 回溯栈并清理它遇到的每个函数的数据，但回溯和清理工作非常繁重。可以通过修改配置，立即结束程序而不进行清理。

如果在项目中需要使生成的二进制文件尽可能小，可以通过在 `Cargo.toml` 文件中添加相应的配置，来从展开切换到在发生恐慌时中止。

```toml
[profile.release]
panic = 'abort'
```



开启 `RUST_BACKTRACE=1`，跟踪错误栈：

```bash
$ RUST_BACKTRACE=1 cargo run 

$ RUST_BACKTRACE=1 cargo run --release
```



### 1.1.3 捕获与恢复

使用 `std::panic::catch_unwind` 函数可以捕获和处理 `panic`：

```rust
use std::panic;

fn main() {
    let result = panic::catch_unwind(|| {
        panic!("this is a panic");
    });
    
    match result {
        Ok(_) => println!("no panic"),
        Err(_) => println!("catched a panic"),
    }
}
```



## 1.2 Option

枚举类型 `Option<T>`:

- `Some(T)`：找到一个属于 T 类型的元素
- `None`：找不到相应元素

处理方式：

- match 显式处理
- unwrap 隐式处理，它要么返回 Some 内部的元素，要么就 panic



## 1.3 Result

Result 是 Option 类型的扩展，它可以有两个结果的其中一个：

- `Ok<T>`：找到 T 元素
- `Err<E>`：找到 E 元素，E 即错误类型

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```



### 1.3.1 别名

```rust
use std::num::ParseIntError;

type AliasedResult<T> = Result<T, ParseIntError>;

fn multiply(s1: &str, s2: &str) -> AliasedResult<i32> {
    s1.parse::<i32>().and_then(|n1| {
        s2.parse::<i32>().map(|n2| n1 * n2)
    })
}

fn print(result: AliasedResult<i32>) {
    match result {
        Ok(n) => println!("n is {}", n),
        Err(e) => println!("Error: {}", e),
    }
}

fn main() {
    let r1 = multiply("5", "7");
    print(r1);

    let r2 = multiply("t", "2");
    print(r2);
}
```



### 1.3.2 匹配不同的错误

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Prombles creating the file: {e:?}"),
            },
            other_error => {
                panic!("Probles opening the file: {other_error:?}");
            },
        },
    };
}
```

替代方法：

```rust
fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if  error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {error:?}");
            })
        } else {
            panic!("Problem opening the file: {error:?}")
        }
    });
}
```



### 1.3.3 提前返回

如果发生错误，则停止函数指向并返回错误，这样的代码更好写、更易读。

```rust
use std::num::ParseIntError;

fn multiply(s1: &str, s2: &str) -> Result<i32, ParseIntError> {
    let n1 = match s1.parse::<i32>() {
        Ok(n1) => n1,
        Err(e) => return Err(e),
    };

    let n2 = match s2.parse::<i32>() {
        Ok(n2) => n2,
        Err(e) => return Err(e),
    };

    Ok(n1 * n2)
}

fn print(result: Result<i32, ParseIntError>) {
    match result {
        Ok(n) => println!("n is {}", n),
        Err(e) => println!("Error: {}", e),
    }
}

fn main() {
    let r1 = multiply("3", "4");
    print(r1);

    let r2 = multiply("w", "8");
    print(r2);
}
```



### 1.3.4 `try!` 宏

`try!` 宏具有和 `?` 相同的功能，主要使用在老代码中

```rust
use std::num::ParseIntError;

fn multiply(s1: &str, s2: &str) -> Result<i32, ParseIntError> {
    // `try!()` macro is deprecated
    let n1 = r#try!(s1.parse::<i32>());
    let n2 = r#try!(s2.parse::<i32>());

    Ok(n1 * n2)
}

fn print(result: Result<i32, ParseIntError>) {
    match result {
        Ok(n) => println!("n is {}", n),
        Err(e) => println!("Error: {}", e),
    }
}

fn main() {
    print(multiply("5", "8"));
    print(multiply("s", "4"));
}
```



## 1.4 `?` 操作符

### 1.4.1 Option

`?` 简化 match 匹配的复杂性

```rust
struct Person {
    job: Option<Job>
}

#[derive(Copy, Clone)]
struct Job {
    phone_number: Option<PhoneNumber>
}

#[derive(Copy, Clone)]
struct PhoneNumber {
    area_code: Option<u8>,
    number: u32,
}

impl Person {
    fn work_phone_area_code(&self) -> Option<u8> {
        // 没有`?`运算符的话，将需要很多的嵌套的 `match` 语句
        self.job?.phone_number?.area_code
    }
}

fn main() {
    let p = Person {
        job: Some(Job{
            phone_number: Some(PhoneNumber{
                area_code: Some(25),
                number: 56712111,
            })
        })
    };

    assert_eq!(p.work_phone_area_code(), Some(25));
}
```



### 1.4.2 Result

unwrap 可能导致 panic，需要层层嵌套判断。如果只想把里面的变量拿出来，可使用 `?`，它几乎就等于一个返回 Error 而不是 panic 的 unwrap

```rust
use std::num::ParseIntError;

fn multiply(s1: &str, s2: &str) -> Result<i32, ParseIntError> {
    let n1 = s1.parse::<i32>()?;
    let n2 = s2.parse::<i32>()?;

    Ok(n1 * n2)
}

fn print(result: Result<i32, ParseIntError>) {
    match result {
        Ok(n) => println!("n is {}", n),
        Err(e) => println!("Error: {}", e),
    }
}

fn main() {
    let r1 = multiply("3", "9");
    print(r1);

    let r2 = multiply("t", "3");
    print(r2);
}
```



## 1.5 方法总结

### 1.5.1 err

**err()**：以 Option 类型返回错误的值



### 1.5.2 unwrap

**unwrap()**：如果 result 是成功的，返回成功的值。否则返回错误的结果并 panic

```rust
let mut x: i32 = 5;
x.try_into().unwrap();
```



**unwrap_or(callback)**：如果 result 是成功的，返回成功的值。否则返回 fallback，丢弃错误的值

```rust
let mut x: i32 = 5;
x.try_into().unwrap_or(0);
```



**unwrap_or_else(callback_fn)**：与 **unwarp_or(callback)** 类似，但传入一个函数或闭包

```rust
let mut x: i32 = 5;
x.try_into().unwrap_or_else(|e| panic!("Couldn't convert the i32, error {}", e));
```



### 1.5.3 expect

**expect(message)**：和 unwrap 基本相同，但 panic 时输出一条定制化错误信息

```rust
let mut x: i32 = 5;
x.try_into().expect("Couldn't convert to a u32");
```



### 1.5.4 as_xxx

**as_ref()**：把一个 Result 转换成 `Result<&T, &E>`

**as_mut()**：和 as_ref() 类似，但借用可变引用，返回 `Result<&mut T, &mut E>`



# 2. 组合器

**组合器设计模式**：将对象组合成树形结构，以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。



## 2.1 `or()` 和 `and()`

对两个表达式做逻辑组合，最终返回 `Option` 或 `Result`

- `or()` ，表达式按顺序求职，若任何一个表达式的结果是 `Some` 或 `Ok`，则该值会立即返回
- `and()`，若两个表达式的结果都是 `Some` 或 `Ok`，则**第二个表达式中的值被返回。若任何一个的结果是 `None` 或 `Err`，则立即返回

```rust
fn main() {
    let s1 = Some(1);
    let s2 = Some(2);
    let n = None;
    
    assert_eq!(s1.or(s2), s1);
    assert_eq!(s1.or(n), s1);
    assert_eq!(s1.and(s2), s2); // 注意返回第二个表达式
    assert_eq!(s1.and(n), n);
    
    // xor 只能用于 Option
    assert_eq!(s1.xor(s2), n);
}
```



## 2.2 `or_else()` 和 `and_then()`

与 `or()` 和 `and()` 类似，但第二个表达式是一个闭包

```rust
fn main() {
    let r1: Result<&str, &str> = Ok("success");
    let r2: Result<&str, &str> = Err("failure");

    assert_eq!(r1.or_else(|_| Ok("1")), r1);
    assert_eq!(r1.and_then(|_| Ok("1")), Ok("1"));
    
    assert_eq!(r2.or_else(|_| Ok::<&str, &str>("2")), Ok("2"));
    assert_eq!(r2.and_then(|_| Ok("2")), r2);
}
```



## 2.3 `filter`

用于对 `Option` 进行过滤：

```rust
fn main() {
    let s1 = Some(8);
    let s2 = Some(5);
    let n = None;
    
    let is_even = |n: &i32| n % 2 == 0;
    
    assert_eq!(s1.filter(is_even), s1);
    assert_eq!(s2.filter(is_even), n);
    assert_eq!(n.filter(is_even), n);
}
```



## 2.4 `map` 和 `map_err()`

将 `Some` 或 `Ok` 中的值映射为另一个：

```rust
fn main() {
    let char_count = |s: &str| s.chars().count();

    let s1 = Some("abcde");
    let s2 = Some(5);
    assert_eq!(s1.map(char_count), s2);
    
    let n1 = None;
    let n2 = None;
    assert_eq!(n1.map(char_count), n2);
    
    let o1: Result<&str, &str> = Ok("abcde");
    let o2: Result<usize, &str> = Ok(5);
    assert_eq!(o1.map(char_count), o2);
    
    // 无法修改Err的值
    let e1: Result<&str, &str> = Err("abcde");
    let e2: Result<usize, &str> = Err("abcde");
    assert_eq!(e1.map(char_count), e2);
    
    // 修改Err的值
    let e3: Result<&str, &str> = Err("abcde");
    let e4: Result<&str, usize> = Err(5);
    assert_eq!(e3.map_err(char_count), e4);
}
```



## 2.5 `map_or()` 和 `map_or_else()`

`map_or()` 在 `map()` 的基础上提供一个默认值：

```rust
fn main() {
    const DEFAULT: u32 = 1;
    let fn_closure = |n: u32| n + 2;
    
    let r: Result<u32, ()> = Ok(5);
    assert_eq!(r.map_or(DEFAULT, fn_closure), 7);

    let n: Option<u32> = None;
    assert_eq!(n.map_or(DEFAULT, fn_closure), DEFAULT);
}
```



`map_or_else()` 通过一个闭包来提供默认值：

```rust
fn main() {
    let fn_closure = |n: u32| n + 2;
    let fn_default = || 1; // 匿名函数不能携带参数
    
    let s = Some(5);
    let n: Option<u32> = None;
    assert_eq!(s.map_or_else(fn_default, fn_closure), 7);
    assert_eq!(n.map_or_else(fn_default, fn_closure), 1);
    
    let o = Ok(10);
    let e = Err(6);
    let fn_default_for_result = |n: u32| n - 1;
    
    assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12);
    assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 5);
}
```



## 2.6 `ok_or()` 和 `ok_or_else()`

支持将 `Option` 转换为 `Result`

 `ok_or` 接收一个默认的 `Err` 参数：

 ```rust
fn main() {
    const ERR_MSG: &str = "error message";
    
    let s = Some("abcde");
    let n: Option<&str> = None;
    
    let o = Ok("abcde");
    let e = Err(ERR_MSG);
    
    assert_eq!(s.ok_or(ERR_MSG), o);
    assert_eq!(n.ok_or(ERR_MSG), e);
}
 ```



`ok_or_else` 接收一个闭包作为 `Err` 参数：

```rust
fn main() {
    let fn_err_msg = || "error message";
    
    let s = Some("abcde");
    let n: Option<&str> = None;
    
    let o = Ok("abcde");
    let e = Err(fn_err_msg());
    
    assert_eq!(s.ok_or_else(fn_err_msg), o);
    assert_eq!(n.ok_or_else(fn_err_msg), e);
}
```



## 2.7 示例：简化 match

Option 的 map, and_then 等组合算子也为 Result 实现了

```rust
#![allow(dead_code)]
use std::num::ParseIntError;

fn multiply_v1(s1: &str, s2: &str) -> Result<i32, ParseIntError> {
    match s1.parse::<i32>() {
        Ok(n1) => {
            match s2.parse::<i32>() {
                Ok(n2) => {
                    Ok(n1 * n2)
                },
                Err(e) => Err(e),
            }
        },
        Err(e) => Err(e),
    }
}

fn multiply_v2(s1: &str, s2: &str) -> Result<i32, ParseIntError> {
    s1.parse::<i32>().and_then(|n1| {
        s2.parse::<i32>().map(|n2| n1 * n2)
    })
}

fn print(result: Result<i32, ParseIntError>) {
    match result {
        Ok(n) => println!("n is {}", n),
        Err(e) => println!("Error: {}", e),
    }
}

fn main() {
    let r1 = multiply_v2("32", "5");
    print(r1);

    let r2 = multiply_v2("12", "hk");
    print(r2);
}
```



# 3. 处理多种错误

## 3.1 从 Option 中取出 Result

处理混合错误类型的最基本手段就是让它们相互包容

```rust
use std::num::ParseIntError;

// 通过 Option 包装 Result
fn double_first_v1(vec: Vec<&str>) -> Option<Result<i32, ParseIntError>> {
    vec.first().map(|first| {
        first.parse::<i32>().map(|n| n * 2)
    })
}

// Option 和 Result 互换
fn double_first(vec: Vec<&str>) -> Result<Option<i32>, ParseIntError> {
    let opt = vec.first().map(|first| {
       first.parse::<i32>().map(|n| n * 2)
    });

    opt.map_or(Ok(None), |r| r.map(Some))
}

fn main() {
    let numbers = vec!["21", "42", "16"];
    let empty = vec![];
    let strings = vec!["do", "13", "20"];

    println!("The first double is {:?}", double_first(numbers));
    println!("The first double is {:?}", double_first(empty));
    println!("The first double is {:?}", double_first(strings));
}
```



## 3.2 自定义错误类型

自定义错误类型：

- 用同一个类型代表多种错误
- 向用户提供清楚的错误信息
- 能够容易地与其他类型比较
  - 好的例子：Err(EmptyVec)
  - 坏的例子：Err("Please use a vector with at least one element".to_owned())
- 能够容纳错误的具体信息
  - 好的例子：Err(BadChar(c, position))
  - 坏的例子：Err("+ cannot be used here".to_owned())
- 能够与其他错误很好地整合



标准库可复用的 `std::error::Error` 特征：

```rust
use std::fmt::{Debug, Display};

pub trait Error: Debug + Display {
    fn source(&self) -> Option<&(Error + 'static)> { .. }
}
```

自定义错误类型只需要实现 `Debug` 和 `Display` 特征即可，`source` 方法可选，而 `Debug` 特征往往也无需手动实现，可以直接通过 derive 来派生。



### 3.2.1 最简单的错误

```rust
use std::fmt::{self, Debug, Display};

// 自动派生Debug特征
#[derive(Debug)]
struct AppError;

impl Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "An error occurred, please try again.")
    } 
}

fn produce_error() -> Result<(), AppError> {
    Err(AppError)
}

fn main() {
    match produce_error() {
        Err(e) => eprintln!("{}", e),
        _ => println!("No error"),
    }
    
    eprintln!("{:?}", produce_error());
}
```

实现 Debug 和 Display特征并不是作为 `Err` 使用的必要条件，但实现它们有如下优势：

- 打印错误，需要实现这两个特征
- 可以将自定义错误转换为 `Box<dyn std::error::Error>` 特征对象，**归一化不同错误类型**



### 3.2.2 更详尽得错误

在错误中定义错误码和错误信息：

```rust
use std::fmt::{self, Debug, Display};

struct AppError {
    code: usize,
    message: String,
}

impl Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let err_msg = match self.code {
            404 => "Sorry, cann't find the page.",
            _ => "Sorry, something wrong, please try again.",
        };
    
        write!(f, "{}", err_msg)
    } 
}

impl Debug for AppError {
    fn fmt (&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "AppError {{ code: {}, message: {} }}", self.code, self.message)
    }
}

fn produce_error() -> Result<(), AppError> {
    Err(AppError {
        code: 404,
        message: "Page not found".to_string(),
    })
}

fn main() {
    match produce_error() {
        Err(e) => eprintln!("{}", e),
        _ => println!("No error"),
    }
    
    eprintln!("{:#?}", produce_error());
}
```



### 3.2.3 错误转换 `From` 特征

标准库 `std::convert::From` 特征：

```rust
pub trait From<T>: Sized {
    fn from(_: T) -> Self;
}
```



自定义错误实现 `From` 特征：

```rust
use std::fs::File;
use std::io;

#[derive(Debug)]
struct AppError {
    kind: String,
    message: String,
}

impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError {
            kind: String::from("io"),
            message: error.to_string(),
        }
    }
}

fn main() -> Result<(), AppError> {
    let _file = File::open("abc.txt")?; // "?"隐式强制转换，std::io::Error => AppError
    
    Ok(())
}
```



多个不同得错误转换成 `AppError` ：

```rust
use std::fs::File;
use std::io::{self, Read};
use std::num;

#[derive(Debug)]
struct AppError {
    kind: String,
    message: String,
}

impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError {
            kind: String::from("io"),
            message: error.to_string(),
        }
    }
}

impl From<num::ParseIntError> for AppError {
    fn from(error: num::ParseIntError) -> Self {
        AppError {
            kind: String::from("parse"),
            message: error.to_string(),
        }
    }
}

fn main() -> Result<(), AppError> {
    let mut file = File::open("abc.txt")?;
    
    let mut content = String::new();
    file.read_to_string(&mut content)?;
    
    let _number: usize;
    _number = content.parse()?;
    
    Ok(())
}
```



## 3.3 把错误装箱

如果想写简单的代码，又想保留原始错误信息，可将它们装箱 (Box)。但这样做的坏处是，被包装的错误类型，只能在运行时了解，而不能被静态地判别。

对任何实现了 Error trait 的类型，标准库 Box 通过 From 为其提供到 `Box<Error>` 的转换

```rust
use std::{error, fmt};

type Result<T> = std::result::Result<T, Box<dyn error::Error>>;

#[derive(Debug, Clone)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "invalid first item to double")
    }
}

impl error::Error for EmptyVec {
    fn description(&self) -> &str {
        "invalid first item to double"
    }

    fn cause(&self) -> Option<&dyn error::Error> {
        None
    }
}

fn double_first(vec: Vec<&str>) -> Result<i32> {
    vec.first()
        .ok_or_else(|| EmptyVec.into())  // 装箱
        .and_then(|s| {
            s.parse::<i32>()
                .map_err(|e| e.into()) // 装箱
                .map(|n| n * 2)
        })
}

fn print(result: Result<i32>) {
    match result {
        Ok(n) => println!("The first double is {}", n),
        Err(e) => println!("Error: {}", e),
    }
}

fn main() {
    let numbers = vec!["21", "42", "16"];
    let empty = vec![];
    let strings = vec!["do", "13", "20"];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
```



## 3.4 使用 `?`

在上个示例中，调用 parse 后总是立即将错误从标准库的错误 map 到装箱错误，但 and_then 不够灵活：

```rust
.and_then(|s| s.parse::<i32>()
	.map_err(|e| e.into()))
```

`?` 的解释：

- unwrap
- `return Err(From::from(err))`

由于 `From::from` 是不同类型之间的转换工具，也就是说，如果在错误可转换成返回类型地方使用 `?`，它将自动转换成返回类型

```rust
use std::{error, fmt};

type Result<T> = std::result::Result<T, Box<dyn error::Error>>;

#[derive(Debug, Clone)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "invalid first item to double")
    }
}

impl error::Error for EmptyVec {

}

fn double_first(vec: Vec<&str>) -> Result<i32> {
    // 使用 `?` 立即得到内部值
    let first = vec.first().ok_or(EmptyVec)?;
    let parsed = first.parse::<i32>()?;
    Ok(parsed * 2)
}
fn print(result: Result<i32>) {
    match result {
        Ok(n) => println!("The first double is {}", n),
        Err(e) => println!("Error: {}", e),
    }
}

fn main() {
    let numbers = vec!["21", "42", "16"];
    let empty = vec![];
    let strings = vec!["do", "13", "20"];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
```



## 3.5 包裹错误

将错误装箱改成把它包裹到自定义的错误类型中

```rust
use std::{error, fmt};
use std::num::ParseIntError;

type Result<T> = std::result::Result<T, DoubleError>;

#[derive(Debug, Clone)]
enum DoubleError {
    EmptyVec,
    Parse(ParseIntError),
}

impl fmt::Display for DoubleError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match *self {
            DoubleError::EmptyVec => {
                write!(f, "invalid first item to double")
            },
            DoubleError::Parse(ref e) => e.fmt(f),
        }
    }
}

impl error::Error for DoubleError {
    fn source(&self) -> Option<&(dyn error::Error + 'static)> {
        match *self {
            DoubleError::EmptyVec => None,
            DoubleError::Parse(ref e) => Some(e),
        }
    }
}

impl From<ParseIntError> for DoubleError {
    fn from(e: ParseIntError) -> Self {
        DoubleError::Parse(e)
    }
}

fn double_first(vec: Vec<&str>) -> Result<i32> {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    let parsed = first.parse::<i32>()?;
    Ok(parsed * 2)
}

fn print(result: Result<i32>) {
    match result {
        Ok(n) => println!("The first double is {}", n),
        Err(e) => println!("Error: {}", e),
    }
}

fn main() {
    let numbers = vec!["21", "42", "16"];
    let empty = vec![];
    let strings = vec!["do", "13", "20"];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
```



# 4. 遍历 Result

`Item::map` 操作可能失败：

```rust
fn main() {
    let strings = vec!["do", "12", "37"];
    let numbers: Vec<_> = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();

    println!("Results: {:?}", numbers);
}
```



## 4.1 `filter_map` 忽略失败项

`filter_map` 会调用一个函数，过滤掉为 `None` 的所有结果

```rust
fn main() {
    let strings = vec!["do", "12", "37"];
    let numbers: Vec<_> = strings
        .into_iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();

    println!("Result: {:?}", numbers);
}
```



## 4.2 `collect()` 使整个操作失败

`Result` 实现了 `FromIter`，因此结果的向量（`Vec<Result<T, E>>`）可以被转换成结果包裹着向量（`Result<Vec<T>, E>`）。一旦找到一个 `Result::Err` ，遍历就被终止

```rust
fn main() {
    let strings = vec!["do", "12", "37"];
    let numbers: Result<Vec<_>, _>= strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();

    println!("Result: {:?}", numbers);
}
```



## 4.3 `partition()` 收集所有合法的值与错误

```rust
fn main() {
    let strings = vec!["do", "12", "37"];
    let (numbers, errors): (Vec<_>, Vec<_>) = strings
        .into_iter()
        .map(|s| s.parse::<i32>())
        .partition(Result::is_ok);

    println!("numbers: {:?}, errors: {:?}", &numbers, errors);

    let numbers: Vec<_> = numbers.into_iter().map(Result::unwrap).collect();
    println!("numbers: {:?}", numbers);

    let errors: Vec<_> = errors.into_iter().map(Result::unwrap_err).collect();
    println!("errors: {:?}", errors);
}
```



# 5. 归一化不同错误类型

归一化错误得三种方式：

- 使用特征对象 `Box<dyn Error>`
- 自定义错误类型
- 使用 `thiserror`



## 5.1 `Box<dyn Error>`

自定义错误实现 `Debug + Display` 特征得主要原因就是为了转换成 `Error` 特征对象，而特征对象恰恰是在同一个地方使用不同类型得关键：

```rust
use std::error::Error;

fn render() -> Result<String, Box<dyn Error>> {
    let file = std::env::var("MARKDOWN")?;
    let source = std::fs::read_to_string(file)?;
    Ok(source)
}

fn main() {
    match render() {
        Err(e) => eprintln!("An error occurred: {}", e),
        _ => println!("No error"),
    }
}
```

存在的问题：`Result` 实际上不会限制错误的类型，即一个类型就算不实现 `Error` 特征，它依然可以在 `Result<T, E>` 中作为 `E` 来使用，此时这种特征对象的解决方案是无能无力的。



## 5.2 自定义错误类型

与特征对象相比，自定义错误类型虽然麻烦，但它非常灵活，不会有上面的类似限制：

```rust
fn render() -> Result<String, MyError> {
    let file = std::env::var("MARKDOWN")?;
    let source = std::fs::read_to_string(file)?;
    Ok(source)
}

fn main() {
    match render() {
        Err(e) => eprintln!("An error occurred: {}", e),
        _ => println!("No error"),
    }
}

#[derive(Debug)]
enum MyError {
    EnvironmentVariableNotFound,
    IOError(std::io::Error),
}

impl From<std::env::VarError> for MyError {
    fn from(_: std::env::VarError) -> Self {
        Self::EnvironmentVariableNotFound
    }
}

impl From<std::io::Error> for MyError {
    fn from(err: std::io::Error) -> Self {
        Self::IOError(err)
    }
}

impl std::error::Error for MyError {}

impl std::fmt::Display for MyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MyError::EnvironmentVariableNotFound => write!(f, "Environment variable not found"),
            MyError::IOError(err) => write!(f, "IO Error: {}", err.to_string()),
        }
    }
}
```



# 6. anyhow

## 6.1 错误统一处理问题

**问题一：错误类型泛型爆炸**

应用存在多个 error 来源，需同时兼容多种错误

```rust
fn read_config() -> Result<String, std::io::Error>;
fn parse_config() -> Result<Config, ParseError>;
```

调用时需要定义一个枚举，并要手动实现 From

```rust
enum AppError {
    Io(std::io::Error),
    Parse(ParseError),
}
```



**问题二：缺乏错误上下文与 backtrace**

标准库 Error 定义：

```rust
pub trait Error: Debug + Display {
    fn source(&self) -> Option<&(dyn Error + 'static)> { None }
}
```

- 如果通过 `Result<(), Box<dyn std::error::Error + Send + Sync>>` 统一错误，则会失去静态类型信息
- 有内建 `backtrace` 和上下文字符串 (如 “连接数据库失败: url=xxx”)，如果没有 trace，问题排查起来如同地狱探宝



## 6.2 核心定义

**1、核心类型定义**

```rust
pub struct Error {
    inner: Box<dyn std::error::Error + Send + Sync + 'static>
}
```

该设计保证：

- `Send + Sync`：可在线程间传递，适用于 tokio 等异步运行时
- `'static`：满足 Future 生命周期要求
- Box 动态分发：运行包装任意错误类型，实现统一处理



**2、对比其它库，确定边界**

| 库          | 面向场景        | 是否需定义错误枚举 | 是否支持上下文     | backtrace | 异步兼容性 |
| :---------- | :-------------- | :----------------- | :----------------- | :-------- | :--------- |
| `thiserror` | 底层库          | ✅ 需要显式定义     | ❌（需结合 anyhow） | ❌         | ✅          |
| `snafu`     | 嵌入式/严格类型 | ✅ 强类型枚举       | ✅ 通过宏生成       | ✅         | ✅          |
| `eyre`      | 应用层+库       | ❌ 动态错误         | ✅ 自动上下文       | ✅         | ✅          |
| `anyhow`    | 应用层          | ❌ 动态错误         | ✅ 自动上下文       | ✅         | ✅          |



## 6.3 核心API

### 6.3.1 基础使用

`?` 自动将 `std::io::Error` 转换为 `anyhow::Error`，简化错误类型管理

```rust
use anyhow::Result;
use std::fs::File;
use std::io::Read;

fn read_file(path: &str) -> Result<String> {
    let mut s = String::new();
    File::open(path)?.read_to_string(&mut s)?;
    Ok(s)
}

fn main() -> Result<()> {
    let content = read_file("Cargo.toml")?;
    println!("{}", content);
    Ok(())
}
```



### 6.3.2 错误创建

#### 6.3.2.1  `anyhow!` 创建错误

支持类型的格式化输出，比 `std::io::Error::new` 更简洁

```rust
use anyhow::{anyhow, Result};

fn fail() -> Result<()> {
    Err(anyhow!("Something went wrong: {}", 42))
}
```



#### 6.3.2.2 `bail!` 直接返回错误

`bail!` 相当于 `return Err(anyhow!(...))` 展开

```rust
use anyhow::{bail, Result};

fn check(value: i32) -> Result<()> {
    if value < 0 {
        bail!("{} is not a negative value.", value);
    }
    Ok(())
}
```



#### 6.3.2.3 `ensure!` 进行条件校验

可以替代 `if !condition { return Err(...) }`

```rust
use anyhow::{ensure, Result};

fn validate(value: i32) -> Result<()> {
    ensure!(value > 0, "value must be positive");
    Ok(())
}
```



### 6.3.3 上下文增强机制

#### 6.3.3.1 context() 和 with_content()

调用时每一层都插入错误链，最终打印堆栈时显示详细信息。context() 通过 trait Context 提供的 `ResultExt` 方法实现，内部调用 `map_err` 将错误包装为带有上下文的 `anyhow::Error`

```rust
use anyhow::{Context, Result};
use std::fs::File;
use std::io::Read;

fn read_file(path: &str) -> Result<String> {
    let mut s = String::new();
    File::open(path)
        .with_context(|| format!("Failed to open file {}", path))?
        .read_to_string(&mut s)
        .context("Failed to read file")?;
    Ok(s)
}
```



#### 6.3.3.2 链式 Context

```rust
use anyhow::{Context, Result};

fn read_config() -> Result<String> {
    std::fs::read_to_string("config.toml").context("Failed to read config file.")
}

fn parse_config() -> Result<()> {
    let content = read_config().context("Failed to read config file")?;
    println!("{content}");
    Ok(())
}

fn main() {
    if let Err(e) = parse_config() {
        eprintln!("Error: {e:?}");

        for cause in e.chain().skip(1) {
            eprintln!("\tcaused by: {}", cause);
        }
    }
}
```



### 6.3.4 捕获并封装panic

为防止程序崩溃和统一打印错误链条，需要捕获 panic。包装 panic 为 anyhow error

```rust
use anyhow::{Error, Result};
use std::panic;

fn run_safely() -> Result<(), Error> {
    let result = panic::catch_unwind(|| {
        panic!("Safely panicked!");
    });

    match result {
        Ok(_) => Ok(()),
        Err(e) => {
            let msg = if let Some(s) = e.downcast_ref::<&str>() {
                s.to_string()
            } else if let Some(s) = e.downcast_ref::<String>() {
                s.clone()
            } else {
                "Unknown panic".to_string()
            };
            Err(Error::msg(msg))
        }
    }
}

fn main() -> Result<(), Error> {
    run_safely()?;
    Ok(())
}
```



## 6.4 异步函数

### 6.4.1 async/await 的错误传递

- async 函数返回 `anyhow::Result<T>` 时，`?` 运算符任然可用
- `anyhow::Error` 是 `Send + Sync + 'static`，保证跨线程安全

```rust
use anyhow::{Context, Result};
use reqwest;

async fn fetch_data(url: &str) -> Result<String> {
    let resp = reqwest::get(url)
        .await
        .with_context(|| format!("Failed to fetch data from {}", url))?;

    let body = resp.text().await.context("Failed to read response body")?;
    Ok(body)
}

#[tokio::main]
async fn main() {
    // let url = "https://httpbin.org/get";
    let url = "https://google.com";
    let result = fetch_data(url).await;

    match result {
        Ok(data) => println!("{}", data),
        Err(e) => eprintln!("Error: {}", e),
    }
}
```



### 6.4.2 `tokio::spawn` 与 `JoinError`

`JoinError` 可转换为 `anyhow::Error` ，保持统一错误处理

```rust
use anyhow::Error;

#[tokio::main]
async fn main() {
    let handle = tokio::spawn(async {
        panic!("task failed");
    });

    let result = handle.await.map_err(|e| Error::new(e));
    if let Err(e) = result {
        eprintln!("Caught error: {:?}", e);
    }
}
```



### 6.4.3 捕获 backtrace

- `async::Error` 内部封装了一个 `std::backtrace::Backtrace`
- 在创建 Error 的时候 ( `anyhow!(...)` 或 `.context()` 调用时) 就自动捕获堆栈
- 异步函数中 `.await` 不会破坏 backtrace 链，因为它在错误创建时固定下来的

```rust
use anyhow::{anyhow, Result};

async fn do_something() -> Result<()> {
    let err = anyhow!("async task failed");

    // anyhow 1.0.57-
    // if let Some(bt) = anyhow::Error::backtrace(&err) {
    //     println!("{bt}");
    // }

    let bt = err.backtrace();
    println!("Captured backtrace:\n{bt}");

    Err(err)
}

#[tokio::main]
async fn main() -> Result<()> {
    do_something().await?;
    Ok(())
}
```

需要设置环境变量`RUST_BACKTRACE=1 cargo run`，backtrace 才会在 Display 中展开。



### 6.4.4 捕获 panic 兜底

- Rust 的异步 panic 不会传播到其它任务，只会导致该 `JoinHandle` 报错
- `JoinError` 提供了 `.is_panic()` 和 `.into_panic()` 方法
- 可以将 panic 封装为 `anyhow::Error` 保持统一错误模型，保证服务不中断

```rust
use anyhow::{Error, Result};
use std::panic;

#[tokio::main]
async fn main() -> Result<()> {
    let handle = tokio::spawn(async {
        panic!("something went terribly wrong");
    });

    match handle.await {
        Ok(_) => println!("Task finished normally!"),
        Err(e) => {
            if e.is_panic() {
                // 将 panic 转换为 anyhow::Error
                let err: Error = Error::msg(format!("caught panic: {}", e));
                println!("Recovered from async panic: {:?}", err);
            }
        }
    }

    Ok(())
}
```

注意：同步用 `std::panic::catch_unwind` 与 `async` 原理一致



# 7. thiserror

## 7.1 入门

### 7.1.1 错误处理问题

手写错误格式化输出 (Display) 和 转换 (From)

```rust
use std::fmt;

#[derive(Debug)]
pub enum MyError {
    Config(String),
    Io(std::io::Error),
}

impl fmt::Display for MyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            MyError::Config(s) => write!(f, "Config error: {}", s),
            MyError::Io(e) => write!(f, "Io error: {}", e),
        }
    }
}

impl std::error::Error for MyError {}

impl From<std::io::Error> for MyError {
    fn from(e: std::io::Error) -> Self {
        MyError::Io(e)
    }
}
```



### 7.1.2 `thiserror`

`thiserror` 提供了一个派生宏 `#[derive(thiserror::Error)]` ，用于生成自定义错误枚举或结构的模板代码，包括 `std::error::Error` 特征的实现。

主要功能：

- 允许创建具有特定变体的强类型自定义错误类型
- 自动实现 `std::error::Error`、Display，并可选择 From 将其它错误类型转换为自定义错误
- 支持为错误添加上下文或信息，并将它们与源错误关联起来 （用于链式处理）
- 生成简洁，经过编译时检查的错误处理代码

```rust
use std::fs::File;
use std::io::{self, Read};
use thiserror::Error;

#[derive(Debug, Error)]
enum AppError {
    // IO 错误自动转换
    #[error("I/O error: {0}")]
    Io(#[from] io::Error),

    // 自定义错误
    #[error("Invalid config: {0}")]
    InvalidConfig(String),

    // anyhow 兜底错误
    #[error("Internal error: {0}")]
    Internal(#[from] anyhow::Error),
}

fn read_config(path: &str) -> Result<String, AppError> {
    let mut file = File::open(path)?;
    let mut contents = String::new();

    file.read_to_string(&mut contents)?;

    if !contents.starts_with("version") {
        return Err(AppError::InvalidConfig(
            "missing version field at the beginning".into(),
        ));
    }

    Ok(contents)
}

fn main() -> Result<(), AppError> {
    match read_config("config.txt") {
        Ok(contents) => println!("contents: {}", contents),
        Err(err) => println!("error: {}", err),
    }

    Ok(())
}
```



## 7.2 核心 API

### 7.2.1 `#[derive(thiserror::Error)]` 

- `#[derive(thiserror::Error)]`：注解枚举或结构体字段

- `#[error("message")]`：为属性指定错误信息

```rust
use thiserror::Error;

#[derive(Debug, Error)]
enum MyError {
    // IO 错误自动转换
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    // 自定义错误
    #[error("Custom error: {msg}")]
    Custom { msg: String },
}

fn io_error() -> Result<(), MyError> {
    std::fs::read_to_string("not-found.txt").map_err(MyError::Io)?;
    Ok(())
}

fn custom_error() -> Result<(), MyError> {
    Err(MyError::Custom {
        msg: "Invalid status".into(),
    })
}

fn main() {
    println!("{}", io_error().unwrap_err()); // 调用 Display
    println!("{:?}", io_error().unwrap_err()); // 调用 Debug

    println!("{}", custom_error().unwrap_err());
    println!("{:?}", custom_error().unwrap_err());
}
```



### 7.2.2 `#[from]` 自动转换

```rust
use thiserror::Error;

#[derive(Debug, Error)]
enum AppError {
    #[error("Parse error: {0}")]
    Parse(#[from] std::num::ParseIntError),
}

fn str2num(s: &str) -> Result<i32, AppError> {
    let num: i32 = s.parse()?;
    Ok(num)
}

fn main() {
    println!("{}", str2num("42").unwrap_err());
    println!("{}", str2num("foo").unwrap_err());
}
```



`#[from]` 自动为 `AppError` 实现 `From`：

```rust
impl From<ParseIntError> for AppError {
    fn from(err: ParseIntError) -> Self {
        AppError::Parse(err)
    }
}
```



### 7.2.3 `#[source]` 返回底层错误

`std::error::Error` trait 有一个方法 `fn source(&self) -> Option<&(dyn Error + 'static)>`  它用于返回 底层引起当前错误的原始错误，可以构建错误链 (error chain)，方便调试和日志打印。

`#[source]` 显式标记一个字段是 “底层错误”，生成的 `Error::source()` 会返回这个字段

```rust
use std::error::Error;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum DbError {
    #[error("数据库查询失败: {query}")]
    Query {
        query: String,
        #[source]
        source: std::io::Error,
    },
}

#[derive(Debug, Error)]
enum AppError {
    #[error("业务处理失败: {0}")]
    DbError(#[from] DbError),

    #[error("解析失败: {0}")]
    Parse(#[from] std::num::ParseIntError),
}

fn db_layer() -> Result<(), DbError> {
    let io_err = std::io::Error::new(std::io::ErrorKind::NotFound, "文件不存在");
    Err(DbError::Query {
        query: "SELECT *".into(),
        source: io_err,
    })
}

fn app_layer() -> Result<(), AppError> {
    // 底层 db_layer 错误通过 #[from] 自动转成 AppError::Db
    db_layer()?;
    Ok(())
}

fn main() {
    let err = app_layer().unwrap_err();

    println!("Display: {}", err);

    // 遍历多层 source
    let mut source = err.source();
    let mut level = 1;

    while let Some(s) = source {
        println!("Source level {}: {} ({:?})", level, s, s);
        source = s.source();
        level += 1;
    }
}
```

`#[source]` 标记底层错误，配合 `Error::source()` 访问层错误：

- 最顶层：`AppError::Db`
  - Display："业务处理失败：数据库查询失败：SELECT *"
  - source()：`DbError::Query`
- 中间层：`DbError::Query`
  - Display："数据库查询失败：SELECT *"
  - source()：`io::Error`

- 底层：`io::Error`

  - Display："文件不存在"

  - source()：None



### 7.2.4 `#[error(transparent)]`

- 封装底层 error，透明传递底层错误，不额外加前缀或信息
- 常用于底层错误封装 + `#[from]` 自动转换

```rust
use thiserror::Error;

#[derive(Debug, Error)]
pub enum MyError {
    #[error(transparent)]
    Io(#[from] std::io::Error),
}

fn read_file() -> Result<String, MyError> {
    let content = std::fs::read_to_string("main.rs")?; // io::Error -> MyError::Io
    Ok(content)
}

fn main() {
    let err = read_file().unwrap_err();

    println!("Display: {}", err);
    println!("Source: {:?}", err);
}
```

注意：只支持单个字段

```rust
#[error(transparent)]
Io(#[from] io::Error); // 编译通过
Io { source: std::io::Error, code: i32 } // 编译失败，不支持多个字段
```



### 7.2.5 backtrace

捕获构造错误时的错误栈，`thiserror` 自动调用 `Backtrace::capture()` 存进去

```rust
#[derive(this::Error, Debug)]
pub enum MyError {
    #[error("IO 失败")]
    Io {
        #[from]
        source: std::io::Error,
        
        #[backtrace]
        backtrace: std::backtrace::Backtrace,
    }
}
```



## 7.3 高级技巧

### 7.3.1 用 `#[error(transparent)]` 实现 "error wrapper"

```rust
#[derive(Error, Debug)]
pub enum AppError {
    #[error(transparent)]
    Db(#[from] sqlx::Error),
    
    #[error(transparent)]
    Anyhow(#[from] anyhow::Error),
    
    #[error("业务错误：{0}")]
    Biz(String),
}
```

- 统一错误出口
- `SQLx / Reqwest / IO / Anyhow` 的错误自动转型
- 最后 `AppError` 做 API / Trace 转换



### 7.3.2 结合 `#[source]` 与上下文 (Context) 字段

结构化处理错误，解决只有底层保持但缺乏业务上下文 (如文件名、行号、请求ID) 的问题

```rust
use thiserror::Error;

#[derive(Debug, Error)]
pub enum ConfigError {
    #[error("读取配置文件 {path} 失败")]
    ReadFailed {
        path: std::path::PathBuf,
        #[source]
        source: std::io::Error,
    },
}

fn load_config(path: std::path::PathBuf) -> Result<(), ConfigError> {
    std::fs::File::open(&path).map_err(|e| ConfigError::ReadFailed {
        path: path.clone(),
        source: e,
    })?;
    Ok(())
}

fn main() {
    let path = std::path::PathBuf::from("config.json");
    if let Err(e) = load_config(path) {
        eprintln!("{}", e);

        // 验证 source
        use std::error::Error;
        if let Some(src) = e.source() {
            eprintln!("Caused by: {}", src);
        }
    }
}

// Output
// 读取配置文件 config.json 失败
// Caused by: The system cannot find the file specified. (os error 2)
```



### 7.3.3 处理泛型错误 (Generic Errors)

错误类型需要包含用户自定义的数据类型，或者错误的具体类型由泛型决定

```rust
use std::fmt::Debug;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum ParseError<T: Debug + std::fmt::Display> {
    #[error("在位置 {location} 发现非法 Token: {token}")]
    InvalidToken { location: usize, token: T },

    #[error("未知错误")]
    Unknown,
}

fn main() {
    let err = ParseError::InvalidToken {
        token: "EOF",
        location: 42,
    };

    println!("{}", err);
}
```



### 7.3.4 错误模块化

错误定义：

```rust
errors/
    ├─ mod.rs
    ├─ io_error.rs
    ├─ service_error.rs
    └─ db_error.rs
```

统一 wrap：

```rust
#[derive(Error, Debug)]
pub enum AppError {
    #[error(transparent)]
    Io(#[from] IoError),

    #[error(transparent)]
    Db(#[from] DbError),
}
```



# 8. anyhow 和 `thiserror`

## 8.1 对比

| 功能/属性    | `thiserror`                | `anyhow`                                |
| ------------ | -------------------------- | --------------------------------------- |
| **目的**     | 自定义的强类型错误类型     | 通用错误类型简化错误处理                |
| **错误类型** | 自定义枚举、结构体         | 单一`anyhow::Error`类型                 |
| **使用案例** | 库、复杂错误处理           | 应用、原型开发、简单错误处理            |
| **类型安全** | 强类型、显式变量           | 动态、包罗万象的错误类型                |
| **模板**     | 需要定义错误类型           | 模板最少，无需自定义类型                |
| **错误链**   | 使用`#[from]`显式          | `.context()`或`.with_context()`隐式实现 |
| **目标受众** | 库作者、需要精细控制的用户 | 应用程序开发人员，快速迭代              |
| **性能**     | 性能略高（静态调度）       | 性能略低（动态调度）                    |



`thiserror` 负责“产出”错误，`anyhow` 负责“消费”错误。

- 库代码用 `thiserror`，比如db，cache
- 业务层优先` thiserror`，复杂链路可结合，错误穿透到 main用anyhow
  - 数据库、HTTP、序列化：**thiserror**
  - 入口层（Controller / handler）：**anyhow + Context**
- 在 Web 服务中，通常 Controller/Handler 层是分界线。
  - Service 层返回 `Result<T, AppError>` (用 `thiserror`)。
  - Handler 捕获 `AppError`，将其转换为 HTTP Response。
  - 如果 Service 层遇到意料之外的 bug（比如 panic 或不可恢复的 IO 错），才会被 `anyhow` 捕获并记录为 500 错误。



## 8.2 结合

配合错误枚举，应用层再转换为 `anyhow::Result<T>`

**任何实现了 `Error + Send + Sync + 'static` 的类型，都可以自动转为 `anyhow::Error`**

```rust
use anyhow::Result;
use thiserror::Error;

#[derive(Error, Debug)]
pubenum MyLibError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Parse error: {0}")]
    Parse(#[from] serde_json::Error),
}

fn lib_function() -> std::result::Result<String, MyLibError> {
    let content = std::fs::read_to_string("file.json")?;
    let _val: serde_json::Value = serde_json::from_str(&content)?;
    Ok(content)
}

fn app_function() -> Result<String> {
    let res = lib_function()?; // 自动转换为 anyhow::Error
    Ok(res)
}
```



## 8.3 tracing_error

结合 `tracing-error` crate，`tracing-error` 提供 `InstrumentedErrorLayer`，能自动把 `anyhow::Error` 的链合并为一条漂亮的日志。

```rust
use anyhow::{Context, Result};
use futures::future::join_all;
use reqwest;
use tracing::{error, info, instrument};
use tracing_error::ErrorLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

#[tokio::main]
asyncfn main() -> Result<()> {
    // 初始化 tracing subscriber
    tracing_subscriber::registry()
        .with(tracing_subscriber::fmt::layer()) // 格式化输出
        .with(ErrorLayer::default()) // 捕获 tracing span 上下文
        .init();

    info!("Starting fetch tasks...");

    let urls = vec![
        "https://httpbin.org/get",
        "https://invalid.example",
        "https://httpbin.org/status/404",
    ];

    ifletErr(e) = fetch_urls(urls).await {
        error!(error = ?e, "Top-level error occurred");
    }

    Ok(())
}

#[instrument]// 自动为函数创建 tracing span
asyncfn fetch_urls(urls: Vec<&str>) -> Result<Vec<String>> {
    let futures = urls.into_iter().map(|url| asyncmove {
        fetch_one(url).await
            .with_context(|| format!("fetch failed for URL: {}", url))
    });

    let results = join_all(futures).await;

    // 遍历每个请求结果
    for result in &results {
        ifletErr(err) = result {
            // 使用 tracing-error 捕获 span trace
            let span_trace = tracing_error::SpanTrace::capture();
            error!(
                error = ?err,
                trace = ?span_trace,
                "Request failed with context chain"
            );
        }
    }

    // 收集成功结果
    let ok_results = results
        .into_iter()
        .filter_map(Result::ok)
        .collect::<Vec<_>>();

    Ok(ok_results)
}

#[instrument]
asyncfn fetch_one(url: &str) -> Result<String> {
    let response = reqwest::get(url)
        .await
        .context("HTTP request failed")?;

    let status = response.status();

    if !status.is_success() {
        anyhow::bail!("Received non-success status: {}", status);
    }

    let text = response
        .text()
        .await
        .context("Failed to read response body")?;

    Ok(text)
}
```



输出：

```
2025-10-25T15:14:13.343867Z ERROR fetch_urls{urls=["https://httpbin.org/get", "https://invalid.example", "https://httpbin.org/status/404"]}: anyhow_tracing_demo: Request failed with context chain error=fetch failed for URL: https://invalid.example

Caused by:
    0: HTTP request failed
    1: error sending request for url (https://invalid.example/)
    2: client error (Connect)
    3: dns error
    4: failed to lookup address information: nodename nor servname provided, or not known
```















