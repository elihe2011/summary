# 1. å‡½æ•°

## 1.1 å®šä¹‰

```rust
fn func_name(para1: T, para2: T) -> T {
    
}
```

- å‡½æ•°åï¼šè›‡å½¢å‘½å(snake_case)
- è¿”å›å€¼ï¼š`-> T`



## 2.2 å‚æ•°

å‡½æ•°å‚æ•°å’Œå˜é‡ä¸€æ ·ï¼Œé»˜è®¤æ˜¯ä¸å¯å˜çš„ï¼Œå½“éœ€è¦å¯å˜å‚æ•°æ—¶ï¼Œä¸€æ ·å¾—ä½¿ç”¨ mut å…³é”®å­—

**æŒ‰å€¼ä¼ é€’**ï¼š

```rust
fn main() {
    let v = vec![1, 2, 3];
    let v = modify(v);  // shadow
    println!("{:?}", v);
}

fn modify(mut v: Vec<u32>) -> Vec<u32> {
    v.push(4);
    v
}
```



**æŒ‰å¼•ç”¨ä¼ é€’ï¼š**

```rust
fn main() {
    let mut v = vec![1, 2, 3];
    modify(&mut v);
    println!("{:?}", v);
}

fn modify(v: &mut Vec<u32>) {
    v.push(4)
}
```



## 2.3 è¿”å›å€¼

å¦‚æœæ²¡æœ‰è¿”å›å€¼ï¼Œ`->` ä¸å†™ï¼Œé»˜è®¤è¿”å›çš„ç±»å‹æ˜¯å•å…ƒå€¼ `()`ã€‚æ‰€ä»¥ï¼Œä¹Ÿå¯ä»¥æ˜¾ç¤ºè¿”å›è¯¥ç±»å‹ã€‚

```rust
fn main() {
    let (x, y) = swap(2, 3);
    println!("x={}, y={}", x, y);
}

fn swap(x: i32, y: i32) -> (i32, i32) {
    (y, x)
}
```



# 2. é—­åŒ…

é—­åŒ… (closure) ä¹Ÿå« lambda è¡¨è¾¾å¼ï¼Œæ˜¯ä¸€ç±»èƒ½å¤Ÿæ•è·å‘¨å›´ä½œç”¨åŸŸä¸­å˜é‡çš„å‡½æ•°ã€‚**é—­åŒ…å°±åƒæ˜¯ä¸€ä¸ªâ€œå¸¦è®°å¿†çš„å‡½æ•°â€**ã€‚

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1;
```

é—­åŒ…ç‰¹ç‚¹ï¼š

- å£°æ˜æ—¶ä½¿ç”¨ `||` æ›¿ä»£ `()` å°†è¾“å…¥å‚æ•°æ‹¬èµ·æ¥
- å‡½æ•°å®šç•Œç¬¦ `{}` å¯¹å•ä¸ªè¡¨è¾¾å¼æ˜¯å¯é€‰çš„ï¼Œå…¶ä»–æƒ…å†µå¿…é¡»åŠ ä¸Š
- **æœ‰èƒ½åŠ›æ•è·å¤–éƒ¨ç¯å¢ƒçš„å˜é‡**

```rust
fn main() {
    fn function(i: i32) -> i32 { i + 1 }

    let closure_annotated = |i: i32| -> i32 { i + 1 };
    let closure_inferred = |i| i + 1;

    // è°ƒç”¨ï¼Œå‡è¿”å›2
    let i = 1;
    println!("function: {}", function(i));
    println!("closure_annotated: {}", closure_annotated(i));
    println!("closure_inferred: {}", closure_inferred(i));

    // æ— è¾“å…¥å€¼
    let one = || 1;
    println!("closure returning one: {}", one());
}
```



## 2.1 æ•è·å˜é‡

**é—­åŒ…æœ¬è´¨ä¸Šæ˜¯åŒ…å«åŒ¿åå‡½æ•°å’Œå…¶æ‰§è¡Œç¯å¢ƒçš„ç»“æ„ä½“**ã€‚å½“é—­åŒ…æ•è·å¤–éƒ¨å˜é‡æ—¶ï¼Œç¼–è¯‘å™¨ä¼šæ ¹æ®å˜é‡çš„ä½¿ç”¨æ–¹å¼è‡ªåŠ¨æ¨å¯¼æ•è·æ–¹å¼ï¼š

- ä¸å¯å˜å¼•ç”¨æ•è· (`&T`)
- å¯å˜å¼•ç”¨æ•è· (`&mut T`)
- æ‰€æœ‰æƒè½¬ç§»æ•è· (`T`)



### 2.1.1 FnOnceï¼šåå™¬å‹é—­åŒ… (è·å–æ‰€æœ‰æƒ)

```rust
fn main() {
    let data = vec![1, 2, 3];
    
    // è¯¥é—­åŒ…ä¼šâ€œåƒæ‰â€ data
    let consume = || {
        mem::drop(data); // è·å–æ‰€æœ‰æƒå¹¶é‡Šæ”¾
        println!("æ•°æ®å·²è¢«æ¶ˆè´¹ï¼");
    };
    
    consume();
    //consume();  // æ— æ³•å†æ¬¡è¢«è°ƒç”¨
}
```

é€‚ç”¨åœºæ™¯ï¼šéœ€è¦è½¬ç§»æ‰€æœ‰æƒæ—¶ï¼Œæ¯”å¦‚å°†æ•°æ®å‘é€åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ã€‚



### 2.1.2 FnMutï¼šå¯å˜å€Ÿç”¨å‹é—­åŒ…

```rust
fn main() {
    let mut counter = 0;
    
    // è¯¥é—­åŒ…å¯å˜å€Ÿç”¨äº† counter
    let mut increment = || {
        counter += 1;
        counter
    };
    
    println!("{}", increment());  // 1
    println!("{}", increment());  // 2
}
```

é€‚ç”¨åœºæ™¯ï¼šéœ€è¦ä¿®æ”¹æ•è·çš„å˜é‡æ—¶



### 2.1.3 Fnï¼šä¸å¯å˜å€Ÿç”¨é—­åŒ…

```rust
fn main() {
    let greeting = String::from("Hello");
    
    // è¯¥é—­åŒ…åªè¯»å– greeting
    let say_hi = |name: &str| {
        println!("{}, {}!", greeting, name);
    }
    
    say_hi("Alice");
    say_hi("Bob");
    
    // greeting ä»å¯ä½¿ç”¨
    println!("{}", greeting);
}
```

é€‚ç”¨åœºæ™¯ï¼šæœ€å¸¸è§çš„æƒ…å†µï¼Œåªè¯»ç¯å¢ƒå˜é‡



## 2.2 ä½œä¸ºè¾“å…¥å‚æ•°

é—­åŒ…ä½œä¸ºå‡½æ•°å‚æ•°ï¼Œè¦æ±‚é—­åŒ…æ—¶æ³›å‹çš„ï¼Œé—­åŒ…å®šä¹‰çš„æ–¹å¼å†³å®šäº†è¿™æ˜¯å¿…è¦çš„ã€‚

ç¼–è¯‘å™¨ä¼šéšå¼åœ°ä¸ºé—­åŒ…åˆ›å»ºä¸€ä¸ªåŒ¿åç±»å‹çš„ç»“æ„ä½“ï¼Œç”¨ä»¥å­˜å‚¨é—­åŒ…æ•è·çš„å˜é‡ï¼ŒåŒæ—¶ä¸ºè¿™ä¸ªæœªçŸ¥ç±»å‹çš„ç»“æ„ä½“å®ç°å‡½æ•°åŠŸèƒ½ï¼Œé€šè¿‡ `Fn`ã€`FnMut`æˆ– `FnOnce` ä¸‰ç§ `trait` ä¸­çš„ä¸€ç§ã€‚å…¶**é—­åŒ…å˜é‡æ•è·æ–¹å¼å—é™ç¨‹åº¦æŒ‰ä»¥ä¸‹é¡ºåºé€’å‡**ï¼š

```rust
// æ¥æ”¶ä»»ä½•é—­åŒ…
fn dynamic_dispatch<F: FnOnce()>(f: F) {
    f()
}

// ä»…æ¥å—å¯å˜é—­åŒ…
fn mutable_dispatch<F: FnMut()>(mut f: F) {
    f()
}

// æ¥å—å¯å¤šæ¬¡è°ƒç”¨çš„é—­åŒ…
fn reusable_dispatch<F: Fn()>(f: F) {
    f();
    f();
}
```



## 2.3 ä½œä¸ºè¾“å‡ºå‚æ•°

é—­åŒ…ä¹Ÿå¯ä»¥ä½œä¸ºè¾“å‡ºå‚æ•°ï¼Œä½†ç”±äº **Rust åªæ”¯æŒè¿”å›å…·ä½“ (éæ³›å‹) çš„ç±»å‹ï¼Œæ‰€ä»¥é—­åŒ…ä¸èƒ½ç›´æ¥è¢«è¿”å›ï¼Œéœ€è¦ä½¿ç”¨ `impl trait` æ‰å¯¹è¿”å›ä¸€ä¸ªé—­åŒ…**ã€‚

è¿”å›é—­åŒ…çš„æœ‰æ•ˆç‰¹å¾ï¼š`Fn`, `FnMut`, `FnOnce`

é™¤æ­¤å¤–ï¼Œ**move å…³é”®å­—ä¸å¯å°‘ï¼Œå®ƒè¡¨æ˜æ‰€æœ‰çš„æ•è·éƒ½æ˜¯é€šè¿‡å€¼è¿›è¡Œ**çš„ã€‚å› ä¸ºåœ¨å‡½æ•°é€€å‡ºæ—¶ï¼Œä»»ä½•é€šè¿‡å¼•ç”¨çš„æ•è·éƒ½è¢«ä¸¢å¼ƒï¼Œåœ¨é—­åŒ…ä¸­ç•™ä¸‹æ— æ•ˆçš„å¼•ç”¨ã€‚

```rust
fn create_fn() -> impl Fn() {
    let text = "Fn".to_owned();
    move || println!("This is a `{}`", text)
}

fn create_fn_mut() -> impl FnMut() {
    let text = "FnMut".to_owned();
    move || println!("This is a `{}`", text)
}

fn create_fn_once() -> impl FnOnce() {
    let text = "FnOnce".to_owned();
    move || println!("This is a `{}`", text)
}

fn main() {
    let fn_plain = create_fn();
    let mut fn_mut = create_fn_mut();
    let fn_once = create_fn_once();

    fn_plain();
    fn_mut();
    fn_once();
}
```



## 2.4 å®é™…åº”ç”¨åœºæ™¯

### 2.4.1 çº¿ç¨‹é—´æ•°æ®ä¼ é€’

`FnOnce` åœ¨è·¨çº¿ç¨‹ç¼–ç¨‹ä¸­å°¤ä¸ºé‡è¦ï¼Œå› ä¸º `spawn` å‡½æ•°è¦æ±‚é—­åŒ…æ»¡è¶³ `Send + 'static`:

```rust
use std::thread;

fn main() {
    let value = String::from("hello world");
    
    thread::spawn(move || {
        println!("Received: {}", value);
    }).join().unwrap();
}
```

é€šè¿‡ `move` å¼ºåˆ¶è½¬ç§»æ‰€æœ‰æƒï¼Œç¡®ä¿çº¿ç¨‹å®‰å…¨ã€‚



### 2.4.2 ç¼“å­˜æ¨¡å¼ (Memoization)

åˆ©ç”¨ `FnMnt` å®ç°å¸¦çŠ¶æ€çš„ç¼“å­˜ï¼š

```rust
struct Cacher<T>
where
    T: FnMut(i32) -> i32,
{
    calculation: T,
    value: Option<i32>,
}

impl<T> Cacher<T>
where
	T: FnMut(i32) -> i32,
{
    fn new(calculation: T) -> Self {
        Cacher {
            calculation,
            value: None,
        }
    }
    
    fn value(&mut self, arg: i32) -> i32 {
        if let Some(v) = self.value {
            v
        } else {
            let v = (self.calculation)(arg);
            self.value = Some(v);
            v
        }
    }
}
```



### 2.4.3 æ„å»ºä¸€ä¸ªç®€å•çš„äº‹ä»¶ç³»ç»Ÿ

```rust
struct EventSystem {
    listeners: Vec<Box<dyn Fn(&str)>>,
}

impl EventSystem {
    fn new() -> Self {
        Self {
            listeners: Vec::new(),
        }
    }
    
    fn on<F>(&mut self, listener: F)
    where
    	F: Fn(&str) + 'static
    {
        self.listeners.push(Box::new(listener));
    }
    
    fn emit(&self, event: &str) {
        for listener in &self.listeners {
            listener(event);
        }
    }
}

fn main() {
    let mut es = EventSystem::new();
    
    let log_prefix = "[LOG]";
    es.on(move |event| {
        println!("{} Event received: {}", log_prefix, event);
    });
    
    es.on(|event| {
        println!("ğŸ“¢ Broadcasting: {}", event);
    });
    
    es.emit("User logged in");
}
```



# 3. è¿­ä»£å™¨

è¿­ä»£å™¨æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå…è®¸ä½ é¡ºåºè®¿é—®é›†åˆå¾—å…ƒç´ ã€‚Rustä¸­çš„è¿­ä»£å™¨æ˜¯æ‡’æ€§çš„ï¼Œè¿™æ„å‘³ç€è®¡æ•°ä¸ä¼šç«‹å³å‘ç”Ÿï¼Œç›´åˆ°ä½ æ˜ç¡®åœ°æ¶ˆè´¹è¿­ä»£å™¨ï¼Œè¿™ä½¿å¾—ä»–ä»¬å†å†…å­˜å’Œå¤„ç†æ–¹é¢éå¸¸é«˜æ•ˆã€‚



## 3.1 Iterator trait

```rust
pub trait Iterator {
    type Item;
    
    fn next(&mut self) -> Option<Self::Item>;
    
    // --skip--
}
```

åœ¨è¿­ä»£å™¨ä¸­è°ƒç”¨ `next()` æ–¹æ³•

```rust
fn main() {
    let v = vec![1, 2, 3];
    
    let mut v_iter = v.iter();
    
    assert_eq!(v_iter.next(), Some(&1));
    assert_eq!(v_iter.next(), Some(&2));
    assert_eq!(v_iter.next(), Some(&3));
    assert_eq!(v_iter.next(), None);
}
```



## 3.2 `Vec<T>` ç”Ÿæˆè¿­ä»£å™¨æ–¹æ³•

- `iter()`ï¼šè¿”å›ä¸å¯å˜å¼•ç”¨ï¼Œå³ `&T`
- `iter_mut()`ï¼šè¿”å›å¯å˜å¼•ç”¨ï¼Œå³ `&mut T`
- `into_iter()`ï¼šè¿”å›å€¼ï¼Œå³ `T`ï¼Œ`for` å¾ªç¯é»˜è®¤è°ƒç”¨çš„æ–¹æ³• 



```rust
letÂ mutÂ numbers =Â vec![1,Â 2,Â 3];

// iter(): ä¸å¯å˜å€Ÿç”¨ï¼ŒåŸæ•°æ®ä¸å˜
forÂ nÂ inÂ numbers.iter() {
Â  Â Â println!("{}", n);Â // n æ˜¯ &i32
}
println!("{:?}", numbers);Â // numbers è¿˜åœ¨

// iter_mut(): å¯å˜å€Ÿç”¨ï¼Œå¯ä»¥ä¿®æ”¹å…ƒç´ 
forÂ nÂ inÂ numbers.iter_mut() {
Â  Â  *n *=Â 2;Â // n æ˜¯ &mut i32
}
println!("{:?}", numbers);Â // [2, 4, 6]

// into_iter(): è·å–æ‰€æœ‰æƒï¼ŒåŸæ•°æ®è¢«æ¶ˆè€—
forÂ nÂ inÂ numbers.into_iter() {
Â  Â Â println!("{}", n);Â // n æ˜¯ i32
}
// println!("{:?}", numbers); // âŒ ç¼–è¯‘é”™è¯¯ï¼numbers å·²è¢«ç§»åŠ¨
```



## 3.3 è¿­ä»£å™¨æ ¸å¿ƒæ–¹æ³•

### 3.3.1 map è½¬æ¢æ¯ä¸ªå…ƒç´ 

```rust
let numbers = vec![1, 2, 3];
let squared: Vec<_> = numbers.iter().map(|x| x * x).collect();
// [1, 4, 9]
```



### 3.3.2 filetr ç­›é€‰ç¬¦åˆæ¡ä»¶çš„å…ƒç´ 

```rust
let numbers = vec![1, 2, 3, 4, 5, 6];
let evens: Vec<_> = numbers.into_iter().filter(|x| x % 2 == 0).collect();
// [2, 4, 6]
```



### 3.3.3 fold ç´¯ç§¯è®¡ç®—

åœ¨å…¶å®ƒç¼–ç¨‹è¯­è¨€ä¸­ï¼Œä¸€èˆ¬å« reduce

```rust
let numbers = vec![1, 2, 3, 4];
let sum = numbers.iter().fold(0, |acc, x| acc + x);
// 0 + 1 + 2 + 3 + 4 = 10
```



### 3.3.4 chain é“¾æ¥è¿­ä»£å™¨

```rust
let a = vec![1, 2, 3];
let b = vec![4, 5, 6];
let combined: Vec<_> = a.iter().chain(b.iter()).collect();
// [1, 2, 3, 4, 5, 6]
```



### 3.3.5 zip é…å¯¹è¿­ä»£å™¨

```rust
let names = vec!["Alice", "Bob", "Carol"];
let ages = vec![25, 30, 35];
let person: Vec<_> = names.iter().zip(ages.iter()).collect();
// [("Alice", 25), ("Bob", 30), ("Carol", 35)]
```



### 3.3.6 take (è·å–) / skip (è·³è¿‡) å‰Nä¸ª 

```rust
let numbers = 1..=10
let first_5: Vec<_> = numbers.take(5).collect();
// [1, 2, 3, 4, 5]

let numers = 1..=10
let last_5: Vec<_> = numbers.skip(5).collect();
// [6, 7, 8, 9, 10]
```



### 3.3.7 all æ»¡è¶³å…¨éƒ¨æ¡ä»¶

```rust
let numbers = vec![1, 2, 3];
let ok: bool = numbers.iter().all(|&x| x <= 3);
// true

fn is_prime(n: usize) -> bool {
    (2..=(n as f64).sqrt() as usize).all(|i| n % i != 0)
}
let primes: Vec<_> = (2..=10).filter(|x| is_prime(*x)).collect();
// [2, 3, 5, 7]
```



### 3.3.8 any æ»¡è¶³ä»»æ„æ¡ä»¶

```rust
let numbers = vec![1, 2, 3];
let ok: bool = numbers.iter().any(|&x| x == 2);
// true
```



### 3.3.9 find æ»¡è¶³æ¡ä»¶çš„ç¬¬ä¸€ä¸ªå…ƒç´ 

```rust
let numbers = vec![1, 2, 3, 4, 5, 6];
let elem: Option<_> = numbers.iter().find(|&&x| x > 3 );
// Some(4)
```



### 3.3.10 position æ»¡è¶³æ¡ä»¶çš„ç¬¬ä¸€ä¸ªå…ƒç´ çš„ç´¢å¼•

```rust
let numbers = vec![1, 2, 3, 4, 5, 6];
let pos: Option<_> = numbers.iter().position(|&x| x > 3 );
// Some(3)
```



### 3.3.11 enumerate å¢åŠ ç´¢å¼•è¿”å›å…ƒç»„å¯¹

```rust
let fruits = vec!["apple", "orange", "grape", "cherry"];
let pair: Vec<_> = fruits.iter().enumerate().collect();
// [(0, "apple"), (1, "orange"), (2, "grape"), (3, "cherry")]
```



### 3.3.12 flatten æ‰å¹³åŒ–é«˜é˜¶è¿­ä»£å™¨

```rust
let nested = vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]];
let flatten: Vec<_> = nested.iter().flatten().collect();
// [1, 2, 3, 4, 5, 6, 7, 8, 9]
```



### 3.3.13 flat_map

åˆ›å»ºä¸€ä¸ªè¿­ä»£å™¨ï¼Œå…¶å·¥ä½œæ–¹å¼ç±»ä¼¼äº mapï¼Œä½†å®ƒä¼šå°†åµŒå¥—çš„ç»“æ„å±•å¹³ï¼Œå¯çœ‹ä½œæ˜¯ `map(f).flatten()`ã€‚

`map` é€‚é…å™¨éå¸¸æœ‰ç”¨ï¼Œä½†ä»…å½“é—­åŒ…å‚æ•°äº§ç”Ÿå€¼æ—¶æ‰ä½¿ç”¨ã€‚ å¦‚æœå®ƒäº§ç”Ÿä¸€ä¸ªè¿­ä»£å™¨ï¼Œåˆ™å­˜åœ¨ä¸€ä¸ªé¢å¤–çš„é—´æ¥å±‚ã€‚ `flat_map()` å°†è‡ªè¡Œåˆ é™¤è¿™ä¸ªé¢å¤–çš„å±‚ã€‚

```rust
fn main() {
    let suits = ["C", "D", "H", "S"];
    let ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
    
    let deck: Vec<String> = suits.iter().flat_map(|suit| {
        // move æŒ‰å€¼æ•è·suitå˜é‡ï¼Œå…è®¸å®ƒåœ¨é—­åŒ…ä¸­ä½¿ç”¨
        ranks.iter().map(move |rank| format!("{}{}", rank, suit))
    }).collect();
    
    println!("{:?}", deck);  
}
```



### 3.3.14 inspect  è°ƒè¯•è¿­ä»£å™¨

```rust
letÂ result:Â Vec<_> = data.iter()
Â  Â  .inspect(|x|Â println!("åŸå§‹å€¼: {}", x))
Â  Â  .map(|x| x *Â 2)
Â  Â  .inspect(|x|Â println!("ç¿»å€å: {}", x))
Â  Â  .filter(|&x| x >Â 10)
Â  Â  .inspect(|x|Â println!("ç­›é€‰å: {}", x))
Â  Â  .collect();
```



## 3.4 é—­åŒ…ä¸è¿­ä»£å™¨

### 3.4.1 è‡ªå®šä¹‰è¿­ä»£å™¨

```rust
struct Fibonacci {
    curr: u64,
    next: u64,
}

impl Fibonacci {
    fn new() -> Self {
        Fibonacci { curr: 0, next: 1 }
    }
}

impl Iterator for Fibonacci {
    type Item = u64;
    
    fn next(&mut self) -> Option<Self::Item> {
        let curr = self.curr;
        self.curr = self.next;
        self.next = curr + self.next;
        Some(curr)
    }
}

fn main() {
    let fibs: Vec<_> = Fibonacci::new().take(10).collect();
    println!("{:?}", fibs);
    // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
    
    // ç¬¬ä¸€ä¸ªè¶…è¿‡1000çš„
    let first_greater_1k = Fibonacci::new().find(|&x| x > 1000).unwrap();
    println!("{}", first_greater_1k);  // 1597
}
```



### 3.4.2 ç»„åˆå™¨æ¨¡å¼ (é«˜é˜¶å‡½æ•°)

é«˜é˜¶å‡½æ•°(Higher Order Function, HOF)ï¼Œé€šè¿‡è¾“å…¥ä¸€ä¸ªæˆ–å¤šä¸ªå‡½æ•°ï¼Œç”Ÿæˆä¸€ä¸ªæ›´æœ‰ç”¨çš„å‡½æ•°ã€‚

HOF å’Œ æ‡’æ€§è¿­ä»£å™¨ (lazy iterator) æ˜¯ Rust çš„å‡½æ•°å¼ç¼–ç¨‹é£æ ¼.

```rust
fn is_odd(n: i32) -> bool {
    n % 2 == 1
}

fn imperative_prog(upper: i32) {
    let mut acc = 0;

    for n in 0.. {
        let n_squared = n * n;
        if n_squared > upper {
            break
        } else if is_odd(n_squared) {
            acc += n_squared;
        }
    }

    println!("imperative style: {}", acc);
}

fn functional_prog(upper: i32) {
    let sum_of_squared_odd_numbers =
        (0..).map(|n| n * n)// å¹³æ–¹
             .take_while(|&n| n < upper)// å–å°äºä¸Šé™çš„
             .filter(|&n| is_odd(n)) // è¿‡æ»¤éå¥‡æ•°çš„
             .fold(0, |sum, i| sum + i);  // åŠ èµ·æ¥
    println!("functional style: {}", sum_of_squared_odd_numbers);
}

fn main() {
    println!("Find the sum of all the squared odd numbers under 1000");
    let upper = 1000;

    imperative_prog(upper);

    functional_prog(upper);
}
```



### 3.4.3 é”™è¯¯å¤„ç†

```rust
fn parse_numbers(input: Vec<&str>) -> Result<Vec<i32>, String> {
    inputs.iter()
    	.map(|s| s.parse::<i32>())
    	.collect::<Result<Vec<_>, _>>()
    	.map_err(|e| format!("Parsing failed: {}", e))
}

fn main() {
    let valid = vec!["1", "2", "3"];
    println!("{:?}", parse_numbers(valid)); // Ok([1, 2, 3])
    
    let invalid = vec!["1", "b", "3"];
    println!("{:?}", parse_numbers(invalid)); // Err("Parsing failed: ...")
}
```



### 3.5 `std::iter::successors`

successors æ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªæ˜¯åˆå§‹å€¼ï¼Œç¬¬äºŒä¸ªæ˜¯ä¸€ä¸ª**æ¯æ¬¡ä»è¿­ä»£å™¨ä¸­è·å–å¦ä¸€ä¸ªå…ƒç´ æ—¶è°ƒç”¨çš„é—­åŒ…**

```rust
fn main() {
    let fib = std::iter::successors(Some((0, 1)), |(a, b)| Some((*b, *a + *b)))
        .map(|(a, _)| a)
        .take(10);
        
    for n in fib {
        print!("{} ", n);
    }
}
```



# 4. å‘æ•£å‡½æ•°

å‘æ•£å‡½æ•° (diverging function) ç»ä¸ä¼šè¿”å›ï¼Œä½¿ç”¨ `!` æ ‡è®°ç©ºç±»å‹ã€‚å› ä¸ºæ­¤ç±»å‹å¯èƒ½å…·æœ‰æ‰€æœ‰å¯èƒ½å€¼çš„é›†åˆä¸ºç©ºï¼Œæ‰€ä»¥æ— æ³•å®ä¾‹åŒ–ã€‚å®ƒä¸ `()` ç±»å‹ä¸åŒï¼Œåè€…åªæœ‰ä¸€ä¸ªå¯èƒ½çš„å€¼ã€‚

```rust
fn foo() -> ! {
    panic!("This call never returns.");
}
```

ä¸»è¦ç”¨äºæ°¸ä¹…å¾ªç¯çš„å‡½æ•° (å¦‚ç½‘ç»œæœåŠ¡å™¨) æˆ–ç»ˆæ­¢è¿›ç¨‹çš„å‡½æ•° (å¦‚ exit()) çš„è¿”å›ç±»å‹ã€‚

å…¶ä¸»è¦ä¼˜ç‚¹æ˜¯å¯ä»¥è¢«è½¬æ¢ä¸ºä»»ä½•å…¶ä»–ç±»å‹ï¼Œä»è€Œå¯ä»¥åœ¨éœ€è¦ç²¾ç¡®ç±»å‹çš„åœ°æ–¹ä½¿ç”¨ï¼Œä¾‹å¦‚åœ¨ `match` åŒ¹é…åˆ†æ”¯ï¼š

```rust
fn sum_odd_numbers(up_to: u32) -> u32 {
    let mut acc = 0;
    for i in 0..up_to {
        let addition = match i % 2 == 1 {
            true => i,
            false => continue,
        };
        acc += addition;
    }

    acc
}

fn main() {
    println!("Sum of the odd numbers up to 9(excluding): {}", sum_odd_numbers(9));
}
```



































