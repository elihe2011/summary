# 8. Generic Types, Traits, and Lifetimes







## 8.3 Validating References  with Lifetimes

### 8.3.1 Preventing Dangling References with Lifetimes

```rust
fn main() {
    let r;
    
    {
        let x = 5;
        r = &x;
    } // `x` dropped here while still borrowed 
    
    println!("r: {r}");
}
```



### 8.3.2 The Borrow Checker

Annotations of the lifetimes of `r` and `x`, named `'a` and `'b`, respectively

```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+
```

The inner `'b` block is much smaller than the outer `'a` lifetime block. At compile time, Rust compares the size of the two lifetimes and sees that `r` has a lifetime of `'a` but that is refers to memory with a lifetime of `'b`. The program is rejected because `'b` is shorter than `'a`: the subject of the reference doesn't live as long as the reference.



### 8.3.3 Generic Lifetimes in Functions

```rust
fn main() {
    let s1 = String::from("abc");
    let s2 = "xyz";

    let result = longest(s1.as_str(), s2);
    println!("The longest string is {result}");
}

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

It will catch a error: *missing lifetime specifier*. The return type needs a generic lifetime parameter on it because Rust can't tell whether the reference being returned refers to `x` or `y`.



### 8.3.4 Lifetime Annotation Syntax

Lifetime annotations don't change how long any of the references live. Rather, they describe the relationships of the lifetimes of multiple references to each other without affecting the lifetime. Just as functions can accept any type when the signature specifies a generic type parameter, functions can accept references with any lifetime by specifying a generic lifetime parameter.

```rust
&i32         // a reference
&'a i32      // a reference with an explicit lifetime
&'a mut i32  // a mutable reference with an explicit lifetime
```



### 8.3.5 Lifetime Annotations in Function Signatures

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```



### 8.3.6 Thinking in Terms of Lifetimes

The way in which you need to specify lifetime parameters depends on what your function is doing. if we changed the implementation of the `longest` function to always return the first parameter rather than the longest string slice, we wouldn't need to specify a lifetime on the `y` parameter.

```rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```



When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters. If the reference returned doesn't refer to one of the parameters, it must refer to a values created within this function. However, this would be a dangling reference because the value will go out of scope at the end of the function.

```rust
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```

The problem is that `result` goes out of scope and gets cleaned up at the end of the `longest` function.



### 8.3.7 Lifetime Annotations in Struct Definitions

We can define structs to hold references, but in that case we would need to add a lifetime annotation on every reference in the struct's  definition.

```rust
#[derive(Debug)]
struct ImportantExcerpt<'a> {
    part: &'a str,
}
fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };

    println!("{i:?}");
}
```



### 8.3.8 Lifetime Elision

A function that compiled without lifetime annotations, even though the parameter and return type as references.

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

The reason this function compiles without lifetime annotations is historical: in early versions (pre-1.0) of Rust, this code wouldn't have compiled because every reference needed an explicit lifetime. At that time, the function signature would have been written like this:

```rust
fn first_word<'a>(s: &'a str) -> &'a str {}
```

After writing a lot Rust code, the Rust team found that Rust programmers were entering the same lifetime annotations over and over in particular situations. **These situations where predictable and followed a few deterministic patterns. The developers programmed these patterns into the compiler's code so the borrow checker could infer the lifetimes in these situations and wouldn't need explicit annotations**.

The patterns programmed into Rust's analysis of references are called the *lifetime elision rules*. These aren't rules for programmers to follows; they're a set of particular cases that the compiler will consider, and if your code fits these cases, you don't need to write the lifetimes explicitly.

Lifetimes on function or method parameters are called *input lifetimes*, and lifetimes on return values are called *output lifetimes*.

The complier uses three rules to figure out the lifetime of the references when there aren't explicit annotations. The first rule applies to input lifetimes, and the second and third rules apply to output lifetimes. If the compiler gets the end of the three rules and there are still references for which it can't figure out lifetimes, the compiler will stop with an error. There rules apply to `fn` definitions as well as `impl` blocks.

The first rule is that the compiler assigns a lifetime parameter to each parameter thatâ€™s a reference. In other words, a function with one parameter gets one lifetime parameter: `fn foo<'a>(x: &'a i32)`; a function with two parameters gets two separate lifetime parameters: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`; and so on.

The second rule is that, if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: `fn foo<'a>(x: &'a i32) -> &'a i32`.

The third rule is that, if there are multiple input lifetime parameters, but one of them is `&self` or `&mut self` because this is a method, the lifetime of `self` is assigned to all output lifetime parameters. This third rule makes methods much nicer to read and write because fewer symbols are necessary.

The signature starts without any lifetimes associated with references:

```rust
fn first_word(s: &str) -> &str {}
```

Then the compiler applies the first rule, which specifies that each parameter gets its own lifetime.

```rust
fn first_word<'a>(s: &'a str) -> &str {}
```

The second rule applies because there is exactly one input lifetime. The second rule specified that the lifetime of the one input parameter gets assigned to the output lifetime, so the signature is now this:

```rust
fn first_word<'a>(s: &'a str) -> &'a str {}
```

Now all the references in this function signature have lifetimes, and the compiler can continue its analysis without needing the programmer to annotate the lifetimes in this function signature.



### 8.3.9 Lifetime Annotations in Method Definitions

```rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
    
    // the third lifetime elision rule applies
    ffn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {annoucement}");
        self.part
    }
}
```

There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both `&self` and `announcement` their own lifetimes. Then, because one of the parameters is `&self`, the return type gets the lifetime of `&self`, and all lifetimes have been accounted for.



### 8.3.10  The Static Lifetime

`static`, which denotes that affected reference can live for the entire duration of the program.

```rust
let s: &'static str = "I have a static lifetime.";
```



## 8.4 Generic Type Parameters, Trait Bounds, and Lifetime Together

```rust
use std::fmt::Display;

fn longest_with_announcement<'a, T>(
	x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
	T: Display,
{
    println!("Announcement! {ann}");
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```















