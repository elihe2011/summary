## 11.2 Iterators

In Rust, iterators are *lazy*, meaning they have no effect until you call methods that consume the iterator to use it up.

To create an iterator over the items in the vector by calling the `iter` method defined on `Vec<T>`:

```rust
fn main() {
    let v = vec![1, 2, 3];
    
    for i in v.iter() {
        print!("{i} ");
    }
    println!();
}
```



### 11.2.1 The Iterator Trait and the NEXT Method

All iterators implement a trait named `Iterator` that is defined in the standard library.

```rust
pub trait Iterator {
    type Item;
    
    fn next(&mut self) -> Option<Self::Item>;
    
    // methods with default implementations elided
}
```

To call the `next` method on an iterator:

```rust
fn main() {
    let v = vec![1, 2, 3];
    
    let mut v_iter = v.iter();
    
    println!("{:?}", v_iter.next()); // Some(1)
    println!("{:?}", v_iter.next()); // Some(2)
    println!("{:?}", v_iter.next()); // Some(3)
    println!("{:?}", v_iter.next()); // None
}
```



### 11.2.2 Methods that Consume the Iterator

Methods that call `next` are called *consuming adaptors*, because calling them uses up the iterator. The `sum` method, which takes ownership of the iterator and iterates through the items by repeatedly calling `next`, thus consuming the iterator.

```rust 
fn main() {
    let v = vec![1, 2, 3];
    
    let v_iter = v.iter();
    
    // type annotations needed
    let total: i32 = v_iter.sum();
    println!("{total}");
}
```



### 11.2.3 Methods that Produce Other Iterators

*Iterator adaptors* are methods defined on the `Iterator` trait that don't consume the iterator. Instead, they produce different iterators by changing some aspect of the original iterator.

```rust
fn main() {
    let v = vec![1, 2, 3];
    
    // type annotations needed
    let v2: Vec<_> = v.iter().map(|x| x + 1).collect();
    
    println!("{v2:?}");
}
```



### 11.2.4 Using Closures that Capture Their Environment

To use the `filter` method that takes a closure. The closure gets an item from the iterator and returns a  `bool`, if `true`, the value will be included in the iteration produced by `filter`. If the closure returns `false`, the value won't be included.

```rust
#[derive(PartialEq, Debug)]
pub struct Shoe {
    size: u32,
    style: String,
}

pub fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];
        
        let in_my_size = shoes_in_size(shoes, 10);
        
        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker"),
                },
                Shoe {
                    size: 10,
                    style: String::from("boot"),
                },
            ]
        );
    }
}
```



## 11.3 Improving Our I/O Project

### 11.3.1 Using Iterator Trait Methods Instead of Indexing

Filename: `src/lib.rs`

```rust
impl Config {
    pub fn build(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }
        
        let query = args[1].clone();
        let file_path = args[2].clone();
        
        let ignore_case = env::var("IGNORE_CASE").is_ok();
    
        Ok(Config { query, file_path, ignore_case })
    } 
	
	pub fn buildv2(
		mut args: impl Iterator<Item = String>,
	) -> Result<Config, &'static str> {
		args.next();
		
		let query = match args.next() {
			Some(arg) => arg,
			None => return Err("Didn't get a query string"),
		};
		
		let file_path = match args.next() {
			Some(arg) => arg,
			None => return Err("Didn't get file path string"),
		};
		
		let ignore_case = env::var("IGNORE_CASE").is_ok();
		
		Ok(Config {
			query,
			file_path,
			ignore_case,
		})
	}
}
```

### 11.3.2 Using the Returned Iterator Directly

Filename: `src/main.rs`

```rust
use std::{env, process};
use minigrep;

fn main() {
    /*let args: Vec<String> = env::args().collect();
    
    let config = minigrep::Config::build(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    }); */
	
	let config = minigrep::Config::buildv2(env::args()).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });
    
    if let Err(e) = minigrep::run(config) {
        eprintln!("Application error: {e}");
        process::exit(1);
    }
}
```



### 11.3.3 Making Code Clearer with Iterator Adaptors

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut result = Vec::new();
    
    for line in contents.lines() {
        if line.contains(query) {
            result.push(line);
        }
    }
    
    result
}

pub fn searchv2<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
	contents
		.lines()
		.filter(|line| line.contains(query))
		.collect()
}
```



















































