# 1. 函数

## 1.1 定义

```rust
fn func_name(para1: T, para2: T) -> T {
    
}
```

- 函数名：蛇形命名(snake_case)
- 返回值：`-> T`



## 2.2 参数

函数参数和变量一样，默认是不可变的，当需要可变参数时，一样得使用 mut 关键字

**按值传递**：

```rust
fn main() {
    let v = vec![1, 2, 3];
    let v = modify(v);  // shadow
    println!("{:?}", v);
}

fn modify(mut v: Vec<u32>) -> Vec<u32> {
    v.push(4);
    v
}
```

**按引用传递：**

```rust
fn main() {
    let mut v = vec![1, 2, 3];
    modify(&mut v);
    println!("{:?}", v);
}

fn modify(v: &mut Vec<u32>) {
    v.push(4)
}
```



## 2.3 返回值

如果没有返回值，`->` 不写，默认返回的类型是单元值 `()`。所以，也可以显示返回该类型。

```rust
fn main() {
    let (x, y) = swap(2, 3);
    println!("x={}, y={}", x, y);
}

fn swap(x: i32, y: i32) -> (i32, i32) {
    (y, x)
}
```



# 2. 方法

方法(method)是依附于对象的函数。通过关键字 `self` 来访问对象中的数据。方法在 `impl` 代码块中定义。

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 构造函数
    fn new(width: u32, height: u32) -> Rectangle {
        Rectangle{
            width,
            height,
        }
    }

    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn width(&self) -> u32 {
        self.width
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}


fn main() {
    let r1 = Rectangle::new(12, 8);
    println!("area: {}", r1.area());
    println!("width: {}", r1.width());

    let r2 = Rectangle::new(9, 6);
    println!("{}", r1.can_hold(&r2));
}
```

关于 self：

- `self`：实例的所有权转移到该方法中，较少使用
- `&self`：该方法对实例的不可变借用

- `&mut self`：可变借用



# 3. 闭包

Rust 中的闭包 (closure) 也叫 lambda 表达式，是一类能够捕获周围作用域中变量的函数。

```rust
// 可捕获 x 变量的闭包
|val| val + x
```

它的语法何能力使它们在临时 (on the fly) 使用时很方便。调用一个闭包何调用一个函数完全相同，不过调用闭包时，输入和返回类型两者都可以自动推导，而输入变量名必须指明。

闭包特点：

- 声明时使用 `||` 替代 `()` 将输入参数括起来
- 函数定界符 `{}` 对单个表达式是可选的，其他情况必须加上
- 有能力捕获外部环境的变量

```rust
fn main() {
    fn function(i: i32) -> i32 { i + 1 }

    let closure_annotated = |i: i32| -> i32 { i + 1 };
    let closure_inferred = |i| i + 1;

    // 调用，均返回2
    let i = 1;
    println!("function: {}", function(i));
    println!("closure_annotated: {}", closure_annotated(i));
    println!("closure_inferred: {}", closure_inferred(i));

    // 无输入值
    let one = || 1;
    println!("closure returning one: {}", one());
}
```



## 3.1 捕获

闭包捕获变量的方式：

- 引用：&T （优先方式）
- 可变引用：&mut T
- 值：T

```rust
use std::mem;

fn main() {
    // 1. 不可变借用
    immutable_borrow();

    // 2. 可变借用
    mutable_borrow();

    // 3. 不可复制
    non_copyable();
}

fn immutable_borrow() {
    let color = String::from("green");

    // 通过引用(&)，立即借用color，直到print离开作用域
    let print = ||println!("color: {}", color);
    print();

    // color可再次被借用，因为闭包中只保持了一个指向color的不可变借用
    let _reborrow = &color;
    print();

    // 在print后，移动和重新借用都是允许的
    let _color_moved = color;

    // 不注释将报错
    // print();
}

fn mutable_borrow() {
    let mut count = 0;

    // 闭包中含有一个&mut借用，调用闭包时，该变量发生变化，意味着闭包发生变化，所以闭包也要是可变的
    let mut inc = || {
        count += 1;
        println!("count: {}", count);
    };

    inc();

    // 闭包中进行了&mut count可变借用，导致它不能再次被借用，所以此处报错
    // let _reborrow = &mut count;
    inc();

    // 闭包不再借用 &mut count，因此可重新借用
    let _reborrow = &mut count;
}

fn non_copyable() {
    let movable = Box::new(3);

    // mem::drop 要求T类型本身，因此闭包将会捕获变量的值，此种情况下，
    // 可复制类型将会复制给闭包，从而原始值不受影响
    // 不可复制类型必须移动到闭包中，因此movable变量立即移动到闭包中
    let consume = || {
        println!("movable: {:?}", movable);
        mem::drop(movable);
    };

    // 闭包消耗movable变量，因此只能调用一次
    consume();
    // consume();
}
```

通过 move 强制闭包取得被捕获变量的所有权：

```rust
fn main() {
    // Vec 在语义上是不可复制的
    let haystack = vec![1, 2, 3];

    // 强制闭包取得被捕获
    let contains = move |needle| haystack.contains(needle);

    println!("{}", contains(&1));
    println!("{}", contains(&4));

    // 已被移走，无法继续使用，除非将闭包中的 move 删除
    //println!("{}", haystack.len())
}
```



## 3.2 当作输入参数

闭包作为输入参数时，必须指出闭包的完整类型，它通过使用以下 trait 中的一种来指定，其受限程度按以下顺序递减：

- `Fn`：捕获方式通过引用 `&T` 的闭包
- `FnMut`：捕获方式通过可变引用 `&mut T` 的闭包
- `FnOnce`：捕获方式通过值 T 的闭包

```rust
fn apply<F>(f: F) where F: FnOnce() {
    f();
}

fn apply_to_3<F>(f: F) -> i32 where F: Fn(i32) -> i32 {
    f(3)
}

fn main() {
    let greeting = "hello";

    // 不可复制类型，通过借用的数据创建有所有权的数据
    let mut farewell = "goodbye".to_owned();

    let diary = || {
        // 通过引用捕获，需要闭包Fn
        println!("I said {}.", greeting);

        // 通过可变引用捕获，需要闭包FnMut
        farewell.push_str("!!!");
        println!("then I screamed {}", farewell);

        // 手动调用drop，通过值捕获，需要闭包FnOnce
        mem::drop(farewell);
    };

    // 以闭包做参数
    apply(diary);

    // 闭包满足 apply_to_3 的 trait 约束
    let double = |x| 2 * x;
    println!("3 doubled: {}", apply_to_3(double));
}
```



## 3.3 类型匿名

闭包作为函数参数，要求闭包时泛型的，闭包定义的方式决定了这是必要的

```rust
// F 必须是泛型的
fn apply<F>(f: F) where F: FnOnce() {
    f();
}
```

编译器会隐式地为闭包创建一个匿名类型的结构体，用以存储闭包捕获的变量，同时为这个未知类型的结构体实现函数功能，通过 `Fn`、`FnMut`或 `FnOnce` 三种 `trait` 中的一种。

```rust
// F 必须是一个没有输入参数和返回值的闭包实现`Fn`
fn apply<F>(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    let print = || println!("{}", x);

    apply(print);
}
```





































