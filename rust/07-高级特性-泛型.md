# 1. 理论基础

泛型是 Rust 中一种参数化类型 (Parameterized Types) 的机制。它允许在定义函数、结构体或枚举时，使用占位符 (如 `T`) 来代表未知类型，从而实现代码复用。

Rust 的泛型是静态分发的单态化 (Monomorphized)，即编译器在编译时为每种具体类型生成专属代码，确保零开销。

**泛型实现原理**：

- **零运行时开销**：编译器为每个具体类型生成专门的代码
- **静态分发**：编译期确定具体类型，无动态调用开销
- **类型安全**：编译时进行类型检查，确保类型安全
- **trait约束**：通过 trait bounds 限制泛型类型的行为



```rust
// 普通函数
fn max(a: i32, b: i32) -> i32 {
    if a > b { a } else { b }
}

// 错误的泛型函数，缺失 trait bounds
fn max<T>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

// 正确的泛型函数
fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}
```



**核心思想**：<font color="red">泛型是”编译时多态“ (Compile-time Polymorphism)，不同于动态语言的运行时多态。</font>



# 2. 泛型定义

## 2.1 函数

```rust
use std::cmp::PartialOrd;

// 必须使用泛型约束
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut max = &list[0];
    
    for item in list {
        if item > max {
            max = item;
        }
    }
    
    max
}
```



## 2.2 结构体

泛型结构体：

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.5, y: 4.3 };
    let wont_work = Point { x: 5, y: 4.3 }; // expected integer, found floating-point number
}
```



混合类型泛型：

```rust
struct MixedPoint<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = MixedPoint { x: 5, y: 10 };
    let both_float = MixedPoint { x: 1.5, y: 4.3 };
    let integer_and_float = MixedPoint { x: 5, y: 4.3 }; 
}
```



## 2.3 枚举

```rust
enum Option<T> {
    Some(T),
    None,
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}
```



## 2.4 方法

在方法中，泛型允许为 `impl` 块添加参数，实现更灵活的行为。

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

// specify constraints on generic types when defining methods on the type
// implement methods only on Point<f32> instances rather than on Point<T> instances with any generic type
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

fn main() {
    let p = Point { x: 5.2, y: 7.8 };
    println!("p.x = {}", p.x());

    println!("distance from origin: {}", p.distance_from_origin());
}
```



# 3. 泛型约束

## 3.1 单重约束

使用泛型时，类型参数常常必须使用 trait bounds，来明确类型应该满足那些功能

```rust 
// T 必须实现 Display 特征
fn printer<T: Display>(t: T) {
    println!("{}", t);
}

struct S<T: Display>(T);
```



泛型实例，访问 trait bounds 方法：

```rust
use std::fmt::Debug;

trait HasArea {
    fn area(&self) -> f64;
}

#[derive(Debug)]
struct Rectangle {
    width: f64,
    height: f64,
}

impl HasArea for Rectangle {
    fn area(&self) -> f64 {
        self.width * self.height
    }
}

#[allow(dead_code)]
#[derive(Debug)]
struct Triangle {
    base_len: f64,
    height: f64,
}

fn area<T: HasArea>(t: &T) -> f64 {
    t.area()
}

fn main() {
    let rectangle = Rectangle{width: 3.5, height: 2.9};
    println!("area: {}", area(&rectangle));

    let triangle = Triangle{base_len: 6.1, height: 3.5};
    // println!("area: {}", area(&triangle));
}
```



空约束：

```rust
struct Cardinal;
struct BlueJay;
struct Turkey;

trait Red {}
trait Blue {}

impl Red for Cardinal {}
impl Blue for BlueJay {}

fn red<T: Red>(_: &T) -> &'static str { "red" }
fn blue<T: Blue>(_: &T) -> &'static str { "blue" }

fn main() {
    let cardinal = Cardinal;
    let blue_jay = BlueJay;
    let _turkey = Turkey;

    println!("A cardinal is {}", red(&cardinal));
    println!("A blue jay is {}", blue(&blue_jay));
    // println!("A turkey is {}", red(&_turkey));
}
```



## 3.2 多重约束

多重约束 (multiple bounds) 可用 `+` 连接，类型之间使用 `,` 隔开

```rust
use std::fmt::{Debug, Display};

fn compare_print<T: Debug + Display>(t: &T) {
    println!("Debug: {:?}", t);
    println!("Display: {}", t);
}

fn compare_types<T: Debug, U: Debug>(t: &T, u: &U) {
    println!("Debug: {:?}", t);
    println!("Debug: {:?}", u);
}

fn main() {
    let string = "abcd";
    let array = [1, 2, 3, 4];
    let vec = vec![1, 2, 3, 4];

    compare_print(&string);

    // array & vec 未实现Display
    // compare_print(&array);
    // compare_print(&vec);

    compare_types(&array, &vec);
}
```



## 3.3 where 子句

where 子句，用于对任意类型的限定，而不局限于类型参数本身。

- 分别指定泛函的类型和约束，会更清晰

```rust
impl<A: TraitB + TraitC, D: TraitE + TraitF> MyTrait<A, D> for YourType { ... }
  
// where
impl<A, D> MyTrait<A, D> for YourType 
where
  	A: TraitB + TraitC,
  	D: TraitE + TraitF 
{ ... }
```

- 比正常语法更有表现力

```rust
use std::fmt::Debug;

trait PrintInOption {
    fn print_in_option(self);
}

impl <T> PrintInOption for T 
where
    Option<T>: Debug {
        fn print_in_option(self) {
            println!("{:?}", Some(self));
        }
}

fn main() {
    let vec = vec![1, 2, 3];
    vec.print_in_option();
}
```



# 4. 关联项

关联项 (associated item) 指与多种类型的项有关的一组规则。它是 trait 泛型的扩展，允许在 trait 内部定义新的项。



## 4.1 泛型参数

```rust
trait Contains<A, B> {
    fn contains(&self, _: &A, _: &B) -> bool;
    fn first(&self) -> A;
    fn last(&self) -> B;
}

struct Container(i32, i32);

impl Contains<i32, i32> for Container {
    fn contains(&self, n1: &i32, n2: &i32) -> bool {
        &self.0 == n1 && &self.1 == n2
    }

    fn first(&self) -> i32 { self.0 }

    fn last(&self) -> i32 { self.1 }
}

fn difference<A, B, C>(c: &C) -> i32
where
    C: Contains<i32, i32>,
{
    c.last() - c.first()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_trait_generic() {
        let n1 = 5;
        let n2 = 8;

        let c = Container(n1, n2);

        assert!(c.contains(&n1, &n2));
        assert_eq!(c.first(), n1);
        assert_eq!(c.last(), n2);
        assert_eq!(difference::<i32, i32, _>(&c), 3);  // 调用时加类型注解
    }
}
```



## 4.2 关联类型

**将容器内部的类型放到 trait 中作为输出类型，即“关联类型”**，它能增强代码的可读性。

```rust
trait Contains {
    type A;   // 定义类型
    type B;
    
    fn contains(&self, _: &Self::A, _: &Self::B) -> bool;
}
```

使用关联类型：

```rust
use std::ops::Sub;

trait Contains {
    type A;
    type B;

    fn contains(&self, a: &Self::A, b: &Self::B) -> bool;
    fn first(&self) -> Self::A;
    fn last(&self) -> Self::B;
}

struct Container(i32, i32);

impl Contains for Container {
    type A = i32;
    type B = i32;
    fn contains(&self, a: &Self::A, b: &Self::B) -> bool {
        a == &self.0 && b == &self.1
    }

    fn first(&self) -> Self::A {
        self.0
    }

    fn last(&self) -> Self::B {
        self.1
    }
}

fn difference<C: Contains<A=i32, B=i32>>(c: &C) -> i32 {
    c.last() - c.first()
}

// 更通用的泛型
fn difference2<C>(c: &C) -> <C::B as Sub<C::A>>::Output
where
    C: Contains,
    C::B: Sub<C::A>,
{
    c.last() - c.first()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let n1 = 5;
        let n2 = 8;

        let c = Container(n1, n2);

        assert!(c.contains(&n1, &n2));
        assert_eq!(c.first(), 5);
        assert_eq!(c.last(), 8);
        assert_eq!(difference(&c), 3);
        assert_eq!(difference2(&c), 3);
    }
}
```



**当类型定义复杂时，使用泛型的代码可读性不好，建议使用关联类型**：

```rust
pub trait CacheableItem: Clone + Default + fmt::Debug + Decodable + Encodable {
    type Address: AsRef<[u8]> + Clone + fmt::Debug + Eq + Hash;
    
    fn is_null(&self) -> bool;
}
```



## 4.3 默认泛型类型参数

泛型参数 RHS 有一个默认值，当用户不指定 RHS 时，默认使用两个同样类型的值相加，然后返回一个关联类型 Output.

```rust
trait Add<RHS=Self> {
    type Output;
    
    fn add(self, rhs: RHS) -> Self::Output;
}
```



相同类型相加：

```rust
use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    /*
    fn add(self, other: Point) -> Self::Output {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
    */

    fn add(self, rhs: Self) -> Self::Output {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let p1 = Point { x: 1, y: 2 };
        let p2 = Point { x: 3, y: 6 };
        let p3 = p1 + p2;
        assert_eq!(p3, Point { x: 4, y: 8 });
    }
}
```



两个不同类型相加：

```rust
use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Millimeters(f32);

#[derive(Debug, PartialEq)]
struct Meters(f32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, rhs: Meters) -> Self::Output {
        Millimeters(self.0 + rhs.0 * 1000.0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let millimeters = Millimeters(80.0);
        let meters = Meters(1.2);

        let millimeters = millimeters + meters;
        assert_eq!(millimeters, Millimeters(1280.0));
    }
}
```



## 4.4 完全限定语法

```rust
trait Animal {
    fn name() -> String;  // 关联函数
    fn speak(&self) -> String;

    fn eat(&self) -> String;
}

struct Dog;

impl Animal for Dog {
    fn name() -> String {
        String::from("Spot")
    }

    fn speak(&self) -> String {
        String::from("Bark")
    }

    fn eat(&self) -> String {
        String::from("Bones")
    }
}

impl Dog {
    fn name() -> String {
        String::from("Puppet")
    }

    fn speak(&self) -> String {
        String::from("Woof")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(Dog::name(), "Puppet");

        // cannot call associated function of trait
        // assert_eq!(Animal::baby_name(), "Spot");

        assert_eq!(<Dog as Animal>::name(), "Spot");

        // 对像优先调用自已的方法
        let dog = Dog {};
        assert_eq!(dog.speak(), "Woof");
        assert_eq!(dog.eat(), "Bones");

        // 对象调用 trait 的方法
        assert_eq!(<Dog as Animal>::speak(&dog), "Bark")
    }
}
```

Animal 不是具体的类型，编译器无法从 `Animal::name()` 得到任何有效的信息。需要通过使用 **完全限定语法 (Type as Trait)** 明确调用的函数，即Animal就是Dog，而不是其它，因此最终会调用 `impl Animal for Dog` 中的方法。

```rust
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```

第一个参数是方法接收器 receiver (self)，只有方法才拥有，关联函数没有 receiver.



## 4.5 特征的特征约束

特征 A 使用另一个特征 B 的功能，此时，实现特征 A 的类型，必须也实现特征 B，即 super trait

```rust
trait OutlinePrint: std::fmt::Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();

        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}

struct Circle {
    radius: f32,
}

impl OutlinePrint for Circle {}

// 必须实现 OutlinePrint 的父 trait
impl std::fmt::Display for Circle {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "Circle{{radius={}}}", self.radius)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let circle = Circle { radius: 5.0 };
        circle.outline_print();
    }
}
```



# 5. 虚类型参数

**虚类型 (phantom type) 参数是一种在运行时不出现，仅在编译时进行静态检查的类型参数**。

可以用额外的泛型类型参数指定数据类型，该类型可以**充当标记**，也可以提供编译时类型检查使用。这些额外的参数没有存储值，也没有运行时行为。

```rust
use std::cmp::Ordering;
use std::marker::PhantomData;

// 虚元组结构体，`A`是泛型的，并携带隐藏参数`B`
// 泛型`A`会分配内存空间，但`B`不会，因此它不参运算
#[derive(Debug)]
struct PhantomTuple<A, B>(A, PhantomData<B>);

impl<A: PartialEq, B, C> PartialEq<PhantomTuple<A, C>> for PhantomTuple<A, B> {
    fn eq(&self, other: &PhantomTuple<A, C>) -> bool {
        self.0 == other.0
    }
}

impl<A: PartialOrd, B, C> PartialOrd<PhantomTuple<A, C>> for PhantomTuple<A, B> {
    fn partial_cmp(&self, other: &PhantomTuple<A, C>) -> Option<Ordering> {
        self.0.partial_cmp(&other.0)
    }
}

// 虚类型结构体，`A`是泛型的，并携带隐藏参数`B`
// 泛型`A`会分配内存空间，但`B`不会，因此它不参与运算
#[derive(PartialEq)]
struct PhantomStruct<A, B> {
    a: A,
    b: PhantomData<B>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let t1: PhantomTuple<i32, char> = PhantomTuple(1, PhantomData);
        let t2: PhantomTuple<i32, u8> = PhantomTuple(2, PhantomData);
        assert!(t1 < t2);
    }
}
```



实例：单位检测，通过带一个虚类型参数的 Add trait 实现

```rust
// 要求 `Self + RHS = Output`
// `<RHS = Self>` 表示 RHS 的默认值为 Self 类型
pub trait Add<RHS = Self> {
    type Output;
    
    fn add(self, rhs: RHS) -> Self::Output;
}
```



```rust
use std::marker::PhantomData;
use std::ops::Add;

#[derive(Debug, Copy, Clone)]
struct Inch;

#[derive(Debug, Copy, Clone)]
struct Mm;

#[derive(Debug, Copy, Clone)]
struct Length<Unit>(f64, PhantomData<Unit>);

impl<Unit> Add for Length<Unit> {
    type Output = Length<Unit>;

    fn add(self, rhs: Self) -> Self::Output {
        Length(self.0 + rhs.0, PhantomData)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let i1: Length<Inch> = Length(3.7, PhantomData);
        let i2: Length<Inch> = Length(5.2, PhantomData);
        let i = i1 + i2;
        assert_eq!(i.0, 8.9);

        let m1: Length<Mm> = Length(1.1, PhantomData);
        let m2: Length<Mm> = Length(2.1, PhantomData);
        let m = m1 + m2;
        assert_eq!(m.0, 3.2);
    }
}
```



# 6. 泛型示例

## 6.1 泛型容器

```rust
#[derive(Debug)]
struct Container<T> {
    item: T,
}

impl<T> Container<T> {
    fn new(item: T) -> Self {
        Self { item }
    }

    fn get(&self) -> &T {
        &self.item
    }

    fn replace(&mut self, item: T) -> T {
        std::mem::replace(&mut self.item, item)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn int_container() {
        let mut c = Container::new(123);
        assert_eq!(c.get(), &123);

        let old_val = c.replace(321);
        assert_eq!(old_val, 123);
    }

    #[test]
    fn string_container() {
        let c = Container::new("hello");
        assert_eq!(c.get(), &"hello");
    }
}
```



## 6.2 泛型特征

```rust
trait Printable {
    fn format(&self) -> String;
}

impl<T: std::fmt::Display> Printable for Vec<T> {
    fn format(&self) -> String {
        let mut s = String::new();
        for (i, item) in self.iter().enumerate() {
            if i > 0 {
                s.push_str(", ");
            }
            s.push_str(item.to_string().as_str());
        }

        format!("[{}]", s)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let v1 = vec![1, 2, 3];
        assert_eq!(v1.format(), "[1, 2, 3]");

        let v2 = vec!["hello", "world"];
        assert_eq!(v2.format(), "[hello, world]");
    }
}
```



## 6.3 泛型迭代器

```rust
struct Chain<I, J> {
    first: I,
    second: J,
    use_first: bool,
}

impl<I: Iterator, J: Iterator<Item=I::Item>> Iterator for Chain<I, J> {
    type Item = I::Item;

    fn next(&mut self) -> Option<Self::Item> {
        if self.use_first {
            match self.first.next() {
                Some(item) => Some(item),
                None => {
                    self.use_first = false;
                    self.second.next()
                }
            }
        } else {
            self.second.next()
        }
    }
}

impl<I: Iterator, J: Iterator<Item=I::Item>> Chain<I, J> {
    fn new(first: I, second: J) -> Self {
        Chain {
            first,
            second,
            use_first: true,
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::generic_iterator::Chain;

    #[test]
    fn it_works() {
        let v1 = vec![1, 2, 3];
        let v2 = vec![4, 5, 6];

        let mut index = 0;
        let mut result = String::new();

        let chain = Chain::new(v1.iter(), v2.iter());
        for item in chain {
            if index > 0 {
                result.push_str(", ");
            }
            result.push_str(&format!("{}", item));
            index += 1;
        }

        assert_eq!(result, "1, 2, 3, 4, 5, 6");
    }
}
```



## 6.4 泛型状态机

```rust
#[derive(Debug, PartialEq)]
enum State {
    Start,
    Processing,
    Done,
}

struct StateMachine<T> {
    state: State,
    data: Option<T>,
}

impl<T> StateMachine<T> {
    fn new() -> Self {
        StateMachine {
            state: State::Start,
            data: None,
        }
    }

    fn process(&mut self, input: T)
    where
        T: Clone,
    {
        match self.state {
            State::Start => {
                self.state = State::Processing;
                self.data = Some(input);
            }
            State::Processing => {
                // if let Some(_) = self.data.take() {
                //     self.state = State::Done;
                //     self.data = Some(input);
                // }
                if let Some(ref mut data) = self.data {
                    *data = input;
                    self.state = State::Done;
                }
            }
            State::Done => {
                // already done, ignore it
            }
        }
    }

    fn get_state(&self) -> &State {
        &self.state
    }

    fn get_data(&self) -> Option<&T> {
        self.data.as_ref()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let mut sm: StateMachine<i32> = StateMachine::new();
        assert_eq!(sm.get_state(), &State::Start);

        sm.process(1);
        assert_eq!(sm.get_state(), &State::Processing);
        assert_eq!(sm.get_data(), Some(&1));

        sm.process(2);
        assert_eq!(sm.get_state(), &State::Done);
        assert_eq!(sm.get_data(), Some(&2));

        sm.process(3);
        assert_eq!(sm.get_state(), &State::Done);
        assert_eq!(sm.get_data(), Some(&2));  // 未变化
    }
}
```



## 6.5 泛型构造器模式

```rust
#![allow(dead_code)]
#[derive(Debug)]
struct Request<T> {
    url: String,
    method: String,
    payload: Option<T>,
    headers: Vec<(String, String)>,
}

struct RequestBuilder<T> {
    url: Option<String>,
    method: Option<String>,
    payload: Option<T>,
    headers: Vec<(String, String)>,
}

impl<T> RequestBuilder<T> {
    fn new() -> Self {
        RequestBuilder {
            url: None,
            method: None,
            payload: None,
            headers: Vec::new(),
        }
    }

    fn url(mut self, url: impl Into<String>) -> Self {
        self.url = Some(url.into());
        self
    }

    fn method(mut self, method: impl Into<String>) -> Self {
        self.method = Some(method.into());
        self
    }

    fn payload(mut self, payload: T) -> Self {
        self.payload = Some(payload);
        self
    }

    fn header(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.headers.push((key.into(), value.into()));
        self
    }

    fn build(self) -> Result<Request<T>, &'static str> {
        let url = self.url.ok_or("url is missing")?;
        let method = self.method.unwrap_or("GET".to_string());

        Ok(Request {
            url,
            method,
            payload: self.payload,
            headers: self.headers,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let request = RequestBuilder::new()
            .url("http://example.com")
            .method("GET")
            .header("UserAgent", "go-agent")
            .header("Content-Type", "text/html")
            .payload("<h1>Hello</h1>")
            .build()
            .unwrap();

        println!("{:#?}", request);
    }
}
```



## 6.6 泛型命令模式

```rust
use std::fmt::Display;

trait Command {
    fn execute(&self);
}

struct PrintCommand<T: Display> {
    content: T,
}

impl<T: Display> Command for PrintCommand<T> {
    fn execute(&self) {
        println!("{}", self.content);
    }
}

struct CommandQueue {
    commands: Vec<Box<dyn Command>>,
}

impl CommandQueue {
    fn new() -> Self {
        CommandQueue {
            commands: Vec::new(),
        }
    }

    // 内部包装，注意使用全局生命周期
    fn push<T: Command + 'static>(&mut self, command: T) {
        self.commands.push(Box::new(command));
    }

    // 外部包装
    fn add(&mut self, command: Box<dyn Command>) {
        self.commands.push(command);
    }

    fn execute_all(&mut self) {
        for command in self.commands.iter() {
            command.execute();
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let mut q = CommandQueue::new();
        q.push(PrintCommand { content: "hello world" });
        q.push(PrintCommand { content: 123 });
        q.add(Box::new(PrintCommand { content: 3.14159 }));

        q.execute_all();
    }
}
```





# 7. 最佳实践

## 7.1 合理使用约束

```rust
// 好的做法：明确的 trait 约束
fn process<T: Display + Clone>(item: T) {}

// 更好做法：where 子句提高可读性
fn process<T>(item: T)
where
    T: Display + Clone {
        
}
```



## 7.2 避免过度泛型化

```rust
// 不必要的泛型
struct Point<T> {
    x: T,
    y: T,
}

// 如果只用于特定类型，直接使用具体类型
struct Point {
    x: f64,
    y: f64,
}
```



## 7.3 使用泛型约束提供默认实现

```rust
trait WithDefault {
    fn default() -> Self;
}

impl<T: Default> WithDefault for T {
    fn default() -> Self {
        T::default()
    }
}
```

