# 1. 变量

## 1.1 变量绑定

```rust
let x: i32 = 1;
let x = 1;        // 省略类型，使用类型推断(type inference)
let mut x = 3;    // 变量值可变
let (a, b) = (1, 2);
```

变量绑定需注意点：

- 变量默认不可变(immutable)，除非加上 mut 关键字
- 变量具有局部作用域，被限制在所属代码块内，并允许被覆盖(variable shadowing)
- 默认开启属性 `#[warn(unused_variable)]`，对未使用的变量发出警告，以`_`开头的除外
- 允许先声明后初始化，但未被初始化的变量会产生编译错误



## 1.2 可变性 (mut) 

```rust
fn main() {
    let mut n = 10;
    println!("n is {}", n);
    
    n = 11;
    println!("n is {}", n);
}
```



## 1.3 隐藏 (shadow)

Rust 允许「重复」创建同名变量，称为隐藏（Shadow）

```rust
fn main() {
    let n = 10;
    
    {
        let n = "abc";
        println!("n is {}", n);  // abc
    }
    
   	println!("n is {}", n);   // 10
}
```



## 1.4 总结

Rust 是静态类型语言，运行期间不能改变变量类型。

- 通过 let 创建变量，Rust 中一般叫做变量绑定；
- 默认变量不可变，创建可变绑定，可以在变量名前加上 mut 关键字；
- 重复定义重名变量会隐藏（shadow）之前的变量，但要注意作用域问题；



# 2. 常量

Rust 有两种常量，可以在任意作用域声明，包括全局作用域。

- `const`：不可改变的值
- `static`：具有 static 生命周期，可变的变量（须使用 `static mut` 关键字）

有个特例就是 `"string"` 字面量。它可以不经改动就被赋给一个 `static` 变量，因为它的类型标记：`&'static str` 就包含了所要求的生命周期 `'static`。

```rust
static LANGUAGE: &'static str = "Rust";
const THRESHOLD: i32 = 10;

fn main() {
    println!("{}, {}", LANGUAGE, THRESHOLD);
    println!("{}", is_big(15));
}

fn is_big(n: i32) -> bool {
    n > THRESHOLD
}
```

一些重要的区别：

- 常量`const` 在编译时被内联，但静态变量`static`不会。在整个程序中静态变量只有一个实例，也就是说所有引用都指向同一个地址。
- 常量不可变，而静态变量和普通变量一样，默认不可变，但可以通过 mut 关键字定义为可变。



# 3. 流程控制

## 3.1 语句与表达式

Rust 中的语法可以分为两大类：

- **语句(Statement)**：完成了一个具体的操作，但是并**没有返回值**。像声明各种语言项，如变量、常量、结构体、函数等，都是声明语句。
- **表达式(Expression)**：主要用于计算求值，**它通过在末尾加上 ";" 来将表达式变成语句，丢弃该表达式的值，一律返回元类型 `()`**

表达式总是返回一个值，但是**语句不返回值或者返回 `()`**

```rust
let x: i32;  // 声明语句
x = 5;       // 表达式语句

let y = 6;   // 声明并赋值语句

let y = (let x = 5);  // 错误，x =5 是表达式，返回元类型值 ()
```



## 3.2 条件表达式

分支结构：`if -> else if -> else`，是一个表达式(expression)

```rust
let x = 5;
let z: i32 = if x < 5 { 10; } else { 15; };  // 注意{}中加“;”，否则是表达式
```



## 3.3 循环表达式

### 3.3.1 for

```rust
for item in container {
    code
}
```

其中，container是一个迭代器(iterator)，例如 `0..10` 或 [0, 1, 2].iter() 等

```rust
// [1, 10)
for x in 1..10 {
    print!("{x} ");
}

// [1, 10]
for x in 1..=10 {
    print!("{x} ");
}
```



**注意**:  `for` 往往使用集合的引用形式，**如果不使用引用，所有权会被转移（move）到 `for` 语句块中**，后面就无法再使用这个集合

```rust
for item in &container {
  // ...
}
```

对于实现了 `copy` 特征的数组(例如 [i32; 10] )而言， `for item in arr` 并不会把 `arr` 的所有权转移，而是直接对其进行了拷贝，因此循环之后仍然可以使用 `arr` 

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    for i in a {
        print!("{} ", i);
    }

    println!("\n{:?}", a); // ok
}
```



使用方法总结：

| 使用方法                      | 等价使用方式                                      | 所有权     |
| ----------------------------- | ------------------------------------------------- | ---------- |
| `for item in collection`      | `for item in IntoIterator::into_iter(collection)` | 转移所有权 |
| `for item in &collection`     | `for item in collection.iter()`                   | 不可变借用 |
| `for item in &mut collection` | `for item in collection.iter_mut()`               | 可变借用   |



两种循环方式比较：

```rust
let collection = [1, 2, 3, 4, 5];

// 循环索引(不推荐)
for i in 0..collection.len() {
  let item = collection[i];
  // ...
}

// 直接循环
for item in collection {

}
```

- **性能**：索引方式，因边界检查(Bounds Checking)，导致运行时性能损耗；直接循环则不会触发边界检查。

- **安全**：索引方式访问集合是不连续的，存在一定可能性在两次访问之间，集合发生变化，从而导致脏数据产生；直接循环则是连续的，由于所有权控制，在访问过程中，数据不会发生变化，因此是安全的。



### 3.3.2 while

```rust
let mut i = 0;

while i < 10 {
    print!("{i} ");
	i += 1;
}
```



### 3.3.3 loop

无限循环：

```rust
fn main() {
    'outer: loop {
        println!("Entered outer loop");

        'inner: loop {
            println!("Entered inner loop");
            break 'outer;
        }

        println!("This point will never be reached");
    }

    println!("Exited outer loop");
}
```



loop 是一个值，可以返回值：

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter*2;
        }
    };

    println!("result={}", result)
}
```



复杂控制：

```rust
fn main() {
    let mut count  = 0;

    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }

            if count == 2 {
                break 'counting_up;
            }

            remaining -= 1;
        }

        count += 1;
    }

    println!("End count = {count}")
}
```



# 4. 模式匹配

模式一般由以下内容组成：

- 字面值
- 解构的数组、枚举、结构体或者元组
- 变量
- 通配符
- 占位符



## 4.1 match

match 用于检查某个当前的值是否匹配一组、列值中的某一个

```rust
match target {
    pattern1 => expression1,
    pattern2 => {
        statement1;
        statement2;
        expression2
    },
    pattern3 | pattern4 => expression3,
    _ => expression4
}
```



示例1：

```rust
fn test_match(n: i32) -> &'static str {
    match n {
        1 => {println!("one"); "one"},
        2 | 3 | 5 | 7 | 11 => "A prime",
        13..=19 => "A teen",
        _ => "Ain't special",
    }
}
```



示例2：

```rust
enum Coin {
    Penny,
    Nickle,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        },
        Coin::Nickle => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```



示例3：

```rust
enum IpAddr {
    Ipv4,
    Ipv6,
}

fn main() {
    let ip = IpAddr::Ipv6;
    let ip_str = match ip {
        IpAddr::Ipv4 => "127.0.0.1",
        _ => "::1",
    };

    println!("{}", ip_str);
}
```



示例4：

```rust
enum Color {
    Rgb(u8, u8, u8),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(124, 60, 234));
    
    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!("r{}, g{}, b{}", r, g, b);
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!("h{}, s{}, v{}", h, s, v);
        }
        _ => (),
    }
}
```



示例5：

`_`：忽略值，完全不会绑定；`_x`：未被使用的值不警告，仍会绑定值到变量

```rust
// s 是一个拥有所有权的动态字符串，因为 s 的值会被转移给 _s，在 println! 中再次使用 s 会报错
fn main() {
    let s = Some(String::from("hello"));

    // value partially moved here
    if let Some(_s) = s {
        println!("found a string");
    }

    // value borrowed here after partial move
    println!("{:?}", s);
}

// 只使用下划线本身，则并不会绑定值，因为 s 没有被移动进 _
fn main() {
    let s = Some(String::from("hello"));

    if let Some(_) = s {
        println!("found a string");
    }

    // ok
    println!("{:?}", s);
}
```



`..`：忽略剩余值

```rust
fn main() {
    let arr = [1, 2, 3, 4, 5];
    match arr {
        [first, .., last] => {
            println!("first={}, last={}", first, last);
        }
    }

    let tuple = (1, 4, 9, 16, 25);
    match tuple {
        (first, ..) => {
            println!("first={}", first);
        }
    }
}
```



## 4.2 if let

**if let 分支**：用于匹配一个模式，而忽略剩下的所有模式

```rust
if let PATTERN = SOME_VALUE {

}
```



当只有一个模式的值需要处理，直接忽略其他值的场景：

```rust
fn main() {
    let v = Some(3u8);

    match v {
        Some(3) => println!("three"),
        _ => (),
    }
}
```

**当只要匹配一个条件，且忽略其他条件时就用 `if let` ，否则都用 `match`**

```rust
fn main() {
    let v = Some(3u8);

    if let Some(3) = v {    // 注意是赋值
        println!("three");
    }
}
```



## 4.3 while let

**while let 条件循环**：只要模式匹配就一直进行 `while` 循环

```rust
// Vec是动态数组
let mut stack = Vec::new();

// 向数组尾部插入元素
stack.push(1);
stack.push(2);
stack.push(3);

// stack.pop从数组尾部弹出元素
while let Some(top) = stack.pop() {
    print!("{} ", top);
} // 3 2 1
```



## 4.4  `matches!` 宏

`matches!`宏，将一个表达式跟模式进行匹配，然后返回匹配的结果 `true` or `false`

```rust
#[derive(Debug)]
enum Test {
    Foo,
    Bar
}

fn matches_marco() {
    let v = [Test::Foo, Test::Bar, Test::Foo];

    // x is &&Test, cannot compare
    //let result = v.iter().filter(|x| x == Test::Bar);

    let result = v.iter().filter(|x| matches!(x, Test::Bar));
    for i in result {
        println!("{:?}", i);
    }
}
```



示例：

```rust
let foo = 'f';
assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));

let bar = Some(4);
assert!(matches!(bar, Some(x) if x > 2));
```



## 4.5 Option 枚举

```rust
enum Option<T> {
    Some(T),   // 有值
    None,      // 为空
}
```

匹配 `Option<T>`：

```rust
fn main() {
    let five = Some(5);
    let six = plus_one(five);
    println!("{:?}", six);

    let none = plus_one(None);
    println!("{:?}", none);
}

fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
        None => None,
    }
}
```



## 4.6 匹配守卫

**匹配守卫**（*match guard*）是一个位于 `match` 分支模式之后的额外 `if` 条件，它能为分支模式提供更进一步的匹配条件

```rust
fn main() {
    let x = Some(6);
    let y = 10;

    match x {
        Some(50) => println!("got 50"),
        Some(n) if n > 5 => println!("n={} is more than 5", n),
        Some(n) if n == y => println!("matched, n={}", n),
        _ => println!("default case, x={:?}", x),
    }
}
```



## 4.7 绑定操作

match 后是一个函数，在分支中，根据匹配结果，使用函数的返回值。`@` 运算符允许为一个字段绑定另外一个变量

示例1：

```rust
fn main() {
    match age() {
        0 => println!("not born"),
        n @ 1..=12 => println!("a child: {}", n),
        n @ 13..=19 => println!("a teenage: {}", n),
        n => println!("a old guy: {}", n),
    }
}

fn age() -> i8 {
    let mut rng = rand::thread_rng();
    let mut n: i8;

    loop {
        n = rng.gen();
        print!("{} ", n);
        if n > 0 && n < 100 {
            break
        }
    }
    println!();
    n
}
```



示例2：

```rust
enum Action {
    Say(String),
    MoveTo(i32, i32),
    ChangeColorRGB(u16, u16, u16),
}

fn main() {
    let actions = [
        Action::Say("Hello Rust".to_string()),
        Action::MoveTo(1, 2),
        Action::ChangeColorRGB(160, 32, 240), // purple
    ];
    
    for action in actions {
        match action {
            Action::Say(s) => {
                println!("{}", s);
            },
            Action::MoveTo(x, y) => {
                println!("point from (0, 0) move to ({}, {})", x, y);
            },
            Action::ChangeColorRGB(r, g, b) => {
                println!("change color to '(r{}, g{}, b{})'", r, g, b);
            },
        }
    }
}
```



## 4.8 ref 取得引用

```rust
fn main() {
    let (x, y) = (5, 6);

    match x {
        ref r => println!("got a reference to {}", r),
    }

    match y {
        ref r => println!("got a reference to {}", r),
    }
}
```



# 5. 函数

## 5.1 定义

```rust
fn func_name(para1: T, para2: T) -> T {
    
}
```

- 函数名：蛇形命名(snake_case)
- 返回值：`-> T`



## 5.2 参数

函数参数和变量一样，默认是不可变的，当需要可变参数时，一样得使用 mut 关键字







# 6. 方法

方法一般与结构体、枚举、特性(trait) 一起使用



### 2.7.1 定义方法(impl)

```rust
pub struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 关联函数，不带self
    pub fn new(width: u32, height: u32) -> Rectangle {
        Rectangle {
            width,
            height,
        }
    }

    pub fn area(&self) -> u32 {
        self.width * self.height
    }

    // getter
    pub fn width(&self) -> u32 {
        self.width
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let r = Rectangle::new(5, 7);
    println!("area={}", r.area());
    println!("width={}", r.width());

    let r2 = Rectangle::new(4, 5);
    println!("{}", r.can_hold(&r2));
}
```

关于 self：

- `self`：表示实例的所有权转移到该方法中，较少使用
- `&self`：表示该方法对实例的不可变借用

- `&mut self`：表示可变借用



## 2.8 泛型和特性

### 2.8.1 泛型 Generics

#### 2.8.1.1 泛型是什么

泛型就是一种多态。泛型主要目的是为程序员提供编程的便利，减少代码的臃肿，同时可以极大地丰富语言本身的表达能力。

```rust
fn add<T: std::ops::Add<Output = T>>(x: T, y: T) -> T {
    x + y
}

fn main() {
    println!("add i8: {}", add(3i8, 5i8));
    println!("add i32: {}", add(14, 9));
    println!("add f64: {}", add(1.5f64, 3.1f64));
}
```

示例2：

```rust
fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {
    let mut max= &list[0];

    for item in list.iter() {
        if item > max {
            max = item;
        }
    }

    max
}


fn main() {
    let number_list = vec![32, 17, 25, 68, 23];
    let result = largest(&number_list);
    println!("the largest number in list: {}", result);

    let char_list = vec!['a', 'z', 'g', 'x'];
    let result = largest(&char_list);
    println!("the largest char in list: {}", result);
}
```





### 2.8.2 特性 Trait





















- 指针：最底层的是裸指针`*const T`和`*mut T`，但解引用它们是不安全的，必须放到`unsafe`块里。

- 函数：具有函数类型的变量实质上是一个函数指针。

- 元类型：即`()`，其唯一的值也是`()`。



- 





```rust


// string
let s = "hello, world!";       // &str
let s1 = s.to_string();        // String
let s2 = String::from("ok");   // String



// raw pointers
let x = 3;
let raw = &x as *const i32;
let p = unsafe { *raw };
let raw2: *const i32 = &x;
let p2 = unsafe { *raw2 };

// function
fn foo(x: i32) -> i32 { x };
let bar: fn(x: i32) -> i32 = foo;
```

特殊用法：

- 单字节字符 `b'H'`，单字节字符串 `b"hello"`，仅限于ASCII字符
- 原始字符串 `r#"..."#`，不需要对特殊字符进行转义
- 使用 & 将 String 转换为 `&str` 不涉及分配内存，但使用 `to_string()` 将 `&str` 转换为 String 则需要分配内存
- 数组的长度是不可变的，动态的数组称为向量(vector)，可使用宏 `vec!` 来创建
- 元组可通过 == 及 != 来判断是否相同
- 小于等于32个元素的数组、小于等于12个元素的元组，在值传递时自动复制
- 原生类型不支持隐式转换，需要使用 as 关键字显式转换
- type 关键字定义类型的别名，采用驼峰命名法

```rust
// explicit conversion
let decimal = 65.4321_f32;
let integer = decimal as u8;
let character = integer as char;

// type alias
type NanoSecond = u64;
type Point = (u8, u8);
```











# 7. 注释

- 单行注释：以 // 开始

- 块注释：`/*  */`
- 文档注释：`///` 或 `//!`，支持 Markdown 语法，配合 rustdoc 自动生成说明文档
  - `///` 等价于属性 `#[doc = "..."]`
  - `//!` 等价于 `#[doc = "/// ..."]`




