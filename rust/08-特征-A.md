# 1. 基础知识

## 1.1 入门

Traits are similar to a feature often called *interfaces* in other languages, although with some differences.

`trait` 和 `impl` 的作用：

- **抽象和多态**：trait 定义抽象接口，实现多态
- **代码复用**：通过 trait，为不同类型实现相同的行为
- **功能扩展**：impl 允许为已有类型添加新的方法，即使是别人实现的类型
- **组织代码**：trait 和 impl 帮助更好地组织和结构化代码



初级使用：

- 定义：`trait Foo { fn f(&self) }`

- 实现：`impl Foo for Bar { ... }`
- 泛型约束：`T: Foo + Send + Sync + 'static`

但 trait 系统不止“接口”，更是 **关联类型、对象安全、擦除与组合**



### 1.1.1 定义

```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```



### 1.1.2 实现

```rust
pub struct NewArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewArticle {
    fn summarize(&self) -> String {
        format!("{} by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```

trait 定义与实现的位置的原则：**如果想要为类型 A 实现特征 T，那么 A 或 T 至少有一个是在当前作用域定义中的！该规则称为“<font color="red">孤儿规则</font>”**，用于确保其他人编写的代码不会破坏你的代码，也确保你不会莫名其妙地破坏牛马不相及的代码。



### 1.1.3 默认实现

提供默认的方法实现，使用该 trait 的类型可以选择使用或重写这些默认实现。

```rust
pub trait Summary {
    pub summarize_author(&self) -> String;
    
    pub summarize(&self) -> String {
        format!("Read more from {}", self.summarize_author())
    }
}
```



### 1.1.4 示例：运算符重载

```rust
use std::ops::Add;

#[derive(Debug)]
struct Point {
    x: f64,
    y: f64,
}

impl Add for Point {
    type Output = Point;
    
    fn add(self, other: Point) -> Self::Output {
        Point {
           x: self.x + other.x,
           y: self.y + other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1.7, y: 3.2 };
    let p2 = Point { x: 5.4, y: 6.6 };
    
    let p3 = p1 + p2;
    println!("{:?}", p3);
}
```



## 1.2 应用场景

### 1.2.1 函数参数

Instead of a concrete type for the `item` parameter, we specify the `impl` keyword and the trait name. This parameter accepts any type that implements the specified trait.

```rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```



### 1.2.2 函数返回

```rust
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from("of course, as you probably alreay know, people"),
        reply: false,
        retweet: false,
    }
}
```



### 1.2.3 特征约束

通过特征约束有条件实现方法

```rust
use std::fmt::Display;

pub struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    pub fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    pub fn cmp_display(&self) {
        if self.x > self.y {
            println!("The largest number is x = {}", self.x);
        } else {
            println!("The largest number is y = {}", self.y);
        }
    }
}
```

Only a type that has implemented `Display` & `PartialOrd` trait can call `cmp_display` method:

```rust
fn main() {
    let p = Pair::new(5, 10);

    p.cmp_display();
}
```



## 1.3 特征继承

```rust
trait Living {
    fn is_alive(&self) -> bool;
}

// trait约束，确保先满足Living
trait Animal: Living {
    fn make_sound(&self) -> String;
}

struct Dog {
    alive: bool,
}

impl Living for Dog {
    fn is_alive(&self) -> bool {
        self.alive
    }
}
    
impl Animal for Dog {
    fn make_sound(&self) -> String {
        "bark".to_string()
    }
}

fn main() {
    let dog = Dog { alive: true };
    
    println!("Is the dog alive?: {}, \nand it makes sound: {}", dog.is_alive(), dog.make_sound());
}
```



## 1.4. 特征约束

### 1.4.1 约束语法

在泛型编程中，trait bounds 用于指定一个泛型类型必须实现一个或多个 trait

```rust
// 改语法糖 impl Summary 形式为特征约束 T: Summary
pub fn notify(item: &impl Summary) {}
pub fn notify<T: Summary>(item: &T) {}

// 多个参数
pub fn notify(item1: &impl Summary, item2: &impl Summary) {}
pub fn notify<T: Summary>(item1: &T, item2: &T) {}
```



**多重约束**：

```rust
// 语法糖形式
pub fn notify(item: &(impl Summary + Display)) {}

// 特征约束形式
pub fn notify<T: Summary + Display>(item: &T) {}
```



**Where 约束**:

```rust
// 特征约束很多时，函数签名将变得很复杂
fn some_func<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}

// 通过 where 改写
fn some_func<T, U>(t: &T, u: &U) -> i32
where
	T: Display + Clone,
	U: Clone + Debug,
{}
```



### 1.4.2 条件约束

方式一：

```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self {
            x,
            y,
        }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x > self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}

// 有条件地实现特征：对于任何实现了 Display 特征的类型调用由  ToString 定义的 `to_string()` 方法。
impl<T: Display> ToString for T {
    // --snip--
}
```



方式二：`impl Trait for Type where ...`

```rust
use std::fmt::Display;

trait Summary {
    fn summarize(&self) -> String;
}

impl<T> Summary for Vec<T>
where
    T: Display
{
    fn summarize(&self) -> String {
        let items: Vec<String> = self.iter().map(|x| format!("{}", x)).collect();
        format!("Vector containing: [{}]", items.join(", "))
    }
}

fn main() {
    let vi = vec![1, 2, 3, 4, 5];
    println!("{}", vi.summarize());
    
    let vs = vec!["abc", "123", "xyz"];
    println!("{}", vs.summarize());
}
```



## 1.5 重叠消除

针对多个 trait 具有相同的方法，为消除歧义，可以使用完全限定语法 (Fully Qualified Syntax)

```rust
trait UsernameWidget {
    fn get(&self) -> String;
}

trait AgeWidget {
    fn get(&self) -> u8;
}

struct Form {
    username: String,
    age: u8,
}

impl UsernameWidget for Form {
    fn get(&self) -> String {
        self.username.clone()
    }
}

impl AgeWidget for Form {
    fn get(&self) -> u8 {
        self.age
    }
}

fn main() {
    let form = Form {
        username: "rustacean".to_owned(),
        age: 28,
    };

    let username = <Form as UsernameWidget>::get(&form);
    assert_eq!("rustacean".to_owned(), username);

    let age = <Form as AgeWidget>::get(&form);
    assert_eq!(28, age);
}
```



## 1.6 关联类型

将 “泛型参数” 藏进 trait 里

```rust
trait Service {
    type Request;
    type Response;
    
    fn call(&self, req: Self::Request) -> Self::Response;
}

struct Upper;

impl Service for Upper {
    type Request = String;
    type Response = String;
    
    fn call(&self, req: String) -> String {
        req.to_uppercase()
    }
}
```

它把“实现者必须指定的类型关系”变成 trait 的一部分。不再需要在每个使用点都带着 `Service<Req, Resp>` 这种外置泛型，而是让类型关系被实现者承诺。

典型场景：

- 抽象 IO、协议解析、编解码
- 组合中间件 (Request/Response 贯穿链路)
- 迭代器体系 (`Iterator::Item` 即关联类型)



# 2. 动态分发

dyn 关键字用于表示动态分发的 trait 对象。它本质上是一种在**<font color="red">运行时确定具体类型</font>**的方式，运行在不知道具体类型的情况下调用 trait 方法。

dyn trait 不只是“慢”，它可以**把类型抹掉、换取运行期组合、跨 crate 边界稳定 API、减少泛型膨胀**

```rust
fn run_all(tasks: Vec<Box<dyn Fn() + Send>>) {
    for t in tasks {
        t();
    }
}
```

使用场景：

- 插件式注册 (回调、策略、处理器列表)
- 编译时间和二进制体积成为问题 (泛型单态化带来的膨胀)
- 希望公开 API 不被泛型“污染” (用户不用理解API内部的一堆类型参数)



## 2.1 基本语法

```rust
trait Drawable {
    fn draw(&self);
}

struct Circle {
    radius: f64,
}

struct Reactangle {
    width: f64,
    height: f64,
}

impl Drawable for Circle {
    fn draw(&self) {
        println!("Drawing a circle with the radius: {}", self.radius);
    }
}

impl Drawable for Reactangle {
    fn draw(&self) {
        println!("Drawing a reactangle: {} x {}", self.width, self.height);
    }
}

// 使用trait对象
fn draw_shapes(shapes: Vec<Box<dyn Drawable>>) {
    for shape in shapes {
        shape.draw();
    }
}

fn main() {
    let shapes: Vec<Box<dyn Drawable>> = vec![
        Box::new(Circle { radius: 5.2 }),
        Box::new(Reactangle { width: 3.7, height: 4.0 }),
    ];
    
    draw_shapes(shapes);
}
```



## 2.2 动态分发

### 2.2.1 静态分发(static dispatch)

泛型是在编译期完成处理的，编译器会为每一个泛型参数对应的具体类型生成一份代码。因为在编译期完成，对运行时性能完成没有任何影响

```rust
// 静态分发 (编译期确定)
fn foo<T: Draw>(x: &T) {
    x.draw();
}
```

- 使用泛型
- 编译期单态化 (monomorphization)
- 快，但会产生多份代码



### 2.2.2 动态分发(dynamic dispatch)

直到运行时，才能确定需要调用什么方法。

```rust
// 动态分发 (运行期确定)
fn foo(x: &dyn Draw) {
    x.draw();
}
```

- 使用 trait 对象
- 运行期通过 `vtable` 查找方法
- 有一次 间接开销，但更灵活



### 2.2.3 静态和动态对比

静态分发 `Box<T>` 和动态分发 `Box<dyn Trait>` 的区别：

![img](https://cdn.jsdelivr.net/gh/elihe2011/bedgraph@master/rust/rust-static-vs-dynamic-dispatch.png)

- **特征对象大小不固定**：对于特征 Draw，类型 Button 和 SelectBox 都可以实现它，因此特征没有固定大小
- **几乎总是使用特征对象的引用方式**，如 `&dyn Draw`，`Box<dyn Draw>`
  - <font color="redish">特征对象没有固定大小，但它的引用类型的大小是固定的</font>，它由两个指针组成 (`ptr` & `vptr`)，因此占用两个指针大小
  - 指针 `ptr` 指向一个实现特征 Draw 的具体类型的实例，即当作特征 Draw 来用的类型的实例，比如类型 Button 和 SelectBox 的实例
  - 指针 `vptr` 指向一个虚表 `vtable`，该虚表中保存了类型 Button 和 SelectBox 的实例对于可以调用的实现于特征 Draw 的方法。当调用方法时，直接从 `vtable` 中找到方法并调用。



```rust
// 静态分发 (单态化)
fn static_dispatch<T: Animal>(animal: T) {
    animal.make_sound();
}

// 动态分发
fn dynamic_dispatch(animal: &dyn Animal) {
    animal.make_sound();
}

// 性能比较
fn performance_comparison() {
    let dog = Dog { name: String::from("Rex") };
    static_dispatch(dog);   // 编译时确定具体类型，生成专门的代码
    
    let cat = Cat { name: String::from("Whiskers") };
    dynamic_dispatch(&dog);  // 运行时查找方法，通过虚表调用
}
```



### 2.2.4 总结

| 特性     | 静态分发                 | 动态分发                     |
| :------- | :----------------------- | :--------------------------- |
| 机制     | 单态化（编译时代码生成） | Trait 对象 + 虚表（vtable）  |
| 关键字   | 泛型（`impl<T: Trait>`） | `dyn Trait`                  |
| 性能     | 零开销，可内联           | 间接调用开销，无法内联       |
| 灵活性   | 编译时类型固定           | 运行时类型可变，支持异构集合 |
| 核心约束 | Trait 约束               | **对象安全性**               |

**简单记忆**：

- 当你需要**性能**和**类型已知**时，用**静态分发**（泛型）。
- 当你需要**运行时多态**、存储**异构类型集合**或**减小二进制大小**时，用**动态分发**（`dyn Trait`）。
- 使用 `dyn Trait` 时，必须确保你的 trait 是**对象安全的**：方法接收者要明确、无泛型方法、不返回 `Self`。



## 2.3 对象安全性 (Object Safety)

<font color="red">只有“对象安全”的 trait，才能用于动态方法 (dyn trait)</font>

一个 trait 如果可以被当作 trait 对象使用 (即 dyn trait)，就称它是对象安全的。



### 2.3.1 **两大核心规则**

✅ 规则 1：**方法不能返回 `Self`**

❌ 不安全：

```rust
trait Foo {
  	fn clone(&self) -> Self; // ❌
}
```

原因：

- `dyn Foo` 在运行时不知道具体类型
- 无法确定 `Self` 的大小

✅ 修正方式：

```
trait Foo {
    fn clone_box(&self) -> Box<dyn Foo>;
}
```



✅ 规则 2：**方法不能使用未受限制的泛型参数**

❌ 不安全：

```
trait Foo {
    fn bar<T>(&self, t: T); // ❌
}
```

原因：

- 泛型是 **编译期特性**
- 动态分发是 **运行期行为**



### 2.3.2 **`Self: Sized`  逃生通道**

Rust 允许部分 trait 不安全对象

```rust
trait Foo {
    fn object_safe(&self);
    
    fn not_object_safe(&self) -> Self
    where
    	Self: Sized;
}
```

- `Self: Sized` 方法 不会出现在 `vtable`
- 仍然可以用 `dyn Foo`



### 2.3.3 总结

| 情况                                | 是否对象安全 |
| ----------------------------------- | ------------ |
| 返回 `Self`                         | ❌            |
| 方法有泛型参数                      | ❌            |
| 使用 `Self` 作为参数                | ✅            |
| `&self` / `&mut self` / `Box<Self>` | ✅            |
| 关联常量                            | ✅            |
| 关联类型                            | ✅            |
| `where Self: Sized`                 | ✅（被排除）  |



```rust
// 非对象安全 trait
trait NonObjectSafe {
    fn new() -> Self;  // 不允许在 dyn 中使用
    fn get_type(&self) -> Self;  // 不允许在 dyn 中使用
}

// 对象安全 trait
trait ObjectSafe {
    fn describe(&self) -> String;  // 允许在 dyn 中使用
    fn clone_box(&self) -> Box<dyn ObejctSafe>;  // 允许在 dyn 中使用
}

// 使用 where Self: Sized 来允许非对象安全方法
trait Mixed {
    fn normal_method(&self);  // 对象安全
    
    fn non_object_safe() -> Self where Self: Sized; // 通过 where 子句使方法可用
}
```

```rust
trait Bad {
    fn f<T>(&self, t: T);
}
```

无法编译 `Box<dyn Bad>`。 表面结论：“**带泛型方法的 trait 不能对象化**”

真正原因：**dyn trait 的调用必须在运行期通过 `vtable` 找到具体函数签名，而泛型方法需要编译期单态化，两者冲突**。



:alarm_clock:**trait 要变 `dyn`**:

- 方法不返回 Self
- 方法不带泛型
- 必要时用 `Self: Sized` 规避



## 2.4 特征组合

```rust
trait Drawable {
    fn draw(&self);
}

trait Resizable {
    fn resize(&self, width: u32, height: u32);
}

// 组合多个 trait
trait DrawableAndResizable: Drawable + Resizable {}

impl<T: Drawable + Resizable> DrawableAndResizable for T {}

struct Canvas {
    elements: Vec<Box<dyn DrawableAndResizable>>,
}

impl Canvas {
    fn add_element(&mut self, element: Box<dyn DrawableAndResizable>) {
        self.elements.push(element);
    }
    
    fn draw_all(&self) {
        for element in &self.elements {
            element.draw();
        }
    }
}
```



## 2.5 动态分发与泛型结合

```rust
trait Factory<T> {
    fn create(&self) -> T;
}

struct GenericProcessor<T> {
    factory: Box<dyn Factory<T>>,
}

impl<T> GenericProcessor<T> {
    fn process(&self) -> T {
        self.factory.create()
    }
}

// 实现具体工厂
struct StringFactory;

impl Factory<String> for StringFactory {
    fn create(&self) -> String {
        "Hello".to_string()
    }
}
```



## 2.6 生命周期

```rust
trait WithLifetime<'a> {
    fn process(&self, data: &'a str);
}

// 显式生命周期标注
type DynWithLifetime<'a> = dyn WithLifetime<'a> + 'a;

struct Processor;

impl<'a> WithLifetime<'a> for Processor {
    fn process(&self, data: &'a str) {
        println!("Processing: {}", data);
    }
}

fn use_processor<'a>(processor: Box<DynWithLifetime<'a>>, data: &'a str) {
    processor.process(data);
}
```



## 2.7 函数返回

Rust 编译器需要直到每个函数的返回类型需要多少空间，这意味着所有函数都必须返回一个具体类型。但函数如何返回 trait？因为其不同的实现将需要不同的内存量，所以无法直接返回。

**解决方法**：返回一个包含 trait 的 Box。因为 Box 只对堆中某些内存的引用，引用的大小是静态已知的，满足函数返回值的要求。

当函数通过上述方式返回指向堆的 trait 指针，则需要使用 dyn 关键字指定返回类型，例如 `Box<dyn Animal>`

```rust
struct Sheep {}
struct Cow {}

trait Animal {
    fn noise(&self) -> &'static str;
}

impl Animal for Sheep {
    fn noise(&self) -> &'static str {
        "baaaaah!"
    }
}

impl Animal for Cow {
    fn noise(&self) -> &'static str {
        "moooooo!"
    }
}

fn random_animal(random_number: f64) -> Box<dyn Animal> {
    if random_number < 0.5 {
        Box::new(Sheep {})
    } else {
        Box::new(Cow {})
    }
}

fn main() {
    let random_number = 0.234;
    let animal = random_animal(random_number);
    println!("You've randomly chosen an animal, and it says {}", animal.noise());
}
```



## 2.8 特征对象

对不同类型进行统一处理时，trait objects 提供了一种方法，它们通过一个指向实现了特定 trait 的类型的指针来实现动态分发。

```rust
// &dyn Drawable 是 trait object 的应用，在运行时处理不同的实现了 Drawable trait 的类型
fn print_drawables_dyn(drawables: &[&dyn Drawable]) {
    for drawable in drawables {
        drawable.draw();
    }
}
```



# 3. 性能优化

## 3.1 虚表缓存

```rust
struct CachedDispatch<T: ?Sized> {
    vtable: *const (),
    data: *const T,
}

impl<T: ?Sized> CachedDispatch<T> {
    fn new(data: &T) -> Self {
        CachedDispatch {
            vtable: std::ptr::null(),
            data: data as *const T,
        }
    }
}
```



## 3.2 静态分发和动态分发

```rust
trait Processor {
    fn process(&self, data: &str);
}

// 热点路径使用静态分发
fn fast_path<T: Processor>(processor: &T, data: &str) {
    processor.process(data);
}

// 非关键路径使用动态分发
fn flexible_path(processor: &dyn Processor, data: &str) {
    processor.process(data);
}
```



## 3.3 内存布局优化

```rust
use std::any::Any;

// 不好的设计
struct Unoptimized {
    dynamic: Box<dyn Any>,  // 动态大小
    value: u32,             // 固定大小
}

// 优化后
struct Optimized {
    value: u32,            // 固定大小先放
    dynamic: Box<dyn Any>, // 动态大小后放
}

// 使用 const 泛型优化
struct ArrayWrapper<const N: usize> {
    data: [u8; N],   // 编译时确定大小
}
```



## 3.4 泛型约束优化

```rust
// 通用实现
trait DataProcessor {
    fn process(&self);
}

// 针对 Sized 类型优化实现
impl<T: Sized> DataProcessor for T {
    #[inline(always)]
    fn process(&self) {
        // 直接内联的快速处理路径
        println!("Fast path for sized type");
    }
}

// 针对动态大小类型实现
impl<T: ?Sized> DataProcessor for Box<T> {
    fn process(&self) {
        // 动态分发的处理路径
        println!("Dynamic dispatch path");
    }
}
```



# 4. 最佳实践

**合理选择分发方式**：

- 性能关键路径优先使用静态分发
- 需要灵活性时使用动态分发
- 考虑编译时间和而进行大小的平衡



最佳实践：

- 面向接口编程
  - 优先使用 trait 定义接口
  - 利用泛型和 trait 约束实现多态
- 组合优于继承
  - 使用 trait 组合实现复杂行为
  - 避免深层次的 trait 继承关系
- 封装与抽象
  - 使用 trait 隐藏实现细节
  - 提供清晰的公共接口
- 性能考虑
  - 静态分发和动态分发
  - 适时使用 trait 对象



## 4.1 trait 对象大小考虑

```rust
// 使用 Box 减少栈空间
type BigProcessor = dyn Processor + Send + Sync;
struct Manager {
    processor: Box<BigProcessor>,
}
```



## 4.2 生命周期明确标注

```rust
type DynProcessor<'a> = dyn Processor + 'a;

fn process_data<'a>(processor: &'a dyn Processor, data: &'a str) {
    processor.process(data);
}
```



## 4.3 高性能容器

```rust
struct FastContainer<T: Sized> {
    data: Vec<T>,
    metadata: Box<dyn Any>,
}

impl<T: Sized> FastContainer<T> {
    fn new() -> Self {
        Self {
            data: Vec::new(),
            metadata: Box::new(()),
        }
    }
    
    #[inline(always)]
    fn push(&mut self, item: T) {
        self.data.push(item);
    }
    
    fn iter(&self) -> impl Iterator<Item = &T> {
        self.data.iter()
    }
}
```



## 4.4 零拷贝处理

```rust
trait ZeroCopy: Sized {
    fn as_bytes(&self) -> &[u8] {
        unsafe {
            std::slice::from_raw_parts(
            	self as *const Self as *const u8,
                std::mem::size_of::<Self>(),
            )
        }
    }
}

// 为固定大小类型实现零拷贝
#[repr(C)]
struct PackedData {
    header: u32,
    playload: [u8; 64],
}

impl ZeroCopy for PackedData {}
```



# 5. 实例

## 5.1 插件系统

```rust
trait Plugin {
    fn name(&self) -> &str;
    fn execute(&self);
}

struct PluginManager {
    plugins: Vec<Box<dyn Plugin>>,
}

impl PluginManager {
    fn new() -> Self {
        PluginManager { plugins: Vec::new() }
    }
    
    fn register_plugin(&mut self, plugin: Box<dyn Plugin>) {
        println!("Registering plugin: {}", plugin.name());
        self.plugins.push(plugin);
    }
    
    fn execute_all(&self) {
        for plugin in &self.plugins {
            plugin.execute();
        }
    }
}

// 具体插件实现
struct LoggerPlugin;
impl Plugin for LoggerPlugin {
    fn name(&self) -> &str { "Logger" }
    fn execute(&self) { println!("Logging..."); }
}
```



## 5.2 状态模式

```rust
trait State {
    fn handle_input(&self) -> Box<dyn State>;
    fn update(&self);
    fn render(&self);
}

struct StateMachine {
    state: Box<dyn State>,
}

impl StateMachine {
    fn new(initial_state: Box<dyn State>) -> Self {
        StateMachine { state: initial_state }
    }
    
    fn update(&mut self) {
        let new_state = self.state.handle_input();
        self.state = new_state;
        self.state.update();
        self.state.render();
    }
}
```



## 5.3 命令模式

```rust
trait Command {
    fn execute(&self);
    fn undo(&self);
}

struct CommandManager {
    commands: Vec<Box<dyn Command>>,
    current: usize,
}

impl CommandManager {
    fn new() -> Self {
        CommandManager {
            commands: Vec::new(),
            current: 0,
        }
    }
    
    fn execute(&mut self, command: Box<dyn Command>) {
        command.execute();
        self.commands.push(command);
        self.current += 1;
    }
    
    fn undo(&mut self) {
        if self.current > 0 {
            self.current -= 1;
            self.commands[self.current].undo();
        }
    }
}
```



## 5.4 构建者模式

```rust
trait Builder {
    type Output;
    fn build(self) -> Result<Self::Output, String>;
}

#[derive(Default, Debug)]
struct Computer {
    cpu: Option<String>,
    memory: Option<String>,
    storage: Option<String>,
}

#[derive(Debug)]
struct ComputerBuilder {
    computer: Computer,
}

impl ComputerBuilder {
    fn new() -> Self {
        ComputerBuilder {
            computer: Computer::default(),
        }
    }
    
    fn cpu(mut self, cpu: String) -> Self {
        self.computer.cpu = Some(cpu);
        self
    }
    
    fn memory(mut self, memory: String) -> Self {
        self.computer.memory = Some(memory);
        self
    }
    
    fn storage(mut self, storage: String) -> Self {
        self.computer.storage = Some(storage);
        self
    }
}

impl Builder for ComputerBuilder {
    type Output = Computer;
    
    fn build(self) -> Result<Self::Output, String> {
        let computer = self.computer;
        if computer.cpu.is_none() {
            Err("Cpu is required".to_string())
        } else {
            Ok(computer)
        }
    } 
}

fn main() {
    let cb = ComputerBuilder::new()
        .cpu("Intel(R) Core(TM) i7-10700 CPU @ 2.90GHz 2.90 GHz".to_string())
        .memory("16 GB".to_string())
        .storage("SSD 240GB".to_string());
    
    println!("{:?}", cb.build());
}
```

