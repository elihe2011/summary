# 1. 什么是零成本抽象

零成本抽象是编程中的一种抽象，一旦编译，与手动编写的代码相比，在性能方面不会产生额外的成本。从本质上讲，抽象并不会增加运行时开销——它就绪你自己编写底层操作一样高效。

Rust 的所有权系统、迭代器和 Trait 经常被称赞为零成本。它们允许开发人员编写优雅、安全和高级的代码，同时仍然保持像C这样底层语音的速度和效率。



# 2. 什么时候抽象不是零成本

## 2.1 动态分派 和 dyn Trait

Rust 中的动态分派允许编写灵活的动态代码，但这是有代价的。当使用 dyn Trait 时，Rust必须通过虚函数表在运行时查找要调用的实际方法，与静态分派（方法调用在编译时解析）相比，这增加了一些开销。

```rust
fn process_shape(shap: &dyn Shape) {
    shape.draw();
}
```

每次调用 `shape.draw()` 都会产生运行时开销，以便通过虚函数表查找实际的方法实现。

**替代方法**：如果性能很关键，且不需要多动态，可考虑使用泛函静态分派

```rust
fn process_shape<T: Shape>(shape: &T) {
    shape.draw();
}
```

编译器在编译时就知道要调用哪个方法，从而消除了运行时查找。



## 2.2 抽象中的分配

Rust 的集合 (Vec、HashMap和String等) 是强大的抽象，但它们依赖动态内存分配。虽然这些方法对于许多用例都是有效的，但如果不小心管理，堆分配的成本可能会累积。

例如：当把元素推入 Vec 时，如果内部容量不够大，Rust 将需要重新分配内存来扩展存储，这种重新分配在时间和内存使用方面都是代价高昂的。

```rust
let mut v = Vec::new();
for i in 0..100 {
    v.push(i);  // 可能触发重新分配
}
```

如果提前知道集合的大小，可使用`Vec::with_capacity()` 预分配内存，以避免频繁的重新分配。

```rust
let mut v = Vec::with_capacity(100);
for i in 0..100 {
    v.push(i);  // 不会重新分配
}
```



## 2.3 `async/await` 异步编程

异步函数生成的状态机可能带来开销。当使用 async fn 时，Rust 会创建一个表示该函数的状态机，它在内存或CPU使用方面是有开销的。

```rust
async fn fetch_data() {
    let data = get_data().await;
}
```

每个 await 点都会增加开销，因为 Rust 需要存储函数的状态并在稍后恢复它。

虽然 async/await 比许多其他模型（如线程）更有效，但它不是零成本的。关键是要理解，虽然异步抽象可以最大限度地减少阻塞，但由于状态机管理，它们仍然会产生性能损失。



## 2.4 闭包 和 Fn Trait

Rust 闭包是简洁的函数式编程的好工具。然而，它们可能会引入开销，这取决于它们的使用方式。当使用闭包时，它会捕获其环境，根据捕获机制的不同，这可能会导致内存分配或额外的间接性性能开销。

例如，通过引用捕获变量的闭包可能会在运行时导致额外的解引用：

```rust
let x = 10;
let clousure = || println!("{}", x);  // Captures `x` by reference
closure();
```

注意：当性能很重要时，需要考虑闭包是按值还是按引用捕获变量，并选择最适合需求的方法。也可以显式地使用 move 闭包来转移所有权，在某些情况下减少间接性。



# 3. 如何识别非零成本抽象

- **分析工具**：perf 和 valgrind 这样的工具可以帮助分析 Rust 应用程序，并确定在哪里引入开销；
- **基准测试**：使用 Rust 内置的基准测试工具（通过 cargo bench）来衡量代码中不同抽象的性能；
- **检查汇编**：对于深度优化，可以使用 `cargo rustc --release -- --emit=asm` 来检查生成的汇编代码，这有助于识别抽象在哪里导致了额外的指令。



# 4. 总结：抽象的成本

Rust 的零成本抽象是强大的，而且通常是正确的，但就像编程中的任何承诺一样。它也有局限性，像动态分派、堆分配和异步等待这样的抽象，虽然在表达性和灵活性方面是无价的，但在优化性能关键型代码时，可能会引入成本。

Rust 提供了微调性能和消除不必要开销的工具，通过了解这些成本产生的位置和原因，可以在不牺牲该语言提供的安全性和表达性的情况下编写高效的 Rust 代码。









































