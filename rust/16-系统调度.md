# 1. 线程

Rust 通过 spawn 函数创建本地操作系统 (native OS) 线程的机制，该函数的参数是一个通过值捕获变量的闭包 (moving closure)

```rust
use std::thread;

static NTHREADS: i32 = 10;

fn main() {
    let mut children = vec![];

    for i in 0..NTHREADS {
        children.push(thread::spawn(move || {
            println!("this is thread number {}", i);
        }));
    }

    for child in children {
        let _ = child.join();
    }
}
```



实现 `map-reduce`：计算一堆数字中每一位的和。将它们分成几块，放入不同的线程，每个线程会把自己那一块的数字的每一位加起来，之后再把每个线程提供的结果加起来。

```rust
use std::thread;

fn main() {
    let data = "86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668";

    // 创建一个向量，存储子线程
    let mut children = vec![];

    // Map 阶段：数据分段，并进行初始化
    let chunked_data = data.split_whitespace();

    for (i, data_segment) in chunked_data.enumerate() {
        println!("data segment {} is \"{}\"", i, data_segment);

        // 'move || -> u32' 语法表示该闭包：
        // * 没有参数（'||'）
        // * 会获取所捕获变量的所有权（'move'）
        // * 返回无符号 32 位整数（'-> u32'）
        children.push(thread::spawn(move || -> u32 {
            let result = data_segment
                .chars()
                .map(|c| c.to_digit(10).expect("should be a digit"))
                .sum();

            println!("process segment {}, result={}", i, result);

            result
        }));
    }

    // Reduce 阶段：收集中间结果，得出最终结果
    let mut intermediate_sums = vec![];
    for child in children {
        intermediate_sums.push(child.join().unwrap());
    }

    println!("Final sum result: {}", intermediate_sums.iter().sum::<u32>());
}
```



# 2. 通道

Rust 为线程之间的通信提供了异步的通道 (channel)，通道允许两个端点之间的信息单向流动：Sender & Receiver

```rust
use std::sync::mpsc;
use std::sync::mpsc::{Sender,Receiver};
use std::thread;

static NTHREADS: i32 = 3;

fn main() {
    // 创建通道
    let (tx, rx): (Sender<i32>, Receiver<i32>) = mpsc::channel();

    for i in 0..NTHREADS {
        let thread_tx = tx.clone();

        thread::spawn(move || {
            thread_tx.send(i).unwrap();

            println!("thread {} finished", i);
        });
    }

    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        ids.push(rx.recv());
    }

    println!("{:?}", ids);
}
```



# 3. 路径

Path 结构体代表了底层文件系统的文件路径，分两种：

- `posix::Path` 针对类 UNIX 系统
- `windows::Path`  针对 Windows 系统

Path 内部并不使用 UTF-8 字符串表示，它存储为若干字节 (`Vec<u8>`) 的 vector。因此将 Path 转换为 &str 并非零开销的，且可能失败 (返回Option)

```rust
use std::path::Path;

fn main() {
    let path = Path::new(".");

    // 转为可显示的结构体
    let display = path.display();
    println!("Display: {:?}", display);

    let new_path = path.join("a").join("b");
    match new_path.to_str() {
        Some(s) => println!("new path is {}", s),
        _ => panic!("new path is not a valid UTF-8 sequence"),
    }
}
```



# 4. 文件 IO

File 结构体表示一个被打开的文件（它包裹了一个文件描述符），并赋予了对所表示的文件读写能力。

文件读写可能出现各种错误，因此 File 的所有方法都返回 `io::Result<T>` 类型，它是 `Result<T, io::Error>` 的别名。



## 4.1 打开文件

open 静态方法能够以只读模式打开一个文件。

File 拥有资源，即文件描述符 (file descriptor)，它会在自身被 drop 时关闭文件。

```rust
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn main() {
    // 文件路径
    let path = Path::new("hello.txt");
    let display = path.display();

    // 以只读方式打开文件
    let mut file = match File::open(&path) {
        Ok(file) => file,
        Err(e) => panic!("Couldn't open {}: {:?}", display, e),
    };

    // 读取文件
    let mut s = String::new();
    match file.read_to_string(&mut s) {
        Ok(_) => println!("{} contains: \n{}", display, s),
        Err(e) => panic!("Couldn't read {}: {:?}", display, e),
    };
}
```



## 4.2 创建文件

create 静态方法以只写模式打开文件。如果文件已存在，则清空文件内容，否则将创建一个新文件。

```rust
use std::fs::File;
use std::io::Write;
use std::path::Path;

static LOREM_IPSUM: &'static str =
    "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
";

fn main() {
    let path = Path::new("lorem_ipsum.txt");
    let display = path.display();

    // 以只写方式打开文件
    let mut file = match File::create(&path) {
        Ok(file) => file,
        Err(e) => panic!("Couldn't create {}: {:?}", display, e),
    };

    // 写入文件内容
    match file.write_all(LOREM_IPSUM.as_bytes()) {
        Ok(_) => println!("Successfully wrote {}", display),
        Err(e) => panic!("Couldn't write {}: {:?}", display, e),
    }
}
```



## 4.3 读取行

方法 lines() 在文件的行上返回一个迭代器。

`File::open` 需要一个泛型 `AsRef<Path>`

```rust
use std::fs::File;
use std::io;
use std::io::BufRead;
use std::path::Path;

fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>
    where P: AsRef<Path> {
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}

fn main() {
    if let Ok(lines) = read_lines("lorem_ipsum.txt") {
        for line in lines {
            if let Ok(ip) = line {
                println!("{}", ip);
            }
        }
    }
}
```



# 5. 子进程

`process::Output` 结构体 表示已结束的子进程 (child process)的输出。

`process::Command` 结构体是一个进程创建者 (process builder).

```rust
use std::process::Command;

fn main() {
    let output = Command::new("rustc")
        .arg("--version")
        .output().unwrap_or_else(|e| {
            panic!("failed to execute process: {}", e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&output.stdout);
        println!("rustc succeeded and stdout was:\n{}", s);
    } else {
        let s = String::from_utf8_lossy(&output.stderr);
        println!("rustc failed and stderr was:\n{}", s);
    }
}
```



## 5.1 管道

`std::Child` 结构体代表了一个正在运行的子进程，它暴露了 stdin、stdout、stderr 句柄，从而可以通过管道与所代表的进行交互。

```rust
use std::io::{Read, Write};
use std::process::{Command, Stdio};

static PANGRAM: &'static str =
"the quick brown fox jumped over the lazy dog\n";

fn main() {
    let process = match Command::new("wc")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn() {
        Ok(process) => process,
        Err(e) => panic!("Couldn't spawn wc: {:?}", e),
    };

    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Ok(_) => println!("sent pangram to wc"),
        Err(e) => panic!("Couldn't write to wc stdin: {:?}", e),
    }

    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&mut s) {
        Ok(_) => println!("wc responded with:\n{}", s),
        Err(e) => panic!("Couldn't read wc stdout: {:?}", e),
    }
}
```



## 5.2 等待

如果项等待一个 `process::Child` 完成，必须调用 `Child::wait`，它会返回一个 `process::ExistStatus`

```rust
use std::process::Command;

fn main() {
    let mut child = Command::new("sleep").arg("5").spawn().unwrap();
    let result = child.wait().unwrap();

    println!("{:?}", result.code());
}
```



# 6. 文件系统

`std::io::fs` 模块包含了文件系统的函数

```rust
use std::fs::{File, OpenOptions};
use std::{fs, io};
use std::io::{Read, Write};
use std::path::Path;

fn cat(path: &Path) -> io::Result<String> {
    let mut f = File::open(path)?;
    let mut s = String::new();

    /*match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }*/

    // 更简便的写法
    f.read_to_string(&mut s)?;
    Ok(s)
}

fn echo(s: &str, path: &Path) -> io::Result<()> {
    let mut f = File::create(path)?;

    f.write_all(s.as_bytes())
}

fn touch(path: &Path) -> io::Result<()> {
    match OpenOptions::new().create(true).write(true).open(path) {
        Ok(_) => Ok(()),
        Err(e) => Err(e),
    }
}

fn main() {
    println!("`mkdir a`");
    match fs::create_dir("a") {
        Ok(_) => {},
        Err(e) => println!("! {:?}", e.kind()),
    }

    println!("`echo hello > a/b.txt`");
    echo("hello", &Path::new("a/b.txt")).unwrap_or_else(|e| {
        println!("! {:?}", e.kind());
    });

    println!("`mkdir -p a/c/d`");
    fs::create_dir_all("a/c/d").unwrap_or_else(|e| {
        println!("! {:?}", e.kind());
    });

    println!("touch a/c/e.txt");
    touch(&Path::new("a/c/e.txt")).unwrap_or_else(|e| {
        println!("! {:?}", e.kind());
    });

    println!("`ln -s ../b.txt a/c/b.txt`");
    if cfg!(target_family = "unix") {
/*        use std::os::unix;
        unix::fs::symlink("../b.txt", "a/c/b.txt").unwrap_or_else(|e| {
            println!("! {:?}", e.kind());
        });*/
    }

    println!("`cat a/c/b.txt`");
    match cat(&Path::new("a/c/b.txt")) {
        Ok(s) => println!("> {}", s),
        Err(e) => println!("! {:?}", e.kind()),
    };

    println!("`ls a`");
    match fs::read_dir("a") {
        Ok(paths) => for path in paths {
            println!("> {:?}", path.unwrap().path());
        },
        Err(e) => println!("! {:?}", e.kind()),
    }

    println!("`r, a/c/e.txt`");
    fs::remove_file("a/c/e.txt").unwrap_or_else(|e| {
        println!("! {:?}", e.kind());
    });

    println!("`rmdir a/c/d`");
    fs::remove_dir("a/c/d").unwrap_or_else(|e| {
        println!("! {:?}", e.kind());
    });
}
```



# 7. 程序参数

## 7.1 标准库

命令行参数通过 `std::env::args` 进行接收，它返回一个迭代器。

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    // 程序名称
    println!("My path is {}.", args[0]);

    // 参数调用 ./args arg1 arg2
    println!("I got {:?} arguments: {:?}", args.len()-1, &args[1..
        ]);
}
```



## 7.2 参数解析

```rust
use std::env;

fn increase(number: i32) {
    println!("{}", number + 1);
}

fn decrease(number: i32) {
    println!("{}", number - 1);
}

fn help() {
    println!("usage:
match_args <string>
    Check whether given string is the answer.
match_args {{increase|decrease}} <integer>
    Increase or decrease give integer by one.")
}

fn main() {
    let args: Vec<String> = env::args().collect();

    match args.len() {
        1 => {
            println!("My name is 'match_args'. Try passing some arguments!");
        },
        2 => match args[1].parse() {
            Ok(42) => println!("This is the answer!"),
            _ => println!("This is not the answer."),
        },
        3 => {
            let cmd = &args[1];
            let num = &args[2];

            let number: i32 = match num.parse() {
                Ok(n) => n,
                Err(_) => {
                    println!("error: second argument not an integer");
                    help();
                    return;
                }
            };

            match &cmd[..] {
                "increase" => increase(number),
                "decrease" => decrease(number),
                _ => {
                    println!("error: invalid command");
                    help();
                }
            }
        },

        _ => {
            help();
        }
    }
}
```



# 8. 外部语言函数接口

Rust 提供了到 C 语言库的外部语言函数接口 (Foreign Function Interface, FFI)。外部语言函数必须在一个 extern 代码块中，且该代码块要带有一个包含名称的 `#[link]` 属性。

```rust
use std::fmt;
use std::fmt::{Formatter, write};

// 单精度复数
#[repr(C)]
#[derive(Clone, Copy)]
struct Complex {
    re: f32,
    im: f32,
}

impl fmt::Debug for Complex {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        if self.im < 0. {
            write!(f, "{}-{}i", self.re, -self.im)
        } else {
            write!(f, "{}+{}i", self.re, self.im)
        }
    }
}

// extern 代码块链接到 libm 库
#[link(name = "m")]
extern {
    fn csqrtf(z: Complex) -> Complex;

    fn ccosf(z: Complex) -> Complex;
}

fn cos(z: Complex) -> Complex {
    unsafe { ccosf(z) }
}

fn main() {
    // z = -1 +0i
    let z = Complex { re: -1., im: 0. };

    // 调用外部语言函数是不安全操作
    let z_sqrt = unsafe { csqrtf(z) };
    println!("the square root of {:?} is {:?}", z, z_sqrt);

    // 调用不安全操作的安全API封装
    println!("cos({:?}) = {:?}", z, cos(z));
}
```















