# 1. 算法步骤

1. 从左至右扫描中缀表达式
2. 若读取到操作数，则判断该操作数类型，并将其加入后缀表达式中
3. 若读取到括号
   1. 左括号"("：将其直接存入运算符堆栈
   2. 右括号")"：将运算符栈中的运算符依次加到后缀表达式中，直到"("为止
4. 若读取到运算符
   1. 若运算符栈的栈顶为括号，直接入栈
   2. 若比运算符的栈顶的运算符优先级高，直接入栈
   3. 若比运算符的栈顶的运算符优先级低或相等，则先栈顶出栈并加到后缀表达式中，后再将当前运算符入栈



# 2. 实现

## 2.1 中缀转后缀

```go
func transExpress(middleExpress string) []string {
	var postExpress []string
	var opStack = &stack{}

	// 操作位置
	var i int

	for i < len(middleExpress) {
		ch := middleExpress[i]
		if ch >= '0' && ch <= '9' {
			var nums []byte
			for i < len(middleExpress) {
				if middleExpress[i] < '0' || middleExpress[i] > '9' {
					break
				}
				nums = append(nums, middleExpress[i])
				i++
			}

			postExpress = append(postExpress, string(nums))
		} else if ch == '(' {
			opStack.push(ch)
			i++
		} else if ch == ')' {
			for !opStack.empty() {
				op := opStack.pop().(byte)
				if op == '(' {
					break
				}
				postExpress = append(postExpress, string([]byte{op}))
			}
			i++
		} else if ch == '+' || ch == '-' || ch == '*' || ch == '/' {
			// 栈为空，直接入栈
			if opStack.empty() {
				opStack.push(ch)
				i++
				continue
			}

			// 栈顶, 为括号时，直接入栈
			top := opStack.peek().(byte)
			if top == '(' || top == ')' {
				opStack.push(ch)
				i++
				continue
			}

			// 栈顶优选级高或相等，先将栈顶存入后缀表达式
			if priority(top) >= priority(ch) {
				postExpress = append(postExpress, string([]byte{top}))

				// 栈顶出栈
				opStack.pop()
			}

			// 将当前操作符入栈
			opStack.push(ch)
			i++
		} else {
			i++
		}
	}

	// 剩下操作符
	for !opStack.empty() {
		op := opStack.pop().(byte)
		postExpress = append(postExpress, string([]byte{op}))
	}

	return postExpress
}

func priority(op byte) int {
	switch op {
	case '+', '-':
		return 0
	case '*', '/':
		return 1
	}
	return -1
}
```

## 2.2 后缀表达式计算

```go
func calc(postExpress []string) int {
	var numStack = &stack{}

	for _, v := range postExpress {
		switch v {
		case "+", "-", "*", "/":
			s1, s2 := numStack.pop().(string), numStack.pop().(string)
			n1, _ := strconv.Atoi(s1)
			n2, _ := strconv.Atoi(s2)
			var res int

			switch v {
			case "+":
				res = n2 + n1
			case "-":
				res = n2 - n1
			case "*":
				res = n2 * n1
			case "/":
				res = n2 / n1
			}

			numStack.push(strconv.Itoa(res))

		default:
			numStack.push(v)
		}
	}

	res, _ := strconv.Atoi(numStack.pop().(string))
	return res
}
```

## 2.3 示例

```go
func TestCalc(t *testing.T) {
	middleExpress := "9 + (3 - 1) * 3 + 10 / 2"
	expectedPostExpress := "931-3*102/++"
	expectedResult := 20

	express := transExpress(middleExpress)
	if strings.Join(express, "") != expectedPostExpress {
		t.Errorf("Expected post express is %s, but got %s", expectedPostExpress, express)
	}

	actual := calc(express)
	if actual != expectedResult {
		t.Errorf("Expected post express is %d, but got %d", expectedResult, actual)
	}

	t.Log("Done")
}
```

