# 1. 一致性理论

分布式事务的目的是保证分库数据的一致性，而跨库事务会遇到各种不可控的问题，如个别节点永久性宕机，像单机事务一样的ACID是不可能的。



## 1.1 CAP 理论

在分布式系统中，一致性 (Consistency)、可用性 (Availability)、分区容忍性 (Partition Tolerance) 3个要素最多只能满足两个，不可兼得。其中分区容忍性不可或缺。

![a](https://cdn.jsdelivr.net/gh/elihe2011/bedgraph@master/microservice/distributed_cap.png)

**一致性**：分布式环境下多个节点的数据是否强一致

**可用性**：分布式服务能一直保证可用状态，当用户发出一个请求后，服务能在有限时间内返回结果

**分区容忍性**：对网络分区的容忍性



常用分布式数据库：

- Cassandra、Dynamo：优选AP，弱化C
- HBase、MongoDB：优选CP，弱化A



## 1.2 Base 理论

**基本可用** (Basically Available)：出故障时，允许损失部分可用性来保证核心可用。

**软状态** (Soft State)：允许存在中间状态，该中间状态不会影响到系统的整体可用性。

**最终一致性** (Eventual Consistency)：所有副本数据，在经过一定时间后，最终能够达成一致的状态。



## 1.3 一致性模型

**强一致性**：数据更新成功后，任意时刻所有副本中的数据都是一致的。一般采用同步的方式实现。

**弱一致性**：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久后可读到。

**最终一致性**：在弱一致性基础之上，保证最终数据一致。



# 2. 分布式事务方案

分布式事务，主要讨论的是 **强一致性** 和 **最终一致性** 的解决方案。经典方案包括：

- 两阶段提交 (2PC, Two-phase Commit)
- eBay 事件队列
- TCC 补偿 (Try-Confirm-Cancel)
- 缓存数据最终一致性



## 2.1 2PC - 强一致性

核心原理：通过提交分阶段和记录日志方式，记录下事务提交所处的阶段状态。在组件宕机重启后，可通过日志恢复事务提交的阶段状态，并在该状态点重试。

如Coordinator重启后，通过日志可以确定提交处于Prepare还是PrepareAll状态：

- Prepare状态：说明有节点可能没有Prepare成功，或所有节点Prepare成功但还没有下发Commit，状态恢复后给所有节点下发RollBack
- PrepareAll状态：需要给所有节点下发Commit，数据库节点需要保证Commit幂等

![a](https://cdn.jsdelivr.net/gh/elihe2011/bedgraph@master/microservice/distributed_2pc.jpg)

**2PC方案问题：**

- 同步阻塞
- 数据不一致
- 单点问题

升级 3PC 改进：

- 增加超时机制
- 两阶段之间插入准备阶段

3PC 方案依旧存在问题，要彻底避免数据不一致，可采用 Paxos 或 Raft 算法



## 2.2 eBay 事件队列  —— 最终一致性

核心思想：将需要分布式处理的认为，通过消息或者日志的方式来异步执行，消息或日志可以存到本地文件、数据库或消息队列，再通过业务规则进行失败重试，它要求各服务的接口是冥等的。



## 2.3 TCC 补偿模式 —— 最终一致性

某业务模型，用服务A, B, C, D 共同组成的一个微服务架构系统，服务A需要依次调用服务 B, C, D 共同完成一个操作。但 A 调用 D 失败时，若要保证整个系统数据的一致性，需要对 B，C 的调用操作进行回滚。

![a](https://cdn.jsdelivr.net/gh/elihe2011/bedgraph@master/microservice/distributed_tcc.png)

实现关键：

- 服务调用链必须被记录下来
- 每个服务需要提供一组业务逻辑回滚操作，互为补偿，同时回滚操作要保证冥等
- 必须按失败原因执行不同的回滚策略



## 2.4 缓存数据最终一致性

解决缓存和数据库数据不一致问题的方案：

- 为缓存设置过期时间，当缓存过期后，从数据库中获取数据，并重新放入缓存。
- 数据库数据更新后，同步删除缓存数据，保证下一次操作先从数据库获取然后同步到缓存。



# 3. 冥等性

**冥等性**：任意多次执行，产生的影响均与一次执行的影响相同。即使用相同的参数，可重复执行，得到的结果是相同的。

冥等性场景：

- 查询
- 删除
- 唯一索引
- token 机制
- 悲观锁
- 乐观锁
- 分布式锁
- 消息队列缓冲







